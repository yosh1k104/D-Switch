
hello-world.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000004fa  00800100  00005326  000053ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005326  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000008c4  008005fa  008005fa  000058b4  2**0
                  ALLOC
  3 .stab         000027e4  00000000  00000000  000058b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000eed  00000000  00000000  00008098  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000540  00000000  00000000  00008f85  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000161b  00000000  00000000  000094c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000b0d1  00000000  00000000  0000aae0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003f04  00000000  00000000  00015bb1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000069e7  00000000  00000000  00019ab5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001340  00000000  00000000  0002049c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002c57  00000000  00000000  000217dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000477b  00000000  00000000  00024433  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 0000167d  00000000  00000000  00028bae  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000198  00000000  00000000  0002a22b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 98 00 	jmp	0x130	; 0x130 <__ctors_end>
       4:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
       8:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
       c:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      10:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      14:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      18:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      1c:	0c 94 ef 22 	jmp	0x45de	; 0x45de <__vector_7>
      20:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      24:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      28:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      2c:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      30:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      34:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      38:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      3c:	0c 94 6c 05 	jmp	0xad8	; 0xad8 <__vector_15>
      40:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      44:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      48:	0c 94 46 1c 	jmp	0x388c	; 0x388c <__vector_18>
      4c:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      50:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      54:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      58:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      5c:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      60:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      64:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      68:	0c 94 29 06 	jmp	0xc52	; 0xc52 <__vector_26>
      6c:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      70:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      74:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      78:	0c 94 74 1c 	jmp	0x38e8	; 0x38e8 <__vector_30>
      7c:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      80:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      84:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>
      88:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__bad_interrupt>

0000008c <__c.2854>:
      8c:	43 6f 6e 74 69 6b 69 20 32 2e 36 20 73 74 61 72     Contiki 2.6 star
      9c:	74 65 64 2e 20 4e 6f 64 65 20 69 64 20 25 75 0a     ted. Node id %u.
	...

000000ad <__c.2264>:
      ad:	25 73 20 25 73 2c 20 63 68 61 6e 6e 65 6c 20 63     %s %s, channel c
      bd:	68 65 63 6b 20 72 61 74 65 20 25 64 20 48 7a 2c     heck rate %d Hz,
      cd:	20 72 61 64 69 6f 20 63 68 61 6e 6e 65 6c 20 25      radio channel %
      dd:	64 0a 00                                            d..

000000e0 <__c.2262>:
      e0:	4d 41 43 20 25 30 32 78 3a 25 30 32 78 3a 25 30     MAC %02x:%02x:%0
      f0:	32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25 30 32     2x:%02x:%02x:%02
     100:	78 3a 25 30 32 78 3a 25 30 32 78 0a 00              x:%02x:%02x..

0000010d <__c.2255>:
     10d:	25 64 0a 00                                         %d..

00000111 <__c.2250>:
     111:	25 64 2e 00                                         %d..

00000115 <__c.2248>:
     115:	52 69 6d 65 20 73 74 61 72 74 65 64 20 77 69 74     Rime started wit
     125:	68 20 61 64 64 72 65 73 73 20 00                    h address .

00000130 <__ctors_end>:
     130:	11 24       	eor	r1, r1
     132:	1f be       	out	0x3f, r1	; 63
     134:	cf ef       	ldi	r28, 0xFF	; 255
     136:	d0 e1       	ldi	r29, 0x10	; 16
     138:	de bf       	out	0x3e, r29	; 62
     13a:	cd bf       	out	0x3d, r28	; 61

0000013c <__do_copy_data>:
     13c:	15 e0       	ldi	r17, 0x05	; 5
     13e:	a0 e0       	ldi	r26, 0x00	; 0
     140:	b1 e0       	ldi	r27, 0x01	; 1
     142:	e6 e2       	ldi	r30, 0x26	; 38
     144:	f3 e5       	ldi	r31, 0x53	; 83
     146:	00 e0       	ldi	r16, 0x00	; 0
     148:	0b bf       	out	0x3b, r16	; 59
     14a:	02 c0       	rjmp	.+4      	; 0x150 <__do_copy_data+0x14>
     14c:	07 90       	elpm	r0, Z+
     14e:	0d 92       	st	X+, r0
     150:	aa 3f       	cpi	r26, 0xFA	; 250
     152:	b1 07       	cpc	r27, r17
     154:	d9 f7       	brne	.-10     	; 0x14c <__do_copy_data+0x10>

00000156 <__do_clear_bss>:
     156:	1e e0       	ldi	r17, 0x0E	; 14
     158:	aa ef       	ldi	r26, 0xFA	; 250
     15a:	b5 e0       	ldi	r27, 0x05	; 5
     15c:	01 c0       	rjmp	.+2      	; 0x160 <.do_clear_bss_start>

0000015e <.do_clear_bss_loop>:
     15e:	1d 92       	st	X+, r1

00000160 <.do_clear_bss_start>:
     160:	ae 3b       	cpi	r26, 0xBE	; 190
     162:	b1 07       	cpc	r27, r17
     164:	e1 f7       	brne	.-8      	; 0x15e <.do_clear_bss_loop>
     166:	0e 94 cd 03 	call	0x79a	; 0x79a <main>
     16a:	0c 94 91 29 	jmp	0x5322	; 0x5322 <_exit>

0000016e <__bad_interrupt>:
     16e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000172 <process_thread_hello_world_three_process>:
}


/* Implementation of the first process */
PROCESS_THREAD(hello_world_three_process, ev, data)
{
     172:	0f 93       	push	r16
     174:	1f 93       	push	r17
     176:	df 93       	push	r29
     178:	cf 93       	push	r28
     17a:	0f 92       	push	r0
     17c:	cd b7       	in	r28, 0x3d	; 61
     17e:	de b7       	in	r29, 0x3e	; 62
     180:	8c 01       	movw	r16, r24
    // between kernel calls.
    static struct etimer timer;
    static int count = 0;
    
    // any process mustt start with this.
    PROCESS_BEGIN();
     182:	dc 01       	movw	r26, r24
     184:	8d 91       	ld	r24, X+
     186:	9c 91       	ld	r25, X
     188:	11 97       	sbiw	r26, 0x01	; 1
     18a:	00 97       	sbiw	r24, 0x00	; 0
     18c:	29 f0       	breq	.+10     	; 0x198 <process_thread_hello_world_three_process+0x26>
     18e:	8e 38       	cpi	r24, 0x8E	; 142
     190:	91 05       	cpc	r25, r1
     192:	09 f0       	breq	.+2      	; 0x196 <process_thread_hello_world_three_process+0x24>
     194:	4d c0       	rjmp	.+154    	; 0x230 <process_thread_hello_world_three_process+0xbe>
     196:	11 c0       	rjmp	.+34     	; 0x1ba <process_thread_hello_world_three_process+0x48>
    
    // set the etimer module to generate an event in one second.
    etimer_set(&timer, CLOCK_CONF_SECOND);
     198:	8c ef       	ldi	r24, 0xFC	; 252
     19a:	95 e0       	ldi	r25, 0x05	; 5
     19c:	60 e8       	ldi	r22, 0x80	; 128
     19e:	70 e0       	ldi	r23, 0x00	; 0
     1a0:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <etimer_set>
    while (1)
    {
        // wait here for an event to happen
        PROCESS_WAIT_EVENT();
     1a4:	8e e8       	ldi	r24, 0x8E	; 142
     1a6:	90 e0       	ldi	r25, 0x00	; 0
     1a8:	f8 01       	movw	r30, r16
     1aa:	91 83       	std	Z+1, r25	; 0x01
     1ac:	80 83       	st	Z, r24
     1ae:	80 e0       	ldi	r24, 0x00	; 0
     1b0:	91 e0       	ldi	r25, 0x01	; 1
     1b2:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
     1b6:	81 e0       	ldi	r24, 0x01	; 1
     1b8:	40 c0       	rjmp	.+128    	; 0x23a <process_thread_hello_world_three_process+0xc8>

        printf("----------Got event number %d in hello_world_three-----------\n", ev);
     1ba:	00 d0       	rcall	.+0      	; 0x1bc <process_thread_hello_world_three_process+0x4a>
     1bc:	00 d0       	rcall	.+0      	; 0x1be <process_thread_hello_world_three_process+0x4c>
     1be:	ed b7       	in	r30, 0x3d	; 61
     1c0:	fe b7       	in	r31, 0x3e	; 62
     1c2:	31 96       	adiw	r30, 0x01	; 1
     1c4:	8f e1       	ldi	r24, 0x1F	; 31
     1c6:	91 e0       	ldi	r25, 0x01	; 1
     1c8:	ad b7       	in	r26, 0x3d	; 61
     1ca:	be b7       	in	r27, 0x3e	; 62
     1cc:	12 96       	adiw	r26, 0x02	; 2
     1ce:	9c 93       	st	X, r25
     1d0:	8e 93       	st	-X, r24
     1d2:	11 97       	sbiw	r26, 0x01	; 1
     1d4:	62 83       	std	Z+2, r22	; 0x02
     1d6:	13 82       	std	Z+3, r1	; 0x03
     1d8:	69 83       	std	Y+1, r22	; 0x01
     1da:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>

        // if the event is the timer event as expected...
        if(ev == PROCESS_EVENT_TIMER)
     1de:	0f 90       	pop	r0
     1e0:	0f 90       	pop	r0
     1e2:	0f 90       	pop	r0
     1e4:	0f 90       	pop	r0
     1e6:	69 81       	ldd	r22, Y+1	; 0x01
     1e8:	68 38       	cpi	r22, 0x88	; 136
     1ea:	e1 f6       	brne	.-72     	; 0x1a4 <process_thread_hello_world_three_process+0x32>
        {
            // do the process work
            //printf("Hello, world #%i\n", count);
            printf("Hello, world3: %d\n", count);
     1ec:	00 d0       	rcall	.+0      	; 0x1ee <process_thread_hello_world_three_process+0x7c>
     1ee:	00 d0       	rcall	.+0      	; 0x1f0 <process_thread_hello_world_three_process+0x7e>
     1f0:	8e e5       	ldi	r24, 0x5E	; 94
     1f2:	91 e0       	ldi	r25, 0x01	; 1
     1f4:	ed b7       	in	r30, 0x3d	; 61
     1f6:	fe b7       	in	r31, 0x3e	; 62
     1f8:	92 83       	std	Z+2, r25	; 0x02
     1fa:	81 83       	std	Z+1, r24	; 0x01
     1fc:	80 91 fa 05 	lds	r24, 0x05FA
     200:	90 91 fb 05 	lds	r25, 0x05FB
     204:	94 83       	std	Z+4, r25	; 0x04
     206:	83 83       	std	Z+3, r24	; 0x03
     208:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>
            count ++;
     20c:	80 91 fa 05 	lds	r24, 0x05FA
     210:	90 91 fb 05 	lds	r25, 0x05FB
     214:	01 96       	adiw	r24, 0x01	; 1
     216:	90 93 fb 05 	sts	0x05FB, r25
     21a:	80 93 fa 05 	sts	0x05FA, r24
            
            // reset the timer so it will generate an other event
            // the exact same time after it expired (periodicity guaranteed)
            etimer_reset(&timer);
     21e:	0f 90       	pop	r0
     220:	0f 90       	pop	r0
     222:	0f 90       	pop	r0
     224:	0f 90       	pop	r0
     226:	8c ef       	ldi	r24, 0xFC	; 252
     228:	95 e0       	ldi	r25, 0x05	; 5
     22a:	0e 94 ee 02 	call	0x5dc	; 0x5dc <etimer_reset>
     22e:	ba cf       	rjmp	.-140    	; 0x1a4 <process_thread_hello_world_three_process+0x32>
        }
        
        // and loop
    }
    // any process must end with this, even if it is never reached.
    PROCESS_END();
     230:	d8 01       	movw	r26, r16
     232:	11 96       	adiw	r26, 0x01	; 1
     234:	1c 92       	st	X, r1
     236:	1e 92       	st	-X, r1
     238:	83 e0       	ldi	r24, 0x03	; 3
}
     23a:	0f 90       	pop	r0
     23c:	cf 91       	pop	r28
     23e:	df 91       	pop	r29
     240:	1f 91       	pop	r17
     242:	0f 91       	pop	r16
     244:	08 95       	ret

00000246 <process_thread_hello_world_two_process>:
}  


/* Implementation of the first process */
PROCESS_THREAD(hello_world_two_process, ev, data)
{
     246:	0f 93       	push	r16
     248:	1f 93       	push	r17
     24a:	df 93       	push	r29
     24c:	cf 93       	push	r28
     24e:	0f 92       	push	r0
     250:	cd b7       	in	r28, 0x3d	; 61
     252:	de b7       	in	r29, 0x3e	; 62
     254:	8c 01       	movw	r16, r24
    // between kernel calls.
    static struct etimer timer;
    static int count = 0;
    
    // any process mustt start with this.
    PROCESS_BEGIN();
     256:	dc 01       	movw	r26, r24
     258:	8d 91       	ld	r24, X+
     25a:	9c 91       	ld	r25, X
     25c:	11 97       	sbiw	r26, 0x01	; 1
     25e:	00 97       	sbiw	r24, 0x00	; 0
     260:	29 f0       	breq	.+10     	; 0x26c <process_thread_hello_world_two_process+0x26>
     262:	86 36       	cpi	r24, 0x66	; 102
     264:	91 05       	cpc	r25, r1
     266:	09 f0       	breq	.+2      	; 0x26a <process_thread_hello_world_two_process+0x24>
     268:	4d c0       	rjmp	.+154    	; 0x304 <process_thread_hello_world_two_process+0xbe>
     26a:	11 c0       	rjmp	.+34     	; 0x28e <process_thread_hello_world_two_process+0x48>
    
    // set the etimer module to generate an event in one second.
    etimer_set(&timer, CLOCK_CONF_SECOND);
     26c:	86 e0       	ldi	r24, 0x06	; 6
     26e:	96 e0       	ldi	r25, 0x06	; 6
     270:	60 e8       	ldi	r22, 0x80	; 128
     272:	70 e0       	ldi	r23, 0x00	; 0
     274:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <etimer_set>
    while (1)
    {
        // wait here for an event to happen
        PROCESS_WAIT_EVENT();
     278:	86 e6       	ldi	r24, 0x66	; 102
     27a:	90 e0       	ldi	r25, 0x00	; 0
     27c:	f8 01       	movw	r30, r16
     27e:	91 83       	std	Z+1, r25	; 0x01
     280:	80 83       	st	Z, r24
     282:	80 e0       	ldi	r24, 0x00	; 0
     284:	91 e0       	ldi	r25, 0x01	; 1
     286:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	40 c0       	rjmp	.+128    	; 0x30e <process_thread_hello_world_two_process+0xc8>

        printf("----------Got event number %d in hello_world_two-----------\n", ev);
     28e:	00 d0       	rcall	.+0      	; 0x290 <process_thread_hello_world_two_process+0x4a>
     290:	00 d0       	rcall	.+0      	; 0x292 <process_thread_hello_world_two_process+0x4c>
     292:	ed b7       	in	r30, 0x3d	; 61
     294:	fe b7       	in	r31, 0x3e	; 62
     296:	31 96       	adiw	r30, 0x01	; 1
     298:	81 e7       	ldi	r24, 0x71	; 113
     29a:	91 e0       	ldi	r25, 0x01	; 1
     29c:	ad b7       	in	r26, 0x3d	; 61
     29e:	be b7       	in	r27, 0x3e	; 62
     2a0:	12 96       	adiw	r26, 0x02	; 2
     2a2:	9c 93       	st	X, r25
     2a4:	8e 93       	st	-X, r24
     2a6:	11 97       	sbiw	r26, 0x01	; 1
     2a8:	62 83       	std	Z+2, r22	; 0x02
     2aa:	13 82       	std	Z+3, r1	; 0x03
     2ac:	69 83       	std	Y+1, r22	; 0x01
     2ae:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>

        // if the event is the timer event as expected...
        if(ev == PROCESS_EVENT_TIMER)
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	0f 90       	pop	r0
     2b8:	0f 90       	pop	r0
     2ba:	69 81       	ldd	r22, Y+1	; 0x01
     2bc:	68 38       	cpi	r22, 0x88	; 136
     2be:	e1 f6       	brne	.-72     	; 0x278 <process_thread_hello_world_two_process+0x32>
        {
            // do the process work
            //printf("Hello, world #%i\n", count);
            printf("Hello, world2: %d\n", count);
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <process_thread_hello_world_two_process+0x7c>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <process_thread_hello_world_two_process+0x7e>
     2c4:	8e ea       	ldi	r24, 0xAE	; 174
     2c6:	91 e0       	ldi	r25, 0x01	; 1
     2c8:	ed b7       	in	r30, 0x3d	; 61
     2ca:	fe b7       	in	r31, 0x3e	; 62
     2cc:	92 83       	std	Z+2, r25	; 0x02
     2ce:	81 83       	std	Z+1, r24	; 0x01
     2d0:	80 91 04 06 	lds	r24, 0x0604
     2d4:	90 91 05 06 	lds	r25, 0x0605
     2d8:	94 83       	std	Z+4, r25	; 0x04
     2da:	83 83       	std	Z+3, r24	; 0x03
     2dc:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>
            count ++;
     2e0:	80 91 04 06 	lds	r24, 0x0604
     2e4:	90 91 05 06 	lds	r25, 0x0605
     2e8:	01 96       	adiw	r24, 0x01	; 1
     2ea:	90 93 05 06 	sts	0x0605, r25
     2ee:	80 93 04 06 	sts	0x0604, r24
            
            // reset the timer so it will generate an other event
            // the exact same time after it expired (periodicity guaranteed)
            etimer_reset(&timer);
     2f2:	0f 90       	pop	r0
     2f4:	0f 90       	pop	r0
     2f6:	0f 90       	pop	r0
     2f8:	0f 90       	pop	r0
     2fa:	86 e0       	ldi	r24, 0x06	; 6
     2fc:	96 e0       	ldi	r25, 0x06	; 6
     2fe:	0e 94 ee 02 	call	0x5dc	; 0x5dc <etimer_reset>
     302:	ba cf       	rjmp	.-140    	; 0x278 <process_thread_hello_world_two_process+0x32>
        }
        
        // and loop
    }
    // any process must end with this, even if it is never reached.
    PROCESS_END();
     304:	d8 01       	movw	r26, r16
     306:	11 96       	adiw	r26, 0x01	; 1
     308:	1c 92       	st	X, r1
     30a:	1e 92       	st	-X, r1
     30c:	83 e0       	ldi	r24, 0x03	; 3
}
     30e:	0f 90       	pop	r0
     310:	cf 91       	pop	r28
     312:	df 91       	pop	r29
     314:	1f 91       	pop	r17
     316:	0f 91       	pop	r16
     318:	08 95       	ret

0000031a <periodic_rtimer>:
AUTOSTART_PROCESSES(&hello_world_one_process, 
                    &hello_world_two_process,
                    &hello_world_three_process);  
   
// the function which gets called each time the rtimer triggers  
static char periodic_rtimer(struct rtimer *rt, void* ptr){  
     31a:	0f 93       	push	r16
     31c:	1f 93       	push	r17
     31e:	cf 93       	push	r28
     320:	df 93       	push	r29
    uint8_t ret;  
    rtimer_clock_t time_now = RTIMER_NOW();  
     322:	c0 91 88 00 	lds	r28, 0x0088
     326:	d0 91 89 00 	lds	r29, 0x0089
    
    printf("Hello from rtimer!!!\n");  
     32a:	81 ec       	ldi	r24, 0xC1	; 193
     32c:	91 e0       	ldi	r25, 0x01	; 1
     32e:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
    
    ret = rtimer_set(&my_timer, time_now + PERIOD_T, 1,   
     332:	be 01       	movw	r22, r28
     334:	60 56       	subi	r22, 0x60	; 96
     336:	73 47       	sbci	r23, 0x73	; 115
     338:	8e e0       	ldi	r24, 0x0E	; 14
     33a:	96 e0       	ldi	r25, 0x06	; 6
     33c:	41 e0       	ldi	r20, 0x01	; 1
     33e:	50 e0       	ldi	r21, 0x00	; 0
     340:	2d e8       	ldi	r18, 0x8D	; 141
     342:	31 e0       	ldi	r19, 0x01	; 1
     344:	00 e0       	ldi	r16, 0x00	; 0
     346:	10 e0       	ldi	r17, 0x00	; 0
     348:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <rtimer_set>
          (void (*)(struct rtimer *, void *))periodic_rtimer, NULL);  
    if(ret){  
     34c:	88 23       	and	r24, r24
     34e:	a9 f0       	breq	.+42     	; 0x37a <periodic_rtimer+0x60>
        printf("Error Timer: %u\n", ret);  
     350:	00 d0       	rcall	.+0      	; 0x352 <periodic_rtimer+0x38>
     352:	00 d0       	rcall	.+0      	; 0x354 <periodic_rtimer+0x3a>
     354:	ed b7       	in	r30, 0x3d	; 61
     356:	fe b7       	in	r31, 0x3e	; 62
     358:	31 96       	adiw	r30, 0x01	; 1
     35a:	26 ed       	ldi	r18, 0xD6	; 214
     35c:	31 e0       	ldi	r19, 0x01	; 1
     35e:	ad b7       	in	r26, 0x3d	; 61
     360:	be b7       	in	r27, 0x3e	; 62
     362:	12 96       	adiw	r26, 0x02	; 2
     364:	3c 93       	st	X, r19
     366:	2e 93       	st	-X, r18
     368:	11 97       	sbiw	r26, 0x01	; 1
     36a:	82 83       	std	Z+2, r24	; 0x02
     36c:	13 82       	std	Z+3, r1	; 0x03
     36e:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>
     372:	0f 90       	pop	r0
     374:	0f 90       	pop	r0
     376:	0f 90       	pop	r0
     378:	0f 90       	pop	r0
    }  
    return 1;  
}  
     37a:	81 e0       	ldi	r24, 0x01	; 1
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
     380:	1f 91       	pop	r17
     382:	0f 91       	pop	r16
     384:	08 95       	ret

00000386 <process_thread_hello_world_one_process>:
  

PROCESS_THREAD(hello_world_one_process, ev, data)  
{  
     386:	cf 93       	push	r28
     388:	df 93       	push	r29
     38a:	ec 01       	movw	r28, r24
    PROCESS_BEGIN();  
     38c:	88 81       	ld	r24, Y
     38e:	99 81       	ldd	r25, Y+1	; 0x01
     390:	00 97       	sbiw	r24, 0x00	; 0
     392:	21 f0       	breq	.+8      	; 0x39c <process_thread_hello_world_one_process+0x16>
     394:	80 35       	cpi	r24, 0x50	; 80
     396:	91 05       	cpc	r25, r1
     398:	a9 f4       	brne	.+42     	; 0x3c4 <process_thread_hello_world_one_process+0x3e>
     39a:	0a c0       	rjmp	.+20     	; 0x3b0 <process_thread_hello_world_one_process+0x2a>
     
    printf("Starting the application...\n");  
     39c:	87 ee       	ldi	r24, 0xE7	; 231
     39e:	91 e0       	ldi	r25, 0x01	; 1
     3a0:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
     
    periodic_rtimer(&my_timer, NULL);  
     3a4:	8e e0       	ldi	r24, 0x0E	; 14
     3a6:	96 e0       	ldi	r25, 0x06	; 6
     3a8:	60 e0       	ldi	r22, 0x00	; 0
     3aa:	70 e0       	ldi	r23, 0x00	; 0
     3ac:	0e 94 8d 01 	call	0x31a	; 0x31a <periodic_rtimer>
     
    while(1){             
        PROCESS_YIELD();  
     3b0:	80 e5       	ldi	r24, 0x50	; 80
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	99 83       	std	Y+1, r25	; 0x01
     3b6:	88 83       	st	Y, r24
     3b8:	80 e0       	ldi	r24, 0x00	; 0
     3ba:	91 e0       	ldi	r25, 0x01	; 1
     3bc:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
     3c0:	81 e0       	ldi	r24, 0x01	; 1
     3c2:	03 c0       	rjmp	.+6      	; 0x3ca <process_thread_hello_world_one_process+0x44>
    }  
    PROCESS_END();  
     3c4:	19 82       	std	Y+1, r1	; 0x01
     3c6:	18 82       	st	Y, r1
     3c8:	83 e0       	ldi	r24, 0x03	; 3
}  
     3ca:	df 91       	pop	r29
     3cc:	cf 91       	pop	r28
     3ce:	08 95       	ret

000003d0 <update_time>:
{
  clock_time_t tdist;
  clock_time_t now;
  struct etimer *t;

  if (timerlist == NULL) {
     3d0:	80 91 14 06 	lds	r24, 0x0614
     3d4:	90 91 15 06 	lds	r25, 0x0615
     3d8:	00 97       	sbiw	r24, 0x00	; 0
     3da:	29 f4       	brne	.+10     	; 0x3e6 <update_time+0x16>
    next_expiration = 0;
     3dc:	10 92 17 06 	sts	0x0617, r1
     3e0:	10 92 16 06 	sts	0x0616, r1
     3e4:	08 95       	ret
  } else {
    now = clock_time();
     3e6:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <clock_time>
    t = timerlist;
     3ea:	e0 91 14 06 	lds	r30, 0x0614
     3ee:	f0 91 15 06 	lds	r31, 0x0615
    /* Must calculate distance to next time into account due to wraps */
    tdist = t->timer.start + t->timer.interval - now;
     3f2:	22 81       	ldd	r18, Z+2	; 0x02
     3f4:	33 81       	ldd	r19, Z+3	; 0x03
     3f6:	40 81       	ld	r20, Z
     3f8:	51 81       	ldd	r21, Z+1	; 0x01
     3fa:	24 0f       	add	r18, r20
     3fc:	35 1f       	adc	r19, r21
     3fe:	28 1b       	sub	r18, r24
     400:	39 0b       	sbc	r19, r25
     402:	0c c0       	rjmp	.+24     	; 0x41c <update_time+0x4c>
    for(t = t->next; t != NULL; t = t->next) {
      if(t->timer.start + t->timer.interval - now < tdist) {
     404:	42 81       	ldd	r20, Z+2	; 0x02
     406:	53 81       	ldd	r21, Z+3	; 0x03
     408:	60 81       	ld	r22, Z
     40a:	71 81       	ldd	r23, Z+1	; 0x01
     40c:	46 0f       	add	r20, r22
     40e:	57 1f       	adc	r21, r23
     410:	48 1b       	sub	r20, r24
     412:	59 0b       	sbc	r21, r25
  } else {
    now = clock_time();
    t = timerlist;
    /* Must calculate distance to next time into account due to wraps */
    tdist = t->timer.start + t->timer.interval - now;
    for(t = t->next; t != NULL; t = t->next) {
     414:	42 17       	cp	r20, r18
     416:	53 07       	cpc	r21, r19
     418:	08 f4       	brcc	.+2      	; 0x41c <update_time+0x4c>
     41a:	9a 01       	movw	r18, r20
     41c:	04 80       	ldd	r0, Z+4	; 0x04
     41e:	f5 81       	ldd	r31, Z+5	; 0x05
     420:	e0 2d       	mov	r30, r0
     422:	30 97       	sbiw	r30, 0x00	; 0
     424:	79 f7       	brne	.-34     	; 0x404 <update_time+0x34>
      if(t->timer.start + t->timer.interval - now < tdist) {
	tdist = t->timer.start + t->timer.interval - now;
      }
    }
    next_expiration = now + tdist;
     426:	28 0f       	add	r18, r24
     428:	39 1f       	adc	r19, r25
     42a:	30 93 17 06 	sts	0x0617, r19
     42e:	20 93 16 06 	sts	0x0616, r18
     432:	08 95       	ret

00000434 <etimer_request_poll>:
}
/*---------------------------------------------------------------------------*/
void
etimer_request_poll(void)
{
  process_poll(&etimer_process);
     434:	81 eb       	ldi	r24, 0xB1	; 177
     436:	92 e0       	ldi	r25, 0x02	; 2
     438:	0e 94 90 15 	call	0x2b20	; 0x2b20 <process_poll>
}
     43c:	08 95       	ret

0000043e <process_thread_etimer_process>:
    next_expiration = now + tdist;
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(etimer_process, ev, data)
{
     43e:	cf 92       	push	r12
     440:	df 92       	push	r13
     442:	ef 92       	push	r14
     444:	ff 92       	push	r15
     446:	0f 93       	push	r16
     448:	1f 93       	push	r17
     44a:	cf 93       	push	r28
     44c:	df 93       	push	r29
     44e:	7c 01       	movw	r14, r24
  struct etimer *t, *u;
	
  PROCESS_BEGIN();
     450:	fc 01       	movw	r30, r24
     452:	80 81       	ld	r24, Z
     454:	91 81       	ldd	r25, Z+1	; 0x01
     456:	00 97       	sbiw	r24, 0x00	; 0
     458:	29 f0       	breq	.+10     	; 0x464 <process_thread_etimer_process+0x26>
     45a:	8a 35       	cpi	r24, 0x5A	; 90
     45c:	91 05       	cpc	r25, r1
     45e:	09 f0       	breq	.+2      	; 0x462 <process_thread_etimer_process+0x24>
     460:	76 c0       	rjmp	.+236    	; 0x54e <process_thread_etimer_process+0x110>
     462:	0f c0       	rjmp	.+30     	; 0x482 <process_thread_etimer_process+0x44>

  timerlist = NULL;
     464:	10 92 15 06 	sts	0x0615, r1
     468:	10 92 14 06 	sts	0x0614, r1
  
  while(1) {
    PROCESS_YIELD();
     46c:	8a e5       	ldi	r24, 0x5A	; 90
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	f7 01       	movw	r30, r14
     472:	91 83       	std	Z+1, r25	; 0x01
     474:	80 83       	st	Z, r24
     476:	84 e4       	ldi	r24, 0x44	; 68
     478:	92 e0       	ldi	r25, 0x02	; 2
     47a:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	6a c0       	rjmp	.+212    	; 0x556 <process_thread_etimer_process+0x118>

    if(ev == PROCESS_EVENT_EXITED) {
     482:	67 38       	cpi	r22, 0x87	; 135
     484:	49 f5       	brne	.+82     	; 0x4d8 <process_thread_etimer_process+0x9a>
      struct process *p = data;
     486:	ca 01       	movw	r24, r20
     488:	e0 91 14 06 	lds	r30, 0x0614
     48c:	f0 91 15 06 	lds	r31, 0x0615

      while(timerlist != NULL && timerlist->p == p) {
     490:	03 c0       	rjmp	.+6      	; 0x498 <process_thread_etimer_process+0x5a>
	timerlist = timerlist->next;
     492:	04 80       	ldd	r0, Z+4	; 0x04
     494:	f5 81       	ldd	r31, Z+5	; 0x05
     496:	e0 2d       	mov	r30, r0
    PROCESS_YIELD();

    if(ev == PROCESS_EVENT_EXITED) {
      struct process *p = data;

      while(timerlist != NULL && timerlist->p == p) {
     498:	30 97       	sbiw	r30, 0x00	; 0
     49a:	21 f3       	breq	.-56     	; 0x464 <process_thread_etimer_process+0x26>
     49c:	26 81       	ldd	r18, Z+6	; 0x06
     49e:	37 81       	ldd	r19, Z+7	; 0x07
     4a0:	28 17       	cp	r18, r24
     4a2:	39 07       	cpc	r19, r25
     4a4:	b1 f3       	breq	.-20     	; 0x492 <process_thread_etimer_process+0x54>
     4a6:	e0 93 14 06 	sts	0x0614, r30
     4aa:	f0 93 15 06 	sts	0x0615, r31
     4ae:	0f c0       	rjmp	.+30     	; 0x4ce <process_thread_etimer_process+0x90>
      }

      if(timerlist != NULL) {
	t = timerlist;
	while(t->next != NULL) {
	  if(t->next->p == p) {
     4b0:	16 96       	adiw	r26, 0x06	; 6
     4b2:	2d 91       	ld	r18, X+
     4b4:	3c 91       	ld	r19, X
     4b6:	17 97       	sbiw	r26, 0x07	; 7
     4b8:	28 17       	cp	r18, r24
     4ba:	39 07       	cpc	r19, r25
     4bc:	39 f4       	brne	.+14     	; 0x4cc <process_thread_etimer_process+0x8e>
	    t->next = t->next->next;
     4be:	14 96       	adiw	r26, 0x04	; 4
     4c0:	2d 91       	ld	r18, X+
     4c2:	3c 91       	ld	r19, X
     4c4:	15 97       	sbiw	r26, 0x05	; 5
     4c6:	35 83       	std	Z+5, r19	; 0x05
     4c8:	24 83       	std	Z+4, r18	; 0x04
     4ca:	df 01       	movw	r26, r30
     4cc:	fd 01       	movw	r30, r26
	timerlist = timerlist->next;
      }

      if(timerlist != NULL) {
	t = timerlist;
	while(t->next != NULL) {
     4ce:	a4 81       	ldd	r26, Z+4	; 0x04
     4d0:	b5 81       	ldd	r27, Z+5	; 0x05
     4d2:	10 97       	sbiw	r26, 0x00	; 0
     4d4:	69 f7       	brne	.-38     	; 0x4b0 <process_thread_etimer_process+0x72>
     4d6:	ca cf       	rjmp	.-108    	; 0x46c <process_thread_etimer_process+0x2e>
	  } else
	    t = t->next;
	}
      }
      continue;
    } else if(ev != PROCESS_EVENT_POLL) {
     4d8:	62 38       	cpi	r22, 0x82	; 130
     4da:	41 f6       	brne	.-112    	; 0x46c <process_thread_etimer_process+0x2e>

  again:
    
    u = NULL;
    
    for(t = timerlist; t != NULL; t = t->next) {
     4dc:	c0 91 14 06 	lds	r28, 0x0614
     4e0:	d0 91 15 06 	lds	r29, 0x0615
      continue;
    }

  again:
    
    u = NULL;
     4e4:	00 e0       	ldi	r16, 0x00	; 0
     4e6:	10 e0       	ldi	r17, 0x00	; 0
    
    for(t = timerlist; t != NULL; t = t->next) {
     4e8:	2f c0       	rjmp	.+94     	; 0x548 <process_thread_etimer_process+0x10a>
      if(timer_expired(&t->timer)) {
     4ea:	ce 01       	movw	r24, r28
     4ec:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <timer_expired>
     4f0:	00 97       	sbiw	r24, 0x00	; 0
     4f2:	11 f1       	breq	.+68     	; 0x538 <process_thread_etimer_process+0xfa>
	if(process_post(t->p, PROCESS_EVENT_TIMER, t) == PROCESS_ERR_OK) {
     4f4:	8e 81       	ldd	r24, Y+6	; 0x06
     4f6:	9f 81       	ldd	r25, Y+7	; 0x07
     4f8:	68 e8       	ldi	r22, 0x88	; 136
     4fa:	ae 01       	movw	r20, r28
     4fc:	0e 94 b1 14 	call	0x2962	; 0x2962 <process_post>
     500:	00 97       	sbiw	r24, 0x00	; 0
     502:	c1 f4       	brne	.+48     	; 0x534 <process_thread_etimer_process+0xf6>
      printf("************etimer_request_post is done************\n");
     504:	83 e6       	ldi	r24, 0x63	; 99
     506:	92 e0       	ldi	r25, 0x02	; 2
     508:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
	  
	  /* Reset the process ID of the event timer, to signal that the
	     etimer has expired. This is later checked in the
	     etimer_expired() function. */
	  t->p = PROCESS_NONE;
     50c:	1f 82       	std	Y+7, r1	; 0x07
     50e:	1e 82       	std	Y+6, r1	; 0x06
     510:	8c 81       	ldd	r24, Y+4	; 0x04
     512:	9d 81       	ldd	r25, Y+5	; 0x05
	  if(u != NULL) {
     514:	01 15       	cp	r16, r1
     516:	11 05       	cpc	r17, r1
     518:	21 f0       	breq	.+8      	; 0x522 <process_thread_etimer_process+0xe4>
	    u->next = t->next;
     51a:	f8 01       	movw	r30, r16
     51c:	95 83       	std	Z+5, r25	; 0x05
     51e:	84 83       	std	Z+4, r24	; 0x04
     520:	04 c0       	rjmp	.+8      	; 0x52a <process_thread_etimer_process+0xec>
	  } else {
	    timerlist = t->next;
     522:	90 93 15 06 	sts	0x0615, r25
     526:	80 93 14 06 	sts	0x0614, r24
	  }
	  t->next = NULL;
     52a:	1d 82       	std	Y+5, r1	; 0x05
     52c:	1c 82       	std	Y+4, r1	; 0x04
	  update_time();
     52e:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <update_time>
	  goto again;
     532:	d4 cf       	rjmp	.-88     	; 0x4dc <process_thread_etimer_process+0x9e>
	} else {
	  etimer_request_poll();
     534:	0e 94 1a 02 	call	0x434	; 0x434 <etimer_request_poll>

  again:
    
    u = NULL;
    
    for(t = timerlist; t != NULL; t = t->next) {
     538:	8e 01       	movw	r16, r28
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	8d 81       	ldd	r24, Y+5	; 0x05
     53e:	c9 2e       	mov	r12, r25
     540:	e6 01       	movw	r28, r12
     542:	6e 01       	movw	r12, r28
     544:	d8 2e       	mov	r13, r24
     546:	e6 01       	movw	r28, r12
     548:	20 97       	sbiw	r28, 0x00	; 0
     54a:	79 f6       	brne	.-98     	; 0x4ea <process_thread_etimer_process+0xac>
     54c:	8f cf       	rjmp	.-226    	; 0x46c <process_thread_etimer_process+0x2e>
      u = t;
    }
    
  }
  
  PROCESS_END();
     54e:	f7 01       	movw	r30, r14
     550:	11 82       	std	Z+1, r1	; 0x01
     552:	10 82       	st	Z, r1
     554:	83 e0       	ldi	r24, 0x03	; 3
}
     556:	df 91       	pop	r29
     558:	cf 91       	pop	r28
     55a:	1f 91       	pop	r17
     55c:	0f 91       	pop	r16
     55e:	ff 90       	pop	r15
     560:	ef 90       	pop	r14
     562:	df 90       	pop	r13
     564:	cf 90       	pop	r12
     566:	08 95       	ret

00000568 <add_timer>:
  process_poll(&etimer_process);
}
/*---------------------------------------------------------------------------*/
static void
add_timer(struct etimer *timer)
{
     568:	cf 93       	push	r28
     56a:	df 93       	push	r29
     56c:	ec 01       	movw	r28, r24
  struct etimer *t;

  etimer_request_poll();
     56e:	0e 94 1a 02 	call	0x434	; 0x434 <etimer_request_poll>
  printf("/+++++++++++++++++++++++/\n");
     572:	87 e9       	ldi	r24, 0x97	; 151
     574:	92 e0       	ldi	r25, 0x02	; 2
     576:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>

  if(timer->p != PROCESS_NONE) {
     57a:	8e 81       	ldd	r24, Y+6	; 0x06
     57c:	9f 81       	ldd	r25, Y+7	; 0x07
     57e:	00 97       	sbiw	r24, 0x00	; 0
     580:	69 f0       	breq	.+26     	; 0x59c <add_timer+0x34>
    /* Timer not on list. */
    
    for(t = timerlist; t != NULL; t = t->next) {
     582:	e0 91 14 06 	lds	r30, 0x0614
     586:	f0 91 15 06 	lds	r31, 0x0615
     58a:	06 c0       	rjmp	.+12     	; 0x598 <add_timer+0x30>
      if(t == timer) {
     58c:	ec 17       	cp	r30, r28
     58e:	fd 07       	cpc	r31, r29
     590:	a9 f0       	breq	.+42     	; 0x5bc <add_timer+0x54>
  printf("/+++++++++++++++++++++++/\n");

  if(timer->p != PROCESS_NONE) {
    /* Timer not on list. */
    
    for(t = timerlist; t != NULL; t = t->next) {
     592:	04 80       	ldd	r0, Z+4	; 0x04
     594:	f5 81       	ldd	r31, Z+5	; 0x05
     596:	e0 2d       	mov	r30, r0
     598:	30 97       	sbiw	r30, 0x00	; 0
     59a:	c1 f7       	brne	.-16     	; 0x58c <add_timer+0x24>
	return;
      }
    }
  }

  timer->p = PROCESS_CURRENT();
     59c:	80 91 ad 06 	lds	r24, 0x06AD
     5a0:	90 91 ae 06 	lds	r25, 0x06AE
     5a4:	9f 83       	std	Y+7, r25	; 0x07
     5a6:	8e 83       	std	Y+6, r24	; 0x06
  timer->next = timerlist;
     5a8:	80 91 14 06 	lds	r24, 0x0614
     5ac:	90 91 15 06 	lds	r25, 0x0615
     5b0:	9d 83       	std	Y+5, r25	; 0x05
     5b2:	8c 83       	std	Y+4, r24	; 0x04
  timerlist = timer;
     5b4:	d0 93 15 06 	sts	0x0615, r29
     5b8:	c0 93 14 06 	sts	0x0614, r28

  update_time();
     5bc:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <update_time>
}
     5c0:	df 91       	pop	r29
     5c2:	cf 91       	pop	r28
     5c4:	08 95       	ret

000005c6 <etimer_set>:
/*---------------------------------------------------------------------------*/
void
etimer_set(struct etimer *et, clock_time_t interval)
{
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	ec 01       	movw	r28, r24
  timer_set(&et->timer, interval);
     5cc:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <timer_set>
  add_timer(et);
     5d0:	ce 01       	movw	r24, r28
     5d2:	0e 94 b4 02 	call	0x568	; 0x568 <add_timer>
}
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	08 95       	ret

000005dc <etimer_reset>:
/*---------------------------------------------------------------------------*/
void
etimer_reset(struct etimer *et)
{
     5dc:	cf 93       	push	r28
     5de:	df 93       	push	r29
     5e0:	ec 01       	movw	r28, r24
  timer_reset(&et->timer);
     5e2:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <timer_reset>
  add_timer(et);
     5e6:	ce 01       	movw	r24, r28
     5e8:	0e 94 b4 02 	call	0x568	; 0x568 <add_timer>
}
     5ec:	df 91       	pop	r29
     5ee:	cf 91       	pop	r28
     5f0:	08 95       	ret

000005f2 <etimer_restart>:
/*---------------------------------------------------------------------------*/
void
etimer_restart(struct etimer *et)
{
     5f2:	cf 93       	push	r28
     5f4:	df 93       	push	r29
     5f6:	ec 01       	movw	r28, r24
  timer_restart(&et->timer);
     5f8:	0e 94 31 17 	call	0x2e62	; 0x2e62 <timer_restart>
  add_timer(et);
     5fc:	ce 01       	movw	r24, r28
     5fe:	0e 94 b4 02 	call	0x568	; 0x568 <add_timer>
}
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	08 95       	ret

00000608 <etimer_adjust>:
/*---------------------------------------------------------------------------*/
void
etimer_adjust(struct etimer *et, int timediff)
{
     608:	fc 01       	movw	r30, r24
  et->timer.start += timediff;
     60a:	80 81       	ld	r24, Z
     60c:	91 81       	ldd	r25, Z+1	; 0x01
     60e:	86 0f       	add	r24, r22
     610:	97 1f       	adc	r25, r23
     612:	91 83       	std	Z+1, r25	; 0x01
     614:	80 83       	st	Z, r24
  update_time();
     616:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <update_time>
}
     61a:	08 95       	ret

0000061c <etimer_expired>:
/*---------------------------------------------------------------------------*/
int
etimer_expired(struct etimer *et)
{
  return et->p == PROCESS_NONE;
     61c:	21 e0       	ldi	r18, 0x01	; 1
     61e:	30 e0       	ldi	r19, 0x00	; 0
     620:	fc 01       	movw	r30, r24
     622:	86 81       	ldd	r24, Z+6	; 0x06
     624:	97 81       	ldd	r25, Z+7	; 0x07
     626:	00 97       	sbiw	r24, 0x00	; 0
     628:	11 f0       	breq	.+4      	; 0x62e <etimer_expired+0x12>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	30 e0       	ldi	r19, 0x00	; 0
}
     62e:	c9 01       	movw	r24, r18
     630:	08 95       	ret

00000632 <etimer_expiration_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_expiration_time(struct etimer *et)
{
     632:	fc 01       	movw	r30, r24
  return et->timer.start + et->timer.interval;
     634:	22 81       	ldd	r18, Z+2	; 0x02
     636:	33 81       	ldd	r19, Z+3	; 0x03
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	28 0f       	add	r18, r24
     63e:	39 1f       	adc	r19, r25
}
     640:	c9 01       	movw	r24, r18
     642:	08 95       	ret

00000644 <etimer_start_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_start_time(struct etimer *et)
{
     644:	fc 01       	movw	r30, r24
  return et->timer.start;
}
     646:	80 81       	ld	r24, Z
     648:	91 81       	ldd	r25, Z+1	; 0x01
     64a:	08 95       	ret

0000064c <etimer_pending>:
/*---------------------------------------------------------------------------*/
int
etimer_pending(void)
{
  return timerlist != NULL;
     64c:	21 e0       	ldi	r18, 0x01	; 1
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	80 91 14 06 	lds	r24, 0x0614
     654:	90 91 15 06 	lds	r25, 0x0615
     658:	00 97       	sbiw	r24, 0x00	; 0
     65a:	11 f4       	brne	.+4      	; 0x660 <etimer_pending+0x14>
     65c:	20 e0       	ldi	r18, 0x00	; 0
     65e:	30 e0       	ldi	r19, 0x00	; 0
}
     660:	c9 01       	movw	r24, r18
     662:	08 95       	ret

00000664 <etimer_next_expiration_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_next_expiration_time(void)
{
  return etimer_pending() ? next_expiration : 0;
     664:	80 91 14 06 	lds	r24, 0x0614
     668:	90 91 15 06 	lds	r25, 0x0615
     66c:	00 97       	sbiw	r24, 0x00	; 0
     66e:	29 f0       	breq	.+10     	; 0x67a <etimer_next_expiration_time+0x16>
     670:	20 91 16 06 	lds	r18, 0x0616
     674:	30 91 17 06 	lds	r19, 0x0617
     678:	02 c0       	rjmp	.+4      	; 0x67e <etimer_next_expiration_time+0x1a>
     67a:	20 e0       	ldi	r18, 0x00	; 0
     67c:	30 e0       	ldi	r19, 0x00	; 0
}
     67e:	c9 01       	movw	r24, r18
     680:	08 95       	ret

00000682 <etimer_stop>:
/*---------------------------------------------------------------------------*/
void
etimer_stop(struct etimer *et)
{
     682:	cf 93       	push	r28
     684:	df 93       	push	r29
     686:	ec 01       	movw	r28, r24
  struct etimer *t;

  /* First check if et is the first event timer on the list. */
  if(et == timerlist) {
     688:	e0 91 14 06 	lds	r30, 0x0614
     68c:	f0 91 15 06 	lds	r31, 0x0615
     690:	8e 17       	cp	r24, r30
     692:	9f 07       	cpc	r25, r31
     694:	41 f4       	brne	.+16     	; 0x6a6 <etimer_stop+0x24>
    timerlist = timerlist->next;
     696:	8c 81       	ldd	r24, Y+4	; 0x04
     698:	9d 81       	ldd	r25, Y+5	; 0x05
     69a:	90 93 15 06 	sts	0x0615, r25
     69e:	80 93 14 06 	sts	0x0614, r24
     6a2:	14 c0       	rjmp	.+40     	; 0x6cc <etimer_stop+0x4a>
    update_time();
  } else {
    /* Else walk through the list and try to find the item before the
       et timer. */
    for(t = timerlist; t != NULL && t->next != et; t = t->next);
     6a4:	fc 01       	movw	r30, r24
     6a6:	30 97       	sbiw	r30, 0x00	; 0
     6a8:	31 f0       	breq	.+12     	; 0x6b6 <etimer_stop+0x34>
     6aa:	84 81       	ldd	r24, Z+4	; 0x04
     6ac:	95 81       	ldd	r25, Z+5	; 0x05
     6ae:	8c 17       	cp	r24, r28
     6b0:	9d 07       	cpc	r25, r29
     6b2:	c1 f7       	brne	.-16     	; 0x6a4 <etimer_stop+0x22>
     6b4:	07 c0       	rjmp	.+14     	; 0x6c4 <etimer_stop+0x42>
      update_time();
    }
  }

  /* Remove the next pointer from the item to be removed. */
  et->next = NULL;
     6b6:	1d 82       	std	Y+5, r1	; 0x05
     6b8:	1c 82       	std	Y+4, r1	; 0x04
  /* Set the timer as expired */
  et->p = PROCESS_NONE;
     6ba:	1f 82       	std	Y+7, r1	; 0x07
     6bc:	1e 82       	std	Y+6, r1	; 0x06
}
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	08 95       	ret

    if(t != NULL) {
      /* We've found the item before the event timer that we are about
	 to remove. We point the items next pointer to the event after
	 the removed item. */
      t->next = et->next;
     6c4:	8c 81       	ldd	r24, Y+4	; 0x04
     6c6:	9d 81       	ldd	r25, Y+5	; 0x05
     6c8:	95 83       	std	Z+5, r25	; 0x05
     6ca:	84 83       	std	Z+4, r24	; 0x04

      update_time();
     6cc:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <update_time>
     6d0:	f2 cf       	rjmp	.-28     	; 0x6b6 <etimer_stop+0x34>

000006d2 <rtimer_init>:

/*---------------------------------------------------------------------------*/
void
rtimer_init(void)
{
  rtimer_arch_init();
     6d2:	0e 94 66 06 	call	0xccc	; 0xccc <rtimer_arch_init>
}
     6d6:	08 95       	ret

000006d8 <rtimer_set>:
/*---------------------------------------------------------------------------*/
int
rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
	   rtimer_clock_t duration,
	   rtimer_callback_t func, void *ptr)
{
     6d8:	cf 92       	push	r12
     6da:	df 92       	push	r13
     6dc:	ef 92       	push	r14
     6de:	ff 92       	push	r15
     6e0:	0f 93       	push	r16
     6e2:	1f 93       	push	r17
     6e4:	cf 93       	push	r28
     6e6:	df 93       	push	r29
     6e8:	ec 01       	movw	r28, r24
     6ea:	7b 01       	movw	r14, r22
     6ec:	69 01       	movw	r12, r18
  int first = 0;

  //PRINTF("rtimer_set time %d\n", time);
  printf("rtimer_set time %d\n", time);
     6ee:	00 d0       	rcall	.+0      	; 0x6f0 <rtimer_set+0x18>
     6f0:	00 d0       	rcall	.+0      	; 0x6f2 <rtimer_set+0x1a>
     6f2:	82 ec       	ldi	r24, 0xC2	; 194
     6f4:	92 e0       	ldi	r25, 0x02	; 2
     6f6:	ed b7       	in	r30, 0x3d	; 61
     6f8:	fe b7       	in	r31, 0x3e	; 62
     6fa:	92 83       	std	Z+2, r25	; 0x02
     6fc:	81 83       	std	Z+1, r24	; 0x01
     6fe:	74 83       	std	Z+4, r23	; 0x04
     700:	63 83       	std	Z+3, r22	; 0x03
     702:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>

  if(next_rtimer == NULL) {
     706:	80 91 18 06 	lds	r24, 0x0618
     70a:	90 91 19 06 	lds	r25, 0x0619
    first = 1;
  }

  rtimer->func = func;
     70e:	db 82       	std	Y+3, r13	; 0x03
     710:	ca 82       	std	Y+2, r12	; 0x02
  rtimer->ptr = ptr;
     712:	1d 83       	std	Y+5, r17	; 0x05
     714:	0c 83       	std	Y+4, r16	; 0x04

  rtimer->time = time;
     716:	f9 82       	std	Y+1, r15	; 0x01
     718:	e8 82       	st	Y, r14
  next_rtimer = rtimer;
     71a:	d0 93 19 06 	sts	0x0619, r29
     71e:	c0 93 18 06 	sts	0x0618, r28

  if(first == 1) {
     722:	0f 90       	pop	r0
     724:	0f 90       	pop	r0
     726:	0f 90       	pop	r0
     728:	0f 90       	pop	r0
     72a:	00 97       	sbiw	r24, 0x00	; 0
     72c:	19 f4       	brne	.+6      	; 0x734 <rtimer_set+0x5c>
    rtimer_arch_schedule(time);
     72e:	c7 01       	movw	r24, r14
     730:	0e 94 82 06 	call	0xd04	; 0xd04 <rtimer_arch_schedule>
  }
  return RTIMER_OK;
}
     734:	80 e0       	ldi	r24, 0x00	; 0
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	df 91       	pop	r29
     73a:	cf 91       	pop	r28
     73c:	1f 91       	pop	r17
     73e:	0f 91       	pop	r16
     740:	ff 90       	pop	r15
     742:	ef 90       	pop	r14
     744:	df 90       	pop	r13
     746:	cf 90       	pop	r12
     748:	08 95       	ret

0000074a <rtimer_run_next>:
/*---------------------------------------------------------------------------*/
void
rtimer_run_next(void)
{
  struct rtimer *t;
  if(next_rtimer == NULL) {
     74a:	80 91 18 06 	lds	r24, 0x0618
     74e:	90 91 19 06 	lds	r25, 0x0619
     752:	00 97       	sbiw	r24, 0x00	; 0
     754:	c1 f0       	breq	.+48     	; 0x786 <rtimer_run_next+0x3c>
    return;
  }
  t = next_rtimer;
  next_rtimer = NULL;
     756:	10 92 19 06 	sts	0x0619, r1
     75a:	10 92 18 06 	sts	0x0618, r1
  t->func(t, t->ptr);
     75e:	dc 01       	movw	r26, r24
     760:	14 96       	adiw	r26, 0x04	; 4
     762:	6d 91       	ld	r22, X+
     764:	7c 91       	ld	r23, X
     766:	15 97       	sbiw	r26, 0x05	; 5
     768:	12 96       	adiw	r26, 0x02	; 2
     76a:	ed 91       	ld	r30, X+
     76c:	fc 91       	ld	r31, X
     76e:	13 97       	sbiw	r26, 0x03	; 3
     770:	09 95       	icall
  if(next_rtimer != NULL) {
     772:	e0 91 18 06 	lds	r30, 0x0618
     776:	f0 91 19 06 	lds	r31, 0x0619
     77a:	30 97       	sbiw	r30, 0x00	; 0
     77c:	21 f0       	breq	.+8      	; 0x786 <rtimer_run_next+0x3c>
    rtimer_arch_schedule(next_rtimer->time);
     77e:	80 81       	ld	r24, Z
     780:	91 81       	ldd	r25, Z+1	; 0x01
     782:	0e 94 82 06 	call	0xd04	; 0xd04 <rtimer_arch_schedule>
     786:	08 95       	ret

00000788 <init_usart>:
/*---------------------------------------------------------------------------*/
void
init_usart(void)
{
  /* First rs232 port for debugging */
  rs232_init(RS232_PORT_0, USART_BAUD_115200,
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	63 e0       	ldi	r22, 0x03	; 3
     78c:	46 e0       	ldi	r20, 0x06	; 6
     78e:	0e 94 a3 1c 	call	0x3946	; 0x3946 <rs232_init>

#if WITH_UIP || WITH_UIP6
 // slip_arch_init(USART_BAUD_115200);
    rs232_redirect_stdout(RS232_PORT_0);
#else
  rs232_redirect_stdout(RS232_PORT_0);
     792:	80 e0       	ldi	r24, 0x00	; 0
     794:	0e 94 19 1d 	call	0x3a32	; 0x3a32 <rs232_redirect_stdout>
#endif /* WITH_UIP */

}
     798:	08 95       	ret

0000079a <main>:
/*---------------------------------------------------------------------------*/
int
main(void)
{

  leds_init();
     79a:	0e 94 81 07 	call	0xf02	; 0xf02 <leds_init>

  leds_on(LEDS_RED);
     79e:	84 e0       	ldi	r24, 0x04	; 4
     7a0:	0e 94 8b 07 	call	0xf16	; 0xf16 <leds_on>

  /* Initialize USART */
  init_usart();
     7a4:	0e 94 c4 03 	call	0x788	; 0x788 <init_usart>
  
  /* Clock */
  clock_init();
     7a8:	0e 94 c8 05 	call	0xb90	; 0xb90 <clock_init>

  leds_on(LEDS_GREEN);
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	0e 94 8b 07 	call	0xf16	; 0xf16 <leds_on>

  ds2401_init();
     7b2:	0e 94 d6 06 	call	0xdac	; 0xdac <ds2401_init>
  
  node_id_restore();
     7b6:	0e 94 1d 05 	call	0xa3a	; 0xa3a <node_id_restore>

  random_init(ds2401_id[0] + node_id);
     7ba:	20 91 10 0e 	lds	r18, 0x0E10
     7be:	80 91 1a 06 	lds	r24, 0x061A
     7c2:	90 91 1b 06 	lds	r25, 0x061B
     7c6:	82 0f       	add	r24, r18
     7c8:	91 1d       	adc	r25, r1
     7ca:	0e 94 86 19 	call	0x330c	; 0x330c <random_init>

  rtimer_init();
     7ce:	0e 94 69 03 	call	0x6d2	; 0x6d2 <rtimer_init>

  /* Process subsystem */
  process_init();
     7d2:	0e 94 29 14 	call	0x2852	; 0x2852 <process_init>

  process_start(&etimer_process, NULL);
     7d6:	81 eb       	ldi	r24, 0xB1	; 177
     7d8:	92 e0       	ldi	r25, 0x02	; 2
     7da:	60 e0       	ldi	r22, 0x00	; 0
     7dc:	70 e0       	ldi	r23, 0x00	; 0
     7de:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <process_start>

  ctimer_init();
     7e2:	0e 94 ae 18 	call	0x315c	; 0x315c <ctimer_init>

  leds_on(LEDS_YELLOW);
     7e6:	82 e0       	ldi	r24, 0x02	; 2
     7e8:	0e 94 8b 07 	call	0xf16	; 0xf16 <leds_on>

  init_net();
     7ec:	0e 94 16 04 	call	0x82c	; 0x82c <init_net>
  
  printf_P(PSTR(CONTIKI_VERSION_STRING " started. Node id %u\n"), node_id);
     7f0:	00 d0       	rcall	.+0      	; 0x7f2 <main+0x58>
     7f2:	00 d0       	rcall	.+0      	; 0x7f4 <main+0x5a>
     7f4:	8c e8       	ldi	r24, 0x8C	; 140
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	ed b7       	in	r30, 0x3d	; 61
     7fa:	fe b7       	in	r31, 0x3e	; 62
     7fc:	92 83       	std	Z+2, r25	; 0x02
     7fe:	81 83       	std	Z+1, r24	; 0x01
     800:	80 91 1a 06 	lds	r24, 0x061A
     804:	90 91 1b 06 	lds	r25, 0x061B
     808:	94 83       	std	Z+4, r25	; 0x04
     80a:	83 83       	std	Z+3, r24	; 0x03
     80c:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <printf_P>

  leds_off(LEDS_ALL);
     810:	0f 90       	pop	r0
     812:	0f 90       	pop	r0
     814:	0f 90       	pop	r0
     816:	0f 90       	pop	r0
     818:	87 e0       	ldi	r24, 0x07	; 7
     81a:	0e 94 93 07 	call	0xf26	; 0xf26 <leds_off>

  /* Autostart processes */
  autostart_start(autostart_processes);
     81e:	86 e3       	ldi	r24, 0x36	; 54
     820:	92 e0       	ldi	r25, 0x02	; 2
     822:	0e 94 b0 15 	call	0x2b60	; 0x2b60 <autostart_start>

  /* Main scheduler loop */
  do {

    process_run();
     826:	0e 94 3f 14 	call	0x287e	; 0x287e <process_run>
     82a:	fd cf       	rjmp	.-6      	; 0x826 <main+0x8c>

0000082c <init_net>:
}
#endif /* WITH_UIP */
/*---------------------------------------------------------------------------*/
void
init_net(void)
{
     82c:	cf 92       	push	r12
     82e:	df 92       	push	r13
     830:	ef 92       	push	r14
     832:	ff 92       	push	r15
     834:	0f 93       	push	r16
     836:	1f 93       	push	r17
     838:	df 93       	push	r29
     83a:	cf 93       	push	r28
     83c:	cd b7       	in	r28, 0x3d	; 61
     83e:	de b7       	in	r29, 0x3e	; 62
     840:	28 97       	sbiw	r28, 0x08	; 8
     842:	0f b6       	in	r0, 0x3f	; 63
     844:	f8 94       	cli
     846:	de bf       	out	0x3e, r29	; 62
     848:	0f be       	out	0x3f, r0	; 63
     84a:	cd bf       	out	0x3d, r28	; 61

  memset(&addr, 0, sizeof(rimeaddr_t));
#if UIP_CONF_IPV6
  memcpy(addr.u8, ds2401_id, sizeof(addr.u8));
#else
  if(node_id == 0) {
     84c:	80 91 1a 06 	lds	r24, 0x061A
     850:	90 91 1b 06 	lds	r25, 0x061B
     854:	00 97       	sbiw	r24, 0x00	; 0
     856:	39 f4       	brne	.+14     	; 0x866 <init_net+0x3a>
    for(i = 0; i < sizeof(rimeaddr_t); ++i) {
      addr.u8[i] = ds2401_id[7 - i];
     858:	80 91 17 0e 	lds	r24, 0x0E17
     85c:	89 83       	std	Y+1, r24	; 0x01
     85e:	80 91 16 0e 	lds	r24, 0x0E16
     862:	8a 83       	std	Y+2, r24	; 0x02
     864:	02 c0       	rjmp	.+4      	; 0x86a <init_net+0x3e>
    }
  } else {
    addr.u8[0] = node_id & 0xff;
     866:	89 83       	std	Y+1, r24	; 0x01
    addr.u8[1] = node_id >> 8;
     868:	9a 83       	std	Y+2, r25	; 0x02
  }
#endif
  rimeaddr_set_node_addr(&addr);
     86a:	8e 01       	movw	r16, r28
     86c:	0f 5f       	subi	r16, 0xFF	; 255
     86e:	1f 4f       	sbci	r17, 0xFF	; 255
     870:	c8 01       	movw	r24, r16
     872:	0e 94 d5 07 	call	0xfaa	; 0xfaa <rimeaddr_set_node_addr>
  printf_P(PSTR("Rime started with address "));
     876:	00 d0       	rcall	.+0      	; 0x878 <init_net+0x4c>
     878:	85 e1       	ldi	r24, 0x15	; 21
     87a:	91 e0       	ldi	r25, 0x01	; 1
     87c:	ad b7       	in	r26, 0x3d	; 61
     87e:	be b7       	in	r27, 0x3e	; 62
     880:	12 96       	adiw	r26, 0x02	; 2
     882:	9c 93       	st	X, r25
     884:	8e 93       	st	-X, r24
     886:	11 97       	sbiw	r26, 0x01	; 1
     888:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <printf_P>
  for(i = 0; i < sizeof(addr.u8) - 1; i++) {
    printf_P(PSTR("%d."), addr.u8[i]);
     88c:	00 d0       	rcall	.+0      	; 0x88e <init_net+0x62>
     88e:	ed b7       	in	r30, 0x3d	; 61
     890:	fe b7       	in	r31, 0x3e	; 62
     892:	31 96       	adiw	r30, 0x01	; 1
     894:	81 e1       	ldi	r24, 0x11	; 17
     896:	91 e0       	ldi	r25, 0x01	; 1
     898:	ad b7       	in	r26, 0x3d	; 61
     89a:	be b7       	in	r27, 0x3e	; 62
     89c:	12 96       	adiw	r26, 0x02	; 2
     89e:	9c 93       	st	X, r25
     8a0:	8e 93       	st	-X, r24
     8a2:	11 97       	sbiw	r26, 0x01	; 1
     8a4:	89 81       	ldd	r24, Y+1	; 0x01
     8a6:	82 83       	std	Z+2, r24	; 0x02
     8a8:	13 82       	std	Z+3, r1	; 0x03
     8aa:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <printf_P>
  }
  printf_P(PSTR("%d\n"), addr.u8[i]);
     8ae:	ed b7       	in	r30, 0x3d	; 61
     8b0:	fe b7       	in	r31, 0x3e	; 62
     8b2:	31 96       	adiw	r30, 0x01	; 1
     8b4:	8d e0       	ldi	r24, 0x0D	; 13
     8b6:	91 e0       	ldi	r25, 0x01	; 1
     8b8:	ad b7       	in	r26, 0x3d	; 61
     8ba:	be b7       	in	r27, 0x3e	; 62
     8bc:	12 96       	adiw	r26, 0x02	; 2
     8be:	9c 93       	st	X, r25
     8c0:	8e 93       	st	-X, r24
     8c2:	11 97       	sbiw	r26, 0x01	; 1
     8c4:	8a 81       	ldd	r24, Y+2	; 0x02
     8c6:	82 83       	std	Z+2, r24	; 0x02
     8c8:	13 82       	std	Z+3, r1	; 0x03
     8ca:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <printf_P>
void
init_net(void)
{

  set_rime_addr();
  cc2420_init();
     8ce:	0f 90       	pop	r0
     8d0:	0f 90       	pop	r0
     8d2:	0f 90       	pop	r0
     8d4:	0f 90       	pop	r0
     8d6:	0e 94 fd 20 	call	0x41fa	; 0x41fa <cc2420_init>
  {
    uint8_t longaddr[8];
    uint16_t shortaddr;
    
    shortaddr = (rimeaddr_node_addr.u8[0] << 8) +
     8da:	90 91 18 0e 	lds	r25, 0x0E18
     8de:	80 e0       	ldi	r24, 0x00	; 0
     8e0:	20 91 19 0e 	lds	r18, 0x0E19
     8e4:	7c 01       	movw	r14, r24
     8e6:	e2 0e       	add	r14, r18
     8e8:	f1 1c       	adc	r15, r1
                 rimeaddr_node_addr.u8[1];
    memset(longaddr, 0, sizeof(longaddr));
     8ea:	88 e0       	ldi	r24, 0x08	; 8
     8ec:	f8 01       	movw	r30, r16
     8ee:	11 92       	st	Z+, r1
     8f0:	8a 95       	dec	r24
     8f2:	e9 f7       	brne	.-6      	; 0x8ee <init_net+0xc2>
    rimeaddr_copy((rimeaddr_t *)&longaddr, &rimeaddr_node_addr);
     8f4:	c8 01       	movw	r24, r16
     8f6:	68 e1       	ldi	r22, 0x18	; 24
     8f8:	7e e0       	ldi	r23, 0x0E	; 14
     8fa:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    printf_P(PSTR("MAC %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n"),
     8fe:	8d b7       	in	r24, 0x3d	; 61
     900:	9e b7       	in	r25, 0x3e	; 62
     902:	42 97       	sbiw	r24, 0x12	; 18
     904:	0f b6       	in	r0, 0x3f	; 63
     906:	f8 94       	cli
     908:	9e bf       	out	0x3e, r25	; 62
     90a:	0f be       	out	0x3f, r0	; 63
     90c:	8d bf       	out	0x3d, r24	; 61
     90e:	ed b7       	in	r30, 0x3d	; 61
     910:	fe b7       	in	r31, 0x3e	; 62
     912:	31 96       	adiw	r30, 0x01	; 1
     914:	80 ee       	ldi	r24, 0xE0	; 224
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	ad b7       	in	r26, 0x3d	; 61
     91a:	be b7       	in	r27, 0x3e	; 62
     91c:	12 96       	adiw	r26, 0x02	; 2
     91e:	9c 93       	st	X, r25
     920:	8e 93       	st	-X, r24
     922:	11 97       	sbiw	r26, 0x01	; 1
     924:	89 81       	ldd	r24, Y+1	; 0x01
     926:	82 83       	std	Z+2, r24	; 0x02
     928:	13 82       	std	Z+3, r1	; 0x03
     92a:	8a 81       	ldd	r24, Y+2	; 0x02
     92c:	84 83       	std	Z+4, r24	; 0x04
     92e:	15 82       	std	Z+5, r1	; 0x05
     930:	8b 81       	ldd	r24, Y+3	; 0x03
     932:	86 83       	std	Z+6, r24	; 0x06
     934:	17 82       	std	Z+7, r1	; 0x07
     936:	8c 81       	ldd	r24, Y+4	; 0x04
     938:	80 87       	std	Z+8, r24	; 0x08
     93a:	11 86       	std	Z+9, r1	; 0x09
     93c:	8d 81       	ldd	r24, Y+5	; 0x05
     93e:	82 87       	std	Z+10, r24	; 0x0a
     940:	13 86       	std	Z+11, r1	; 0x0b
     942:	8e 81       	ldd	r24, Y+6	; 0x06
     944:	84 87       	std	Z+12, r24	; 0x0c
     946:	15 86       	std	Z+13, r1	; 0x0d
     948:	8f 81       	ldd	r24, Y+7	; 0x07
     94a:	86 87       	std	Z+14, r24	; 0x0e
     94c:	17 86       	std	Z+15, r1	; 0x0f
     94e:	88 85       	ldd	r24, Y+8	; 0x08
     950:	80 8b       	std	Z+16, r24	; 0x10
     952:	11 8a       	std	Z+17, r1	; 0x11
     954:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <printf_P>
             longaddr[0], longaddr[1], longaddr[2], longaddr[3],
             longaddr[4], longaddr[5], longaddr[6], longaddr[7]);
    
    cc2420_set_pan_addr(IEEE802154_PANID, shortaddr, longaddr);
     958:	ed b7       	in	r30, 0x3d	; 61
     95a:	fe b7       	in	r31, 0x3e	; 62
     95c:	72 96       	adiw	r30, 0x12	; 18
     95e:	0f b6       	in	r0, 0x3f	; 63
     960:	f8 94       	cli
     962:	fe bf       	out	0x3e, r31	; 62
     964:	0f be       	out	0x3f, r0	; 63
     966:	ed bf       	out	0x3d, r30	; 61
     968:	8d ec       	ldi	r24, 0xCD	; 205
     96a:	9b ea       	ldi	r25, 0xAB	; 171
     96c:	b7 01       	movw	r22, r14
     96e:	a8 01       	movw	r20, r16
     970:	0e 94 73 20 	call	0x40e6	; 0x40e6 <cc2420_set_pan_addr>
  }
  cc2420_set_channel(RF_CHANNEL);
     974:	8a e1       	ldi	r24, 0x1A	; 26
     976:	90 e0       	ldi	r25, 0x00	; 0
     978:	0e 94 23 20 	call	0x4046	; 0x4046 <cc2420_set_channel>
           ipaddr.u8[7 * 2], ipaddr.u8[7 * 2 + 1]);
  }

#else /* WITH_UIP6 */

  NETSTACK_RDC.init();
     97c:	e0 91 e1 03 	lds	r30, 0x03E1
     980:	f0 91 e2 03 	lds	r31, 0x03E2
     984:	09 95       	icall
  NETSTACK_MAC.init();
     986:	e0 91 01 04 	lds	r30, 0x0401
     98a:	f0 91 02 04 	lds	r31, 0x0402
     98e:	09 95       	icall
  NETSTACK_NETWORK.init();
     990:	e0 91 90 03 	lds	r30, 0x0390
     994:	f0 91 91 03 	lds	r31, 0x0391
     998:	09 95       	icall

  printf_P(PSTR("%s %s, channel check rate %d Hz, radio channel %d\n"),
     99a:	00 91 ff 03 	lds	r16, 0x03FF
     99e:	10 91 00 04 	lds	r17, 0x0400
     9a2:	c0 90 df 03 	lds	r12, 0x03DF
     9a6:	d0 90 e0 03 	lds	r13, 0x03E0
         NETSTACK_MAC.name, NETSTACK_RDC.name,
         CLOCK_SECOND / (NETSTACK_RDC.channel_check_interval() == 0? 1:
     9aa:	e0 90 ed 03 	lds	r14, 0x03ED
     9ae:	f0 90 ee 03 	lds	r15, 0x03EE
     9b2:	f7 01       	movw	r30, r14
     9b4:	09 95       	icall

  NETSTACK_RDC.init();
  NETSTACK_MAC.init();
  NETSTACK_NETWORK.init();

  printf_P(PSTR("%s %s, channel check rate %d Hz, radio channel %d\n"),
     9b6:	00 97       	sbiw	r24, 0x00	; 0
     9b8:	41 f0       	breq	.+16     	; 0x9ca <init_net+0x19e>
         NETSTACK_MAC.name, NETSTACK_RDC.name,
         CLOCK_SECOND / (NETSTACK_RDC.channel_check_interval() == 0? 1:
                         NETSTACK_RDC.channel_check_interval()),
     9ba:	f7 01       	movw	r30, r14
     9bc:	09 95       	icall
     9be:	bc 01       	movw	r22, r24

  NETSTACK_RDC.init();
  NETSTACK_MAC.init();
  NETSTACK_NETWORK.init();

  printf_P(PSTR("%s %s, channel check rate %d Hz, radio channel %d\n"),
     9c0:	80 e8       	ldi	r24, 0x80	; 128
     9c2:	90 e0       	ldi	r25, 0x00	; 0
     9c4:	0e 94 73 25 	call	0x4ae6	; 0x4ae6 <__udivmodhi4>
     9c8:	02 c0       	rjmp	.+4      	; 0x9ce <init_net+0x1a2>
     9ca:	60 e8       	ldi	r22, 0x80	; 128
     9cc:	70 e0       	ldi	r23, 0x00	; 0
     9ce:	8d b7       	in	r24, 0x3d	; 61
     9d0:	9e b7       	in	r25, 0x3e	; 62
     9d2:	0a 97       	sbiw	r24, 0x0a	; 10
     9d4:	0f b6       	in	r0, 0x3f	; 63
     9d6:	f8 94       	cli
     9d8:	9e bf       	out	0x3e, r25	; 62
     9da:	0f be       	out	0x3f, r0	; 63
     9dc:	8d bf       	out	0x3d, r24	; 61
     9de:	ed b7       	in	r30, 0x3d	; 61
     9e0:	fe b7       	in	r31, 0x3e	; 62
     9e2:	31 96       	adiw	r30, 0x01	; 1
     9e4:	8d ea       	ldi	r24, 0xAD	; 173
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	ad b7       	in	r26, 0x3d	; 61
     9ea:	be b7       	in	r27, 0x3e	; 62
     9ec:	12 96       	adiw	r26, 0x02	; 2
     9ee:	9c 93       	st	X, r25
     9f0:	8e 93       	st	-X, r24
     9f2:	11 97       	sbiw	r26, 0x01	; 1
     9f4:	13 83       	std	Z+3, r17	; 0x03
     9f6:	02 83       	std	Z+2, r16	; 0x02
     9f8:	d5 82       	std	Z+5, r13	; 0x05
     9fa:	c4 82       	std	Z+4, r12	; 0x04
     9fc:	77 83       	std	Z+7, r23	; 0x07
     9fe:	66 83       	std	Z+6, r22	; 0x06
     a00:	8a e1       	ldi	r24, 0x1A	; 26
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	91 87       	std	Z+9, r25	; 0x09
     a06:	80 87       	std	Z+8, r24	; 0x08
     a08:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <printf_P>
     a0c:	ed b7       	in	r30, 0x3d	; 61
     a0e:	fe b7       	in	r31, 0x3e	; 62
     a10:	3a 96       	adiw	r30, 0x0a	; 10
     a12:	0f b6       	in	r0, 0x3f	; 63
     a14:	f8 94       	cli
     a16:	fe bf       	out	0x3e, r31	; 62
     a18:	0f be       	out	0x3f, r0	; 63
     a1a:	ed bf       	out	0x3d, r30	; 61
	       uip_ipaddr_to_quad(&hostaddr));
#endif /* WITH_UIP */

  
  
}
     a1c:	28 96       	adiw	r28, 0x08	; 8
     a1e:	0f b6       	in	r0, 0x3f	; 63
     a20:	f8 94       	cli
     a22:	de bf       	out	0x3e, r29	; 62
     a24:	0f be       	out	0x3f, r0	; 63
     a26:	cd bf       	out	0x3d, r28	; 61
     a28:	cf 91       	pop	r28
     a2a:	df 91       	pop	r29
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	ff 90       	pop	r15
     a32:	ef 90       	pop	r14
     a34:	df 90       	pop	r13
     a36:	cf 90       	pop	r12
     a38:	08 95       	ret

00000a3a <node_id_restore>:
uint16_t node_id = 0;

/*---------------------------------------------------------------------------*/
void
node_id_restore(void)
{
     a3a:	df 93       	push	r29
     a3c:	cf 93       	push	r28
     a3e:	00 d0       	rcall	.+0      	; 0xa40 <node_id_restore+0x6>
     a40:	00 d0       	rcall	.+0      	; 0xa42 <node_id_restore+0x8>
     a42:	0f 92       	push	r0
     a44:	cd b7       	in	r28, 0x3d	; 61
     a46:	de b7       	in	r29, 0x3e	; 62
  uint16_t newid[2];
  uint8_t volatile sreg;

  sreg = SREG; /* Save status register before disabling interrupts. */
     a48:	8f b7       	in	r24, 0x3f	; 63
     a4a:	89 83       	std	Y+1, r24	; 0x01
  cli();    /* Disable interrupts. */
     a4c:	f8 94       	cli
  eeprom_read(EEPROM_NODE_ID_START, (unsigned char *)newid, sizeof(newid));
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	be 01       	movw	r22, r28
     a54:	6e 5f       	subi	r22, 0xFE	; 254
     a56:	7f 4f       	sbci	r23, 0xFF	; 255
     a58:	44 e0       	ldi	r20, 0x04	; 4
     a5a:	50 e0       	ldi	r21, 0x00	; 0
     a5c:	0e 94 71 07 	call	0xee2	; 0xee2 <eeprom_read>
  node_id = (newid[0] == 0xdead) ? newid[1] : 0;
     a60:	8a 81       	ldd	r24, Y+2	; 0x02
     a62:	9b 81       	ldd	r25, Y+3	; 0x03
     a64:	2e ed       	ldi	r18, 0xDE	; 222
     a66:	8d 3a       	cpi	r24, 0xAD	; 173
     a68:	92 07       	cpc	r25, r18
     a6a:	19 f4       	brne	.+6      	; 0xa72 <node_id_restore+0x38>
     a6c:	8c 81       	ldd	r24, Y+4	; 0x04
     a6e:	9d 81       	ldd	r25, Y+5	; 0x05
     a70:	02 c0       	rjmp	.+4      	; 0xa76 <node_id_restore+0x3c>
     a72:	80 e0       	ldi	r24, 0x00	; 0
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	90 93 1b 06 	sts	0x061B, r25
     a7a:	80 93 1a 06 	sts	0x061A, r24
  SREG = sreg;    /* Enable interrupts. */
     a7e:	89 81       	ldd	r24, Y+1	; 0x01
     a80:	8f bf       	out	0x3f, r24	; 63
}
     a82:	0f 90       	pop	r0
     a84:	0f 90       	pop	r0
     a86:	0f 90       	pop	r0
     a88:	0f 90       	pop	r0
     a8a:	0f 90       	pop	r0
     a8c:	cf 91       	pop	r28
     a8e:	df 91       	pop	r29
     a90:	08 95       	ret

00000a92 <node_id_burn>:
/*---------------------------------------------------------------------------*/
void
node_id_burn(uint16_t id)
{
     a92:	df 93       	push	r29
     a94:	cf 93       	push	r28
     a96:	00 d0       	rcall	.+0      	; 0xa98 <node_id_burn+0x6>
     a98:	00 d0       	rcall	.+0      	; 0xa9a <node_id_burn+0x8>
     a9a:	0f 92       	push	r0
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
  uint16_t buffer[2] = { 0xdead, id };
     aa0:	2d ea       	ldi	r18, 0xAD	; 173
     aa2:	3e ed       	ldi	r19, 0xDE	; 222
     aa4:	3b 83       	std	Y+3, r19	; 0x03
     aa6:	2a 83       	std	Y+2, r18	; 0x02
     aa8:	9d 83       	std	Y+5, r25	; 0x05
     aaa:	8c 83       	std	Y+4, r24	; 0x04
  uint8_t volatile sreg;

  sreg = SREG; /* Save status register before disabling interrupts. */
     aac:	8f b7       	in	r24, 0x3f	; 63
     aae:	89 83       	std	Y+1, r24	; 0x01
  cli();    /* Disable interrupts. */
     ab0:	f8 94       	cli
  eeprom_write(EEPROM_NODE_ID_START, (unsigned char *)buffer, sizeof(buffer));
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	be 01       	movw	r22, r28
     ab8:	6e 5f       	subi	r22, 0xFE	; 254
     aba:	7f 4f       	sbci	r23, 0xFF	; 255
     abc:	44 e0       	ldi	r20, 0x04	; 4
     abe:	50 e0       	ldi	r21, 0x00	; 0
     ac0:	0e 94 69 07 	call	0xed2	; 0xed2 <eeprom_write>
  SREG = sreg;    /* Enable interrupts. */
     ac4:	89 81       	ldd	r24, Y+1	; 0x01
     ac6:	8f bf       	out	0x3f, r24	; 63
}
     ac8:	0f 90       	pop	r0
     aca:	0f 90       	pop	r0
     acc:	0f 90       	pop	r0
     ace:	0f 90       	pop	r0
     ad0:	0f 90       	pop	r0
     ad2:	cf 91       	pop	r28
     ad4:	df 91       	pop	r29
     ad6:	08 95       	ret

00000ad8 <__vector_15>:
static volatile clock_time_t count, scount;
static volatile unsigned long seconds;

/*---------------------------------------------------------------------------*/
ISR(TIMER0_COMP_vect)
{
     ad8:	1f 92       	push	r1
     ada:	0f 92       	push	r0
     adc:	0f b6       	in	r0, 0x3f	; 63
     ade:	0f 92       	push	r0
     ae0:	0b b6       	in	r0, 0x3b	; 59
     ae2:	0f 92       	push	r0
     ae4:	11 24       	eor	r1, r1
     ae6:	2f 93       	push	r18
     ae8:	3f 93       	push	r19
     aea:	4f 93       	push	r20
     aec:	5f 93       	push	r21
     aee:	6f 93       	push	r22
     af0:	7f 93       	push	r23
     af2:	8f 93       	push	r24
     af4:	9f 93       	push	r25
     af6:	af 93       	push	r26
     af8:	bf 93       	push	r27
     afa:	ef 93       	push	r30
     afc:	ff 93       	push	r31
  count++;
     afe:	80 91 20 06 	lds	r24, 0x0620
     b02:	90 91 21 06 	lds	r25, 0x0621
     b06:	01 96       	adiw	r24, 0x01	; 1
     b08:	90 93 21 06 	sts	0x0621, r25
     b0c:	80 93 20 06 	sts	0x0620, r24
  if(++scount == CLOCK_SECOND) {
     b10:	80 91 22 06 	lds	r24, 0x0622
     b14:	90 91 23 06 	lds	r25, 0x0623
     b18:	01 96       	adiw	r24, 0x01	; 1
     b1a:	90 93 23 06 	sts	0x0623, r25
     b1e:	80 93 22 06 	sts	0x0622, r24
     b22:	80 91 22 06 	lds	r24, 0x0622
     b26:	90 91 23 06 	lds	r25, 0x0623
     b2a:	80 38       	cpi	r24, 0x80	; 128
     b2c:	91 05       	cpc	r25, r1
     b2e:	b9 f4       	brne	.+46     	; 0xb5e <__vector_15+0x86>
    scount = 0;
     b30:	10 92 23 06 	sts	0x0623, r1
     b34:	10 92 22 06 	sts	0x0622, r1
    seconds++;
     b38:	80 91 1c 06 	lds	r24, 0x061C
     b3c:	90 91 1d 06 	lds	r25, 0x061D
     b40:	a0 91 1e 06 	lds	r26, 0x061E
     b44:	b0 91 1f 06 	lds	r27, 0x061F
     b48:	01 96       	adiw	r24, 0x01	; 1
     b4a:	a1 1d       	adc	r26, r1
     b4c:	b1 1d       	adc	r27, r1
     b4e:	80 93 1c 06 	sts	0x061C, r24
     b52:	90 93 1d 06 	sts	0x061D, r25
     b56:	a0 93 1e 06 	sts	0x061E, r26
     b5a:	b0 93 1f 06 	sts	0x061F, r27
  }
  if(etimer_pending()) {
     b5e:	0e 94 26 03 	call	0x64c	; 0x64c <etimer_pending>
     b62:	00 97       	sbiw	r24, 0x00	; 0
     b64:	11 f0       	breq	.+4      	; 0xb6a <__vector_15+0x92>
    etimer_request_poll();
     b66:	0e 94 1a 02 	call	0x434	; 0x434 <etimer_request_poll>
  }
}
     b6a:	ff 91       	pop	r31
     b6c:	ef 91       	pop	r30
     b6e:	bf 91       	pop	r27
     b70:	af 91       	pop	r26
     b72:	9f 91       	pop	r25
     b74:	8f 91       	pop	r24
     b76:	7f 91       	pop	r23
     b78:	6f 91       	pop	r22
     b7a:	5f 91       	pop	r21
     b7c:	4f 91       	pop	r20
     b7e:	3f 91       	pop	r19
     b80:	2f 91       	pop	r18
     b82:	0f 90       	pop	r0
     b84:	0b be       	out	0x3b, r0	; 59
     b86:	0f 90       	pop	r0
     b88:	0f be       	out	0x3f, r0	; 63
     b8a:	0f 90       	pop	r0
     b8c:	1f 90       	pop	r1
     b8e:	18 95       	reti

00000b90 <clock_init>:
/*---------------------------------------------------------------------------*/
void 
clock_init(void)
{
  /* Disable interrupts*/
  cli();
     b90:	f8 94       	cli

  /* Disable compare match interrupts and overflow interrupts. */
  TIMSK &= ~( _BV(TOIE0) | _BV(OCIE0) );
     b92:	87 b7       	in	r24, 0x37	; 55
     b94:	8c 7f       	andi	r24, 0xFC	; 252
     b96:	87 bf       	out	0x37, r24	; 55
  /** 
   * set Timer/Counter0 to be asynchronous 
   * from the CPU clock with a second external 
   * clock(32,768kHz) driving it.
   */
  ASSR |= _BV(AS0);
     b98:	80 b7       	in	r24, 0x30	; 48
     b9a:	88 60       	ori	r24, 0x08	; 8
     b9c:	80 bf       	out	0x30, r24	; 48
  /*
   * Set timer control register:
   * - prescale: 32 (CS00 and CS01)
   * - counter reset via comparison register (WGM01)
   */
  TCCR0 = _BV(CS00) | _BV(CS01) | _BV(WGM01);
     b9e:	8b e0       	ldi	r24, 0x0B	; 11
     ba0:	83 bf       	out	0x33, r24	; 51

  /* Set counter to zero */
  TCNT0 = 0;
     ba2:	12 be       	out	0x32, r1	; 50

  /*
   * 128 clock ticks per second.
   * 32,768 = 32 * 8 * 128
   */
  OCR0 = 8;
     ba4:	88 e0       	ldi	r24, 0x08	; 8
     ba6:	81 bf       	out	0x31, r24	; 49

  /* Clear interrupt flag register */
  TIFR = 0x00;
     ba8:	16 be       	out	0x36, r1	; 54

  /**
   * Wait for TCN0UB, OCR0UB, and TCR0UB.
   *
   */
  while(ASSR & 0x07);
     baa:	80 b7       	in	r24, 0x30	; 48
     bac:	90 e0       	ldi	r25, 0x00	; 0
     bae:	87 70       	andi	r24, 0x07	; 7
     bb0:	90 70       	andi	r25, 0x00	; 0
     bb2:	00 97       	sbiw	r24, 0x00	; 0
     bb4:	d1 f7       	brne	.-12     	; 0xbaa <clock_init+0x1a>

  /* Raise interrupt when value in OCR0 is reached. */
  TIMSK |= _BV(OCIE0);
     bb6:	87 b7       	in	r24, 0x37	; 55
     bb8:	82 60       	ori	r24, 0x02	; 2
     bba:	87 bf       	out	0x37, r24	; 55

  count = 0;
     bbc:	10 92 21 06 	sts	0x0621, r1
     bc0:	10 92 20 06 	sts	0x0620, r1

  /* enable all interrupts*/
  sei();
     bc4:	78 94       	sei

}
     bc6:	08 95       	ret

00000bc8 <clock_time>:
clock_time_t
clock_time(void)
{
  clock_time_t tmp;
  do {
    tmp = count;
     bc8:	20 91 20 06 	lds	r18, 0x0620
     bcc:	30 91 21 06 	lds	r19, 0x0621
  } while(tmp != count);
     bd0:	80 91 20 06 	lds	r24, 0x0620
     bd4:	90 91 21 06 	lds	r25, 0x0621
     bd8:	28 17       	cp	r18, r24
     bda:	39 07       	cpc	r19, r25
     bdc:	a9 f7       	brne	.-22     	; 0xbc8 <clock_time>
  return tmp;
}
     bde:	c9 01       	movw	r24, r18
     be0:	08 95       	ret

00000be2 <clock_delay>:
 * Delay the CPU for a multiple of TODO
 */
void
clock_delay(unsigned int i)
{
  for (; i > 0; i--) {		/* Needs fixing XXX */
     be2:	07 c0       	rjmp	.+14     	; 0xbf2 <clock_delay+0x10>
     be4:	22 e3       	ldi	r18, 0x32	; 50
     be6:	30 e0       	ldi	r19, 0x00	; 0
    unsigned j;
    for (j = 50; j > 0; j--)
      asm volatile("nop");
     be8:	00 00       	nop
     bea:	21 50       	subi	r18, 0x01	; 1
     bec:	30 40       	sbci	r19, 0x00	; 0
void
clock_delay(unsigned int i)
{
  for (; i > 0; i--) {		/* Needs fixing XXX */
    unsigned j;
    for (j = 50; j > 0; j--)
     bee:	e1 f7       	brne	.-8      	; 0xbe8 <clock_delay+0x6>
 * Delay the CPU for a multiple of TODO
 */
void
clock_delay(unsigned int i)
{
  for (; i > 0; i--) {		/* Needs fixing XXX */
     bf0:	01 97       	sbiw	r24, 0x01	; 1
     bf2:	00 97       	sbiw	r24, 0x00	; 0
     bf4:	b9 f7       	brne	.-18     	; 0xbe4 <clock_delay+0x2>
    unsigned j;
    for (j = 50; j > 0; j--)
      asm volatile("nop");
  }
}
     bf6:	08 95       	ret

00000bf8 <clock_wait>:
 * Wait for a multiple of 1 / 128 sec = 7.8125 ms.
 *
 */
void
clock_wait(clock_time_t i)
{
     bf8:	0f 93       	push	r16
     bfa:	1f 93       	push	r17
     bfc:	cf 93       	push	r28
     bfe:	df 93       	push	r29
     c00:	8c 01       	movw	r16, r24
  clock_time_t start;

  start = clock_time();
     c02:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <clock_time>
     c06:	ec 01       	movw	r28, r24
  while(clock_time() - start < i);
     c08:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <clock_time>
     c0c:	8c 1b       	sub	r24, r28
     c0e:	9d 0b       	sbc	r25, r29
     c10:	80 17       	cp	r24, r16
     c12:	91 07       	cpc	r25, r17
     c14:	c8 f3       	brcs	.-14     	; 0xc08 <clock_wait+0x10>
}
     c16:	df 91       	pop	r29
     c18:	cf 91       	pop	r28
     c1a:	1f 91       	pop	r17
     c1c:	0f 91       	pop	r16
     c1e:	08 95       	ret

00000c20 <clock_set_seconds>:
/*---------------------------------------------------------------------------*/
void
clock_set_seconds(unsigned long sec)
{
    // TODO
}
     c20:	08 95       	ret

00000c22 <clock_seconds>:
unsigned long
clock_seconds(void)
{
  unsigned long tmp;
  do {
    tmp = seconds;
     c22:	20 91 1c 06 	lds	r18, 0x061C
     c26:	30 91 1d 06 	lds	r19, 0x061D
     c2a:	40 91 1e 06 	lds	r20, 0x061E
     c2e:	50 91 1f 06 	lds	r21, 0x061F
  } while(tmp != seconds);
     c32:	80 91 1c 06 	lds	r24, 0x061C
     c36:	90 91 1d 06 	lds	r25, 0x061D
     c3a:	a0 91 1e 06 	lds	r26, 0x061E
     c3e:	b0 91 1f 06 	lds	r27, 0x061F
     c42:	28 17       	cp	r18, r24
     c44:	39 07       	cpc	r19, r25
     c46:	4a 07       	cpc	r20, r26
     c48:	5b 07       	cpc	r21, r27
     c4a:	59 f7       	brne	.-42     	; 0xc22 <clock_seconds>
  return tmp;
}
     c4c:	b9 01       	movw	r22, r18
     c4e:	ca 01       	movw	r24, r20
     c50:	08 95       	ret

00000c52 <__vector_26>:
#define DEBUGFLOW(c)
#endif

/*---------------------------------------------------------------------------*/
#if defined(TCNT3) && RTIMER_ARCH_PRESCALER
ISR (TIMER3_COMPA_vect) {
     c52:	1f 92       	push	r1
     c54:	0f 92       	push	r0
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	0f 92       	push	r0
     c5a:	0b b6       	in	r0, 0x3b	; 59
     c5c:	0f 92       	push	r0
     c5e:	11 24       	eor	r1, r1
     c60:	2f 93       	push	r18
     c62:	3f 93       	push	r19
     c64:	4f 93       	push	r20
     c66:	5f 93       	push	r21
     c68:	6f 93       	push	r22
     c6a:	7f 93       	push	r23
     c6c:	8f 93       	push	r24
     c6e:	9f 93       	push	r25
     c70:	af 93       	push	r26
     c72:	bf 93       	push	r27
     c74:	ef 93       	push	r30
     c76:	ff 93       	push	r31
  printf("\n\n---------------call ISR3---------------\n\n");
     c78:	86 ed       	ldi	r24, 0xD6	; 214
     c7a:	92 e0       	ldi	r25, 0x02	; 2
     c7c:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
  //SAVE_CONTEXT();
  DEBUGFLOW('/');
  ENERGEST_ON(ENERGEST_TYPE_IRQ);

  /* Disable rtimer interrupts */
  ETIMSK &= ~((1 << OCIE3A) | (1 << OCIE3B) | (1 << TOIE3) |
     c80:	ed e7       	ldi	r30, 0x7D	; 125
     c82:	f0 e0       	ldi	r31, 0x00	; 0
     c84:	80 81       	ld	r24, Z
     c86:	81 7c       	andi	r24, 0xC1	; 193
     c88:	80 83       	st	Z, r24
  /* All interrupts are enabled including recursive rtimer, so use with caution */
  sei();
#endif

  /* Call rtimer callback */
  printf("start rtimer next\n");
     c8a:	81 e0       	ldi	r24, 0x01	; 1
     c8c:	93 e0       	ldi	r25, 0x03	; 3
     c8e:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
  rtimer_run_next();
     c92:	0e 94 a5 03 	call	0x74a	; 0x74a <rtimer_run_next>
  printf("finish rtimer next\n");
     c96:	83 e1       	ldi	r24, 0x13	; 19
     c98:	93 e0       	ldi	r25, 0x03	; 3
     c9a:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>

  ENERGEST_OFF(ENERGEST_TYPE_IRQ);
  DEBUGFLOW('\\');
  //RESTORE_CONTEXT();
  printf("\n\n---------------end ISR3---------------\n\n");
     c9e:	86 e2       	ldi	r24, 0x26	; 38
     ca0:	93 e0       	ldi	r25, 0x03	; 3
     ca2:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
}
     ca6:	ff 91       	pop	r31
     ca8:	ef 91       	pop	r30
     caa:	bf 91       	pop	r27
     cac:	af 91       	pop	r26
     cae:	9f 91       	pop	r25
     cb0:	8f 91       	pop	r24
     cb2:	7f 91       	pop	r23
     cb4:	6f 91       	pop	r22
     cb6:	5f 91       	pop	r21
     cb8:	4f 91       	pop	r20
     cba:	3f 91       	pop	r19
     cbc:	2f 91       	pop	r18
     cbe:	0f 90       	pop	r0
     cc0:	0b be       	out	0x3b, r0	; 59
     cc2:	0f 90       	pop	r0
     cc4:	0f be       	out	0x3f, r0	; 63
     cc6:	0f 90       	pop	r0
     cc8:	1f 90       	pop	r1
     cca:	18 95       	reti

00000ccc <rtimer_arch_init>:
rtimer_arch_init(void)
{
#if RTIMER_ARCH_PRESCALER
  /* Disable interrupts (store old state) */
  uint8_t sreg;
  sreg = SREG;
     ccc:	9f b7       	in	r25, 0x3f	; 63
  cli ();
     cce:	f8 94       	cli

#ifdef TCNT3
  /* Disable all timer functions */
  ETIMSK &= ~((1 << OCIE3A) | (1 << OCIE3B) | (1 << TOIE3) |
     cd0:	ed e7       	ldi	r30, 0x7D	; 125
     cd2:	f0 e0       	ldi	r31, 0x00	; 0
     cd4:	80 81       	ld	r24, Z
     cd6:	81 7c       	andi	r24, 0xC1	; 193
     cd8:	80 83       	st	Z, r24
      (1 << TICIE3) | (1 << OCIE3C));
  /* Write 1s to clear existing timer function flags */
  ETIFR |= (1 << ICF3) | (1 << OCF3A) | (1 << OCF3B) | (1 << TOV3) |
     cda:	ec e7       	ldi	r30, 0x7C	; 124
     cdc:	f0 e0       	ldi	r31, 0x00	; 0
     cde:	80 81       	ld	r24, Z
     ce0:	8e 63       	ori	r24, 0x3E	; 62
     ce2:	80 83       	st	Z, r24
  (1 << OCF3C); 

  /* Default timer behaviour */
  TCCR3A = 0;
     ce4:	10 92 8b 00 	sts	0x008B, r1
  TCCR3B = 0;
     ce8:	ea e8       	ldi	r30, 0x8A	; 138
     cea:	f0 e0       	ldi	r31, 0x00	; 0
     cec:	10 82       	st	Z, r1
  TCCR3C = 0;
     cee:	10 92 8c 00 	sts	0x008C, r1

  /* Reset counter */
  TCNT3 = 0;
     cf2:	10 92 89 00 	sts	0x0089, r1
     cf6:	10 92 88 00 	sts	0x0088, r1

#if RTIMER_ARCH_PRESCALER==1024
  TCCR3B |= 5;
     cfa:	80 81       	ld	r24, Z
     cfc:	85 60       	ori	r24, 0x05	; 5
     cfe:	80 83       	st	Z, r24
#endif

#endif /* TCNT3 */

  /* Restore interrupt state */
  SREG = sreg;
     d00:	9f bf       	out	0x3f, r25	; 63
#endif /* RTIMER_ARCH_PRESCALER */
}
     d02:	08 95       	ret

00000d04 <rtimer_arch_schedule>:
/*---------------------------------------------------------------------------*/
void
rtimer_arch_schedule(rtimer_clock_t t)
{
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
     d08:	ec 01       	movw	r28, r24
    printf("start rtimer_arch_schedule\n");
     d0a:	80 e5       	ldi	r24, 0x50	; 80
     d0c:	93 e0       	ldi	r25, 0x03	; 3
     d0e:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
#if RTIMER_ARCH_PRESCALER
  /* Disable interrupts (store old state) */
  uint8_t sreg;
  sreg = SREG;
     d12:	9f b7       	in	r25, 0x3f	; 63
  cli ();
     d14:	f8 94       	cli
  DEBUGFLOW(':');
#ifdef TCNT3
  /* Set compare register */
  OCR3A = t;
     d16:	d0 93 87 00 	sts	0x0087, r29
     d1a:	c0 93 86 00 	sts	0x0086, r28
  /* Write 1s to clear all timer function flags */
  ETIFR |= (1 << ICF3) | (1 << OCF3A) | (1 << OCF3B) | (1 << TOV3) |
     d1e:	ec e7       	ldi	r30, 0x7C	; 124
     d20:	f0 e0       	ldi	r31, 0x00	; 0
     d22:	80 81       	ld	r24, Z
     d24:	8e 63       	ori	r24, 0x3E	; 62
     d26:	80 83       	st	Z, r24
  (1 << OCF3C);
  /* Enable interrupt on OCR3A match */
  ETIMSK |= (1 << OCIE3A);
     d28:	ed e7       	ldi	r30, 0x7D	; 125
     d2a:	f0 e0       	ldi	r31, 0x00	; 0
     d2c:	80 81       	ld	r24, Z
     d2e:	80 61       	ori	r24, 0x10	; 16
     d30:	80 83       	st	Z, r24
  TIMSK |= (1 << OCIE1A);

#endif

  /* Restore interrupt state */
  SREG = sreg;
     d32:	9f bf       	out	0x3f, r25	; 63
#endif /* RTIMER_ARCH_PRESCALER */
    printf("finish rtimer_arch_schedule\n");
     d34:	8b e6       	ldi	r24, 0x6B	; 107
     d36:	93 e0       	ldi	r25, 0x03	; 3
     d38:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
}
     d3c:	df 91       	pop	r29
     d3e:	cf 91       	pop	r28
     d40:	08 95       	ret

00000d42 <read_byte>:
/*---------------------------------------------------------------------------*/
static unsigned
read_byte(void)
{
  unsigned result = 0;
  int i = 7;
     d42:	87 e0       	ldi	r24, 0x07	; 7
     d44:	90 e0       	ldi	r25, 0x00	; 0
}
/*---------------------------------------------------------------------------*/
static unsigned
read_byte(void)
{
  unsigned result = 0;
     d46:	20 e0       	ldi	r18, 0x00	; 0
     d48:	30 e0       	ldi	r19, 0x00	; 0
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     d4a:	aa e0       	ldi	r26, 0x0A	; 10
     d4c:	b0 e0       	ldi	r27, 0x00	; 0
     d4e:	60 e1       	ldi	r22, 0x10	; 16
     d50:	70 e0       	ldi	r23, 0x00	; 0
     d52:	45 e6       	ldi	r20, 0x65	; 101
     d54:	50 e0       	ldi	r21, 0x00	; 0
read_byte(void)
{
  unsigned result = 0;
  int i = 7;
  do {
    OW_DRIVE();
     d56:	d4 9a       	sbi	0x1a, 4	; 26
     d58:	dc 98       	cbi	0x1b, 4	; 27
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     d5a:	fd 01       	movw	r30, r26
     d5c:	31 97       	sbiw	r30, 0x01	; 1
     d5e:	f1 f7       	brne	.-4      	; 0xd5c <read_byte+0x1a>
  unsigned result = 0;
  int i = 7;
  do {
    OW_DRIVE();
    udelay(tA);
    OW_RELEASE();	/* Releases the bus */
     d60:	d4 98       	cbi	0x1a, 4	; 26
     d62:	dc 9a       	sbi	0x1b, 4	; 27
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     d64:	fb 01       	movw	r30, r22
     d66:	31 97       	sbiw	r30, 0x01	; 1
     d68:	f1 f7       	brne	.-4      	; 0xd66 <read_byte+0x24>
  do {
    OW_DRIVE();
    udelay(tA);
    OW_RELEASE();	/* Releases the bus */
    udelay(tE);
    if (INP())
     d6a:	cc 99       	sbic	0x19, 4	; 25
      result |= 0x80;	/* LSbit first */
     d6c:	20 68       	ori	r18, 0x80	; 128
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     d6e:	fa 01       	movw	r30, r20
     d70:	31 97       	sbiw	r30, 0x01	; 1
     d72:	f1 f7       	brne	.-4      	; 0xd70 <read_byte+0x2e>
    OW_RELEASE();	/* Releases the bus */
    udelay(tE);
    if (INP())
      result |= 0x80;	/* LSbit first */
    udelay(tF);
    if (i == 0)
     d74:	00 97       	sbiw	r24, 0x00	; 0
     d76:	11 f4       	brne	.+4      	; 0xd7c <read_byte+0x3a>
      return result;
    i--;
    result >>= 1;
  } while (1);
}
     d78:	c9 01       	movw	r24, r18
     d7a:	08 95       	ret
    if (INP())
      result |= 0x80;	/* LSbit first */
    udelay(tF);
    if (i == 0)
      return result;
    i--;
     d7c:	01 97       	sbiw	r24, 0x01	; 1
    result >>= 1;
     d7e:	36 95       	lsr	r19
     d80:	27 95       	ror	r18
  } while (1);
     d82:	e9 cf       	rjmp	.-46     	; 0xd56 <read_byte+0x14>

00000d84 <crc8_add>:
/* Polynomial ^8 + ^5 + ^4 + 1 */
static unsigned
crc8_add(unsigned acc, unsigned byte)
{
  int i;
  acc ^= byte;
     d84:	68 27       	eor	r22, r24
     d86:	79 27       	eor	r23, r25
     d88:	88 e0       	ldi	r24, 0x08	; 8
     d8a:	90 e0       	ldi	r25, 0x00	; 0
  for (i = 0; i < 8; i++)
    if (acc & 1)
      acc = (acc >> 1) ^ 0x8c;
     d8c:	4c e8       	ldi	r20, 0x8C	; 140
     d8e:	50 e0       	ldi	r21, 0x00	; 0
     d90:	9b 01       	movw	r18, r22
     d92:	36 95       	lsr	r19
     d94:	27 95       	ror	r18
crc8_add(unsigned acc, unsigned byte)
{
  int i;
  acc ^= byte;
  for (i = 0; i < 8; i++)
    if (acc & 1)
     d96:	60 ff       	sbrs	r22, 0
     d98:	04 c0       	rjmp	.+8      	; 0xda2 <crc8_add+0x1e>
      acc = (acc >> 1) ^ 0x8c;
     d9a:	b9 01       	movw	r22, r18
     d9c:	64 27       	eor	r22, r20
     d9e:	75 27       	eor	r23, r21
     da0:	01 c0       	rjmp	.+2      	; 0xda4 <crc8_add+0x20>
    else
      acc >>= 1;
     da2:	b9 01       	movw	r22, r18
     da4:	01 97       	sbiw	r24, 0x01	; 1
static unsigned
crc8_add(unsigned acc, unsigned byte)
{
  int i;
  acc ^= byte;
  for (i = 0; i < 8; i++)
     da6:	a1 f7       	brne	.-24     	; 0xd90 <crc8_add+0xc>
      acc = (acc >> 1) ^ 0x8c;
    else
      acc >>= 1;

  return acc;
}
     da8:	cb 01       	movw	r24, r22
     daa:	08 95       	ret

00000dac <ds2401_init>:
/*---------------------------------------------------------------------------*/
int
ds2401_init()
{
     dac:	cf 92       	push	r12
     dae:	df 92       	push	r13
     db0:	ef 92       	push	r14
     db2:	ff 92       	push	r15
     db4:	0f 93       	push	r16
     db6:	1f 93       	push	r17
     db8:	df 93       	push	r29
     dba:	cf 93       	push	r28
     dbc:	0f 92       	push	r0
     dbe:	cd b7       	in	r28, 0x3d	; 61
     dc0:	de b7       	in	r29, 0x3e	; 62
  int i;
  uint8_t volatile sreg;
  unsigned family, crc, acc;

  PIN_INIT();
     dc2:	d4 98       	cbi	0x1a, 4	; 26
     dc4:	dc 98       	cbi	0x1b, 4	; 27

  sreg = SREG;    /* Save status register before disabling interrupts. */
     dc6:	8f b7       	in	r24, 0x3f	; 63
     dc8:	89 83       	std	Y+1, r24	; 0x01
  cli();    /* Disable interrupts. */
     dca:	f8 94       	cli
/*---------------------------------------------------------------------------*/
static uint8_t
reset(void)
{
  uint8_t result;
  OW_DRIVE();
     dcc:	d4 9a       	sbi	0x1a, 4	; 26
     dce:	dc 98       	cbi	0x1b, 4	; 27
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     dd0:	89 e9       	ldi	r24, 0x99	; 153
     dd2:	93 e0       	ldi	r25, 0x03	; 3
     dd4:	01 97       	sbiw	r24, 0x01	; 1
     dd6:	f1 f7       	brne	.-4      	; 0xdd4 <ds2401_init+0x28>
reset(void)
{
  uint8_t result;
  OW_DRIVE();
  udelay(500);     /* 480 < tH < 640 */
  OW_RELEASE();    /* Releases the bus */
     dd8:	d4 98       	cbi	0x1a, 4	; 26
     dda:	dc 9a       	sbi	0x1b, 4	; 27
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     ddc:	80 e8       	ldi	r24, 0x80	; 128
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	01 97       	sbiw	r24, 0x01	; 1
     de2:	f1 f7       	brne	.-4      	; 0xde0 <ds2401_init+0x34>
  uint8_t result;
  OW_DRIVE();
  udelay(500);     /* 480 < tH < 640 */
  OW_RELEASE();    /* Releases the bus */
  udelay(tI);
  result = INP();
     de4:	29 b3       	in	r18, 0x19	; 25
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     de6:	83 ef       	ldi	r24, 0xF3	; 243
     de8:	92 e0       	ldi	r25, 0x02	; 2
     dea:	01 97       	sbiw	r24, 0x01	; 1
     dec:	f1 f7       	brne	.-4      	; 0xdea <ds2401_init+0x3e>
  PIN_INIT();

  sreg = SREG;    /* Save status register before disabling interrupts. */
  cli();    /* Disable interrupts. */

  if (reset() == 0) {
     dee:	24 fd       	sbrc	r18, 4
     df0:	5a c0       	rjmp	.+180    	; 0xea6 <ds2401_init+0xfa>
     df2:	b8 e0       	ldi	r27, 0x08	; 8
     df4:	a3 e3       	ldi	r26, 0x33	; 51
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     df6:	ee e6       	ldi	r30, 0x6E	; 110
     df8:	f0 e0       	ldi	r31, 0x00	; 0
     dfa:	62 e1       	ldi	r22, 0x12	; 18
     dfc:	70 e0       	ldi	r23, 0x00	; 0
     dfe:	4a e0       	ldi	r20, 0x0A	; 10
     e00:	50 e0       	ldi	r21, 0x00	; 0
     e02:	25 e7       	ldi	r18, 0x75	; 117
     e04:	30 e0       	ldi	r19, 0x00	; 0
static void
write_byte(uint8_t byte)
{
  uint8_t i = 7;
  do {
    if (byte & 0x01) {
     e06:	a0 ff       	sbrs	r26, 0
     e08:	09 c0       	rjmp	.+18     	; 0xe1c <ds2401_init+0x70>
      OW_DRIVE();
     e0a:	d4 9a       	sbi	0x1a, 4	; 26
     e0c:	dc 98       	cbi	0x1b, 4	; 27
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     e0e:	ca 01       	movw	r24, r20
     e10:	01 97       	sbiw	r24, 0x01	; 1
     e12:	f1 f7       	brne	.-4      	; 0xe10 <ds2401_init+0x64>
  uint8_t i = 7;
  do {
    if (byte & 0x01) {
      OW_DRIVE();
      udelay(tA);
      OW_RELEASE();    /* Releases the bus */
     e14:	d4 98       	cbi	0x1a, 4	; 26
     e16:	dc 9a       	sbi	0x1b, 4	; 27
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     e18:	c9 01       	movw	r24, r18
     e1a:	08 c0       	rjmp	.+16     	; 0xe2c <ds2401_init+0x80>
      OW_DRIVE();
      udelay(tA);
      OW_RELEASE();    /* Releases the bus */
      udelay(tB);
    } else {
      OW_DRIVE();
     e1c:	d4 9a       	sbi	0x1a, 4	; 26
     e1e:	dc 98       	cbi	0x1b, 4	; 27
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     e20:	cf 01       	movw	r24, r30
     e22:	01 97       	sbiw	r24, 0x01	; 1
     e24:	f1 f7       	brne	.-4      	; 0xe22 <ds2401_init+0x76>
      OW_RELEASE();    /* Releases the bus */
      udelay(tB);
    } else {
      OW_DRIVE();
      udelay(tC);
      OW_RELEASE();    /* Releases the bus */
     e26:	d4 98       	cbi	0x1a, 4	; 26
     e28:	dc 9a       	sbi	0x1b, 4	; 27
 * TODO: Moving the delay_loop to dev/clock.c
 */
static void
delay_loop(uint16_t __count)
{
  asm volatile ("1: sbiw %0,1" "\n\t"
     e2a:	cb 01       	movw	r24, r22
     e2c:	01 97       	sbiw	r24, 0x01	; 1
     e2e:	f1 f7       	brne	.-4      	; 0xe2c <ds2401_init+0x80>
     e30:	b1 50       	subi	r27, 0x01	; 1
      OW_DRIVE();
      udelay(tC);
      OW_RELEASE();    /* Releases the bus */
      udelay(tD);
    }
    if (i == 0)
     e32:	11 f0       	breq	.+4      	; 0xe38 <ds2401_init+0x8c>
      return;
    i--;
    byte >>= 1;
     e34:	a6 95       	lsr	r26
     e36:	e7 cf       	rjmp	.-50     	; 0xe06 <ds2401_init+0x5a>
  sreg = SREG;    /* Save status register before disabling interrupts. */
  cli();    /* Disable interrupts. */

  if (reset() == 0) {
    write_byte(0x33);    /* Read ROM command. */   
    family = read_byte();
     e38:	0e 94 a1 06 	call	0xd42	; 0xd42 <read_byte>
     e3c:	6c 01       	movw	r12, r24
     e3e:	08 e1       	ldi	r16, 0x18	; 24
     e40:	1e e0       	ldi	r17, 0x0E	; 14

  return acc;
}
/*---------------------------------------------------------------------------*/
int
ds2401_init()
     e42:	78 01       	movw	r14, r16

  if (reset() == 0) {
    write_byte(0x33);    /* Read ROM command. */   
    family = read_byte();
    for (i = 7; i >= 2; i--) {
      ds2401_id[i] = read_byte();
     e44:	0e 94 a1 06 	call	0xd42	; 0xd42 <read_byte>
     e48:	d7 01       	movw	r26, r14
     e4a:	8e 93       	st	-X, r24
     e4c:	7d 01       	movw	r14, r26
  cli();    /* Disable interrupts. */

  if (reset() == 0) {
    write_byte(0x33);    /* Read ROM command. */   
    family = read_byte();
    for (i = 7; i >= 2; i--) {
     e4e:	b2 e1       	ldi	r27, 0x12	; 18
     e50:	eb 16       	cp	r14, r27
     e52:	be e0       	ldi	r27, 0x0E	; 14
     e54:	fb 06       	cpc	r15, r27
     e56:	b1 f7       	brne	.-20     	; 0xe44 <ds2401_init+0x98>
      ds2401_id[i] = read_byte();
    }
    crc = read_byte();
     e58:	0e 94 a1 06 	call	0xd42	; 0xd42 <read_byte>
     e5c:	7c 01       	movw	r14, r24

    SREG = sreg;    /* Enable interrupts. */
     e5e:	89 81       	ldd	r24, Y+1	; 0x01
     e60:	8f bf       	out	0x3f, r24	; 63

    if(family != 0x01) {
     e62:	e1 e0       	ldi	r30, 0x01	; 1
     e64:	ce 16       	cp	r12, r30
     e66:	d1 04       	cpc	r13, r1
     e68:	01 f5       	brne	.+64     	; 0xeaa <ds2401_init+0xfe>
      goto fail;
    }
    acc = crc8_add(0x0, family);
     e6a:	80 e0       	ldi	r24, 0x00	; 0
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	61 e0       	ldi	r22, 0x01	; 1
     e70:	70 e0       	ldi	r23, 0x00	; 0
     e72:	0e 94 c2 06 	call	0xd84	; 0xd84 <crc8_add>
    for (i = 7; i >= 2; i--) {
      acc = crc8_add(acc, ds2401_id[i]);
     e76:	d8 01       	movw	r26, r16
     e78:	6e 91       	ld	r22, -X
     e7a:	8d 01       	movw	r16, r26
     e7c:	70 e0       	ldi	r23, 0x00	; 0
     e7e:	0e 94 c2 06 	call	0xd84	; 0xd84 <crc8_add>

    if(family != 0x01) {
      goto fail;
    }
    acc = crc8_add(0x0, family);
    for (i = 7; i >= 2; i--) {
     e82:	be e0       	ldi	r27, 0x0E	; 14
     e84:	02 31       	cpi	r16, 0x12	; 18
     e86:	1b 07       	cpc	r17, r27
     e88:	b1 f7       	brne	.-20     	; 0xe76 <ds2401_init+0xca>
      acc = crc8_add(acc, ds2401_id[i]);
    }
    if (acc == crc) {
     e8a:	8e 15       	cp	r24, r14
     e8c:	9f 05       	cpc	r25, r15
     e8e:	69 f4       	brne	.+26     	; 0xeaa <ds2401_init+0xfe>
      /* 00:1A:4C    OUI for Crossbow Technology, Inc. */
      ds2401_id[0] = 0x00;
     e90:	10 92 10 0e 	sts	0x0E10, r1
      ds2401_id[1] = 0x1A;
     e94:	8a e1       	ldi	r24, 0x1A	; 26
     e96:	80 93 11 0e 	sts	0x0E11, r24
      ds2401_id[2] = 0x4C;
     e9a:	8c e4       	ldi	r24, 0x4C	; 76
     e9c:	80 93 12 0e 	sts	0x0E12, r24
      return 1;	/* Success! */
     ea0:	21 e0       	ldi	r18, 0x01	; 1
     ea2:	30 e0       	ldi	r19, 0x00	; 0
     ea4:	0b c0       	rjmp	.+22     	; 0xebc <ds2401_init+0x110>
    }
  } else {
    SREG = sreg;    /* Enable interrupts. */
     ea6:	89 81       	ldd	r24, Y+1	; 0x01
     ea8:	8f bf       	out	0x3f, r24	; 63
  }

fail:
  memset(ds2401_id, 0x0, sizeof(ds2401_id));
     eaa:	88 e0       	ldi	r24, 0x08	; 8
     eac:	e0 e1       	ldi	r30, 0x10	; 16
     eae:	fe e0       	ldi	r31, 0x0E	; 14
     eb0:	df 01       	movw	r26, r30
     eb2:	1d 92       	st	X+, r1
     eb4:	8a 95       	dec	r24
     eb6:	e9 f7       	brne	.-6      	; 0xeb2 <ds2401_init+0x106>
  return 0;  /* Fail! */
     eb8:	20 e0       	ldi	r18, 0x00	; 0
     eba:	30 e0       	ldi	r19, 0x00	; 0
}
     ebc:	c9 01       	movw	r24, r18
     ebe:	0f 90       	pop	r0
     ec0:	cf 91       	pop	r28
     ec2:	df 91       	pop	r29
     ec4:	1f 91       	pop	r17
     ec6:	0f 91       	pop	r16
     ec8:	ff 90       	pop	r15
     eca:	ef 90       	pop	r14
     ecc:	df 90       	pop	r13
     ece:	cf 90       	pop	r12
     ed0:	08 95       	ret

00000ed2 <eeprom_write>:
#include <stdio.h>

/*---------------------------------------------------------------------------*/
void
eeprom_write(eeprom_addr_t addr, unsigned char *buf, int size)
{
     ed2:	9c 01       	movw	r18, r24
     ed4:	cb 01       	movw	r24, r22
  while(!eeprom_is_ready());
     ed6:	e1 99       	sbic	0x1c, 1	; 28
     ed8:	fe cf       	rjmp	.-4      	; 0xed6 <eeprom_write+0x4>
  eeprom_write_block(buf, (unsigned short *)addr, size);
     eda:	b9 01       	movw	r22, r18
     edc:	0e 94 7e 28 	call	0x50fc	; 0x50fc <__eewr_block_m128>
}
     ee0:	08 95       	ret

00000ee2 <eeprom_read>:
/*---------------------------------------------------------------------------*/
void
eeprom_read(eeprom_addr_t addr, unsigned char *buf, int size)
{
     ee2:	9c 01       	movw	r18, r24
     ee4:	cb 01       	movw	r24, r22
  while(!eeprom_is_ready());
     ee6:	e1 99       	sbic	0x1c, 1	; 28
     ee8:	fe cf       	rjmp	.-4      	; 0xee6 <eeprom_read+0x4>
  eeprom_read_block(buf, (unsigned short *)addr, size);
     eea:	b9 01       	movw	r22, r18
     eec:	0e 94 6e 28 	call	0x50dc	; 0x50dc <__eerd_block_m128>
}
     ef0:	08 95       	ret

00000ef2 <show_leds.clone.0>:
      ENERGEST_ON(ENERGEST_TYPE_LED_RED);
    } else {
      ENERGEST_OFF(ENERGEST_TYPE_LED_RED);
    }
  }
  leds_arch_set(leds ^ invert);
     ef2:	90 91 24 06 	lds	r25, 0x0624
     ef6:	80 91 25 06 	lds	r24, 0x0625
     efa:	89 27       	eor	r24, r25
     efc:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <leds_arch_set>
}
     f00:	08 95       	ret

00000f02 <leds_init>:
/*---------------------------------------------------------------------------*/
void
leds_init(void)
{
  leds_arch_init();
     f02:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <leds_arch_init>
  leds = invert = 0;
     f06:	10 92 24 06 	sts	0x0624, r1
     f0a:	10 92 25 06 	sts	0x0625, r1
}
     f0e:	08 95       	ret

00000f10 <leds_get>:
  leds_invert(inv);
}
/*---------------------------------------------------------------------------*/
unsigned char
leds_get(void) {
  return leds_arch_get();
     f10:	0e 94 29 1d 	call	0x3a52	; 0x3a52 <leds_arch_get>
}
     f14:	08 95       	ret

00000f16 <leds_on>:
void
leds_on(unsigned char ledv)
{
  unsigned char changed;
  changed = (~leds) & ledv;
  leds |= ledv;
     f16:	90 91 25 06 	lds	r25, 0x0625
     f1a:	98 2b       	or	r25, r24
     f1c:	90 93 25 06 	sts	0x0625, r25
  show_leds(changed);
     f20:	0e 94 79 07 	call	0xef2	; 0xef2 <show_leds.clone.0>
}
     f24:	08 95       	ret

00000f26 <leds_off>:
void
leds_off(unsigned char ledv)
{
  unsigned char changed;
  changed = leds & ledv;
  leds &= ~ledv;
     f26:	80 95       	com	r24
     f28:	90 91 25 06 	lds	r25, 0x0625
     f2c:	98 23       	and	r25, r24
     f2e:	90 93 25 06 	sts	0x0625, r25
  show_leds(changed);
     f32:	0e 94 79 07 	call	0xef2	; 0xef2 <show_leds.clone.0>
}
     f36:	08 95       	ret

00000f38 <leds_invert>:
}
/*---------------------------------------------------------------------------*/
/*   invert the invert register using the leds parameter */
void
leds_invert(unsigned char ledv) {
  invert = invert ^ ledv;
     f38:	90 91 24 06 	lds	r25, 0x0624
     f3c:	98 27       	eor	r25, r24
     f3e:	90 93 24 06 	sts	0x0624, r25
  show_leds(ledv);
     f42:	0e 94 79 07 	call	0xef2	; 0xef2 <show_leds.clone.0>
}
     f46:	08 95       	ret

00000f48 <leds_toggle>:
}
/*---------------------------------------------------------------------------*/
void
leds_toggle(unsigned char ledv)
{
  leds_invert(ledv);
     f48:	0e 94 9c 07 	call	0xf38	; 0xf38 <leds_invert>
}
     f4c:	08 95       	ret

00000f4e <leds_blink>:
  leds = invert = 0;
}
/*---------------------------------------------------------------------------*/
void
leds_blink(void)
{
     f4e:	1f 93       	push	r17
  /* Blink all leds. */
  unsigned char inv;
  inv = ~(leds ^ invert);
     f50:	10 91 24 06 	lds	r17, 0x0624
     f54:	80 91 25 06 	lds	r24, 0x0625
     f58:	18 27       	eor	r17, r24
     f5a:	10 95       	com	r17
  leds_invert(inv);
     f5c:	81 2f       	mov	r24, r17
     f5e:	0e 94 9c 07 	call	0xf38	; 0xf38 <leds_invert>

  clock_delay(400);
     f62:	80 e9       	ldi	r24, 0x90	; 144
     f64:	91 e0       	ldi	r25, 0x01	; 1
     f66:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clock_delay>

  leds_invert(inv);
     f6a:	81 2f       	mov	r24, r17
     f6c:	0e 94 9c 07 	call	0xf38	; 0xf38 <leds_invert>
}
     f70:	1f 91       	pop	r17
     f72:	08 95       	ret

00000f74 <rimeaddr_copy>:


/*---------------------------------------------------------------------------*/
void
rimeaddr_copy(rimeaddr_t *dest, const rimeaddr_t *src)
{
     f74:	fc 01       	movw	r30, r24
     f76:	db 01       	movw	r26, r22
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    dest->u8[i] = src->u8[i];
     f78:	8c 91       	ld	r24, X
     f7a:	80 83       	st	Z, r24
     f7c:	11 96       	adiw	r26, 0x01	; 1
     f7e:	8c 91       	ld	r24, X
     f80:	11 97       	sbiw	r26, 0x01	; 1
     f82:	81 83       	std	Z+1, r24	; 0x01
  }
}
     f84:	08 95       	ret

00000f86 <rimeaddr_cmp>:
/*---------------------------------------------------------------------------*/
int
rimeaddr_cmp(const rimeaddr_t *addr1, const rimeaddr_t *addr2)
{
     f86:	fc 01       	movw	r30, r24
     f88:	db 01       	movw	r26, r22
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    if(addr1->u8[i] != addr2->u8[i]) {
     f8a:	90 81       	ld	r25, Z
     f8c:	8c 91       	ld	r24, X
     f8e:	98 17       	cp	r25, r24
     f90:	41 f4       	brne	.+16     	; 0xfa2 <rimeaddr_cmp+0x1c>
      return 0;
     f92:	21 e0       	ldi	r18, 0x01	; 1
     f94:	30 e0       	ldi	r19, 0x00	; 0
     f96:	91 81       	ldd	r25, Z+1	; 0x01
     f98:	11 96       	adiw	r26, 0x01	; 1
     f9a:	8c 91       	ld	r24, X
     f9c:	11 97       	sbiw	r26, 0x01	; 1
     f9e:	98 17       	cp	r25, r24
     fa0:	11 f0       	breq	.+4      	; 0xfa6 <rimeaddr_cmp+0x20>
     fa2:	20 e0       	ldi	r18, 0x00	; 0
     fa4:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  return 1;
}
     fa6:	c9 01       	movw	r24, r18
     fa8:	08 95       	ret

00000faa <rimeaddr_set_node_addr>:
/*---------------------------------------------------------------------------*/
void
rimeaddr_set_node_addr(rimeaddr_t *t)
{
     faa:	fc 01       	movw	r30, r24
void
rimeaddr_copy(rimeaddr_t *dest, const rimeaddr_t *src)
{
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    dest->u8[i] = src->u8[i];
     fac:	80 81       	ld	r24, Z
     fae:	80 93 18 0e 	sts	0x0E18, r24
     fb2:	81 81       	ldd	r24, Z+1	; 0x01
     fb4:	80 93 19 0e 	sts	0x0E19, r24
/*---------------------------------------------------------------------------*/
void
rimeaddr_set_node_addr(rimeaddr_t *t)
{
  rimeaddr_copy(&rimeaddr_node_addr, t);
}
     fb8:	08 95       	ret

00000fba <input>:
  list_remove(sniffers, s);
}
/*---------------------------------------------------------------------------*/
static void
input(void)
{
     fba:	0f 93       	push	r16
     fbc:	1f 93       	push	r17
     fbe:	cf 93       	push	r28
     fc0:	df 93       	push	r29
  struct rime_sniffer *s;
  struct channel *c;

  RIMESTATS_ADD(rx);
     fc2:	80 91 1e 0e 	lds	r24, 0x0E1E
     fc6:	90 91 1f 0e 	lds	r25, 0x0E1F
     fca:	a0 91 20 0e 	lds	r26, 0x0E20
     fce:	b0 91 21 0e 	lds	r27, 0x0E21
     fd2:	01 96       	adiw	r24, 0x01	; 1
     fd4:	a1 1d       	adc	r26, r1
     fd6:	b1 1d       	adc	r27, r1
     fd8:	80 93 1e 0e 	sts	0x0E1E, r24
     fdc:	90 93 1f 0e 	sts	0x0E1F, r25
     fe0:	a0 93 20 0e 	sts	0x0E20, r26
     fe4:	b0 93 21 0e 	sts	0x0E21, r27
  c = chameleon_parse();
     fe8:	0e 94 04 0b 	call	0x1608	; 0x1608 <chameleon_parse>
     fec:	ec 01       	movw	r28, r24
  
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
     fee:	86 e2       	ldi	r24, 0x26	; 38
     ff0:	96 e0       	ldi	r25, 0x06	; 6
     ff2:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
     ff6:	0b c0       	rjmp	.+22     	; 0x100e <input+0x54>
    if(s->input_callback != NULL) {
     ff8:	d8 01       	movw	r26, r16
     ffa:	12 96       	adiw	r26, 0x02	; 2
     ffc:	ed 91       	ld	r30, X+
     ffe:	fc 91       	ld	r31, X
    1000:	13 97       	sbiw	r26, 0x03	; 3
    1002:	30 97       	sbiw	r30, 0x00	; 0
    1004:	09 f0       	breq	.+2      	; 0x1008 <input+0x4e>
      s->input_callback();
    1006:	09 95       	icall
  struct channel *c;

  RIMESTATS_ADD(rx);
  c = chameleon_parse();
  
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    1008:	c8 01       	movw	r24, r16
    100a:	0e 94 31 18 	call	0x3062	; 0x3062 <list_item_next>
    100e:	08 2f       	mov	r16, r24
    1010:	19 2f       	mov	r17, r25
    1012:	01 15       	cp	r16, r1
    1014:	11 05       	cpc	r17, r1
    1016:	81 f7       	brne	.-32     	; 0xff8 <input+0x3e>
    if(s->input_callback != NULL) {
      s->input_callback();
    }
  }
  
  if(c != NULL) {
    1018:	20 97       	sbiw	r28, 0x00	; 0
    101a:	19 f0       	breq	.+6      	; 0x1022 <input+0x68>
    abc_input(c);
    101c:	ce 01       	movw	r24, r28
    101e:	0e 94 ed 0a 	call	0x15da	; 0x15da <abc_input>
  }
}
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	08 95       	ret

0000102c <init>:
/*---------------------------------------------------------------------------*/
static void
init(void)
{
  queuebuf_init();
    102c:	0e 94 3e 1b 	call	0x367c	; 0x367c <queuebuf_init>
  packetbuf_clear();
    1030:	0e 94 b8 1a 	call	0x3570	; 0x3570 <packetbuf_clear>
  announcement_init();
    1034:	0e 94 92 08 	call	0x1124	; 0x1124 <announcement_init>

  chameleon_init();
    1038:	0e 94 01 0b 	call	0x1602	; 0x1602 <chameleon_init>
   * either be configurable, or derived from some MAC layer property
   * (duty cycle, sleep time, or something similar). But this is OK
   * for now, and should at least get us started with experimenting
   * with announcements.
   */
  broadcast_announcement_init(BROADCAST_ANNOUNCEMENT_CHANNEL,
    103c:	82 e0       	ldi	r24, 0x02	; 2
    103e:	90 e0       	ldi	r25, 0x00	; 0
    1040:	60 e0       	ldi	r22, 0x00	; 0
    1042:	72 e0       	ldi	r23, 0x02	; 2
    1044:	40 e0       	ldi	r20, 0x00	; 0
    1046:	5e e1       	ldi	r21, 0x1E	; 30
    1048:	2f ef       	ldi	r18, 0xFF	; 255
    104a:	31 e0       	ldi	r19, 0x01	; 1
    104c:	0e 94 2f 0a 	call	0x145e	; 0x145e <broadcast_announcement_init>
                              BROADCAST_ANNOUNCEMENT_BUMP_TIME,
                              BROADCAST_ANNOUNCEMENT_MIN_TIME,
                              BROADCAST_ANNOUNCEMENT_MAX_TIME);
}
    1050:	08 95       	ret

00001052 <packet_sent>:
/*---------------------------------------------------------------------------*/
static void
packet_sent(void *ptr, int status, int num_tx)
{
    1052:	cf 92       	push	r12
    1054:	df 92       	push	r13
    1056:	ef 92       	push	r14
    1058:	ff 92       	push	r15
    105a:	0f 93       	push	r16
    105c:	1f 93       	push	r17
    105e:	cf 93       	push	r28
    1060:	df 93       	push	r29
    1062:	6c 01       	movw	r12, r24
    1064:	eb 01       	movw	r28, r22
    1066:	8a 01       	movw	r16, r20
  default:
    PRINTF("rime: error %d after %d tx\n", status, num_tx);
  }

  /* Call sniffers, pass along the MAC status code. */
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    1068:	86 e2       	ldi	r24, 0x26	; 38
    106a:	96 e0       	ldi	r25, 0x06	; 6
    106c:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
    1070:	0c c0       	rjmp	.+24     	; 0x108a <packet_sent+0x38>
    if(s->output_callback != NULL) {
    1072:	d7 01       	movw	r26, r14
    1074:	14 96       	adiw	r26, 0x04	; 4
    1076:	ed 91       	ld	r30, X+
    1078:	fc 91       	ld	r31, X
    107a:	15 97       	sbiw	r26, 0x05	; 5
    107c:	30 97       	sbiw	r30, 0x00	; 0
    107e:	11 f0       	breq	.+4      	; 0x1084 <packet_sent+0x32>
      s->output_callback(status);
    1080:	ce 01       	movw	r24, r28
    1082:	09 95       	icall
  default:
    PRINTF("rime: error %d after %d tx\n", status, num_tx);
  }

  /* Call sniffers, pass along the MAC status code. */
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    1084:	c7 01       	movw	r24, r14
    1086:	0e 94 31 18 	call	0x3062	; 0x3062 <list_item_next>
    108a:	e8 2e       	mov	r14, r24
    108c:	f9 2e       	mov	r15, r25
    108e:	e1 14       	cp	r14, r1
    1090:	f1 04       	cpc	r15, r1
    1092:	79 f7       	brne	.-34     	; 0x1072 <packet_sent+0x20>
    if(s->output_callback != NULL) {
      s->output_callback(status);
    }
  }

  abc_sent(c, status, num_tx);
    1094:	c6 01       	movw	r24, r12
    1096:	be 01       	movw	r22, r28
    1098:	a8 01       	movw	r20, r16
    109a:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <abc_sent>
}
    109e:	df 91       	pop	r29
    10a0:	cf 91       	pop	r28
    10a2:	1f 91       	pop	r17
    10a4:	0f 91       	pop	r16
    10a6:	ff 90       	pop	r15
    10a8:	ef 90       	pop	r14
    10aa:	df 90       	pop	r13
    10ac:	cf 90       	pop	r12
    10ae:	08 95       	ret

000010b0 <rime_sniffer_add>:
LIST(sniffers);

/*---------------------------------------------------------------------------*/
void
rime_sniffer_add(struct rime_sniffer *s)
{
    10b0:	bc 01       	movw	r22, r24
  list_add(sniffers, s);
    10b2:	86 e2       	ldi	r24, 0x26	; 38
    10b4:	96 e0       	ldi	r25, 0x06	; 6
    10b6:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <list_add>
}
    10ba:	08 95       	ret

000010bc <rime_sniffer_remove>:
/*---------------------------------------------------------------------------*/
void
rime_sniffer_remove(struct rime_sniffer *s)
{
    10bc:	bc 01       	movw	r22, r24
  list_remove(sniffers, s);
    10be:	86 e2       	ldi	r24, 0x26	; 38
    10c0:	96 e0       	ldi	r25, 0x06	; 6
    10c2:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>
}
    10c6:	08 95       	ret

000010c8 <rime_output>:
  abc_sent(c, status, num_tx);
}
/*---------------------------------------------------------------------------*/
int
rime_output(struct channel *c)
{
    10c8:	cf 93       	push	r28
    10ca:	df 93       	push	r29
    10cc:	ec 01       	movw	r28, r24
  RIMESTATS_ADD(tx);
    10ce:	80 91 1a 0e 	lds	r24, 0x0E1A
    10d2:	90 91 1b 0e 	lds	r25, 0x0E1B
    10d6:	a0 91 1c 0e 	lds	r26, 0x0E1C
    10da:	b0 91 1d 0e 	lds	r27, 0x0E1D
    10de:	01 96       	adiw	r24, 0x01	; 1
    10e0:	a1 1d       	adc	r26, r1
    10e2:	b1 1d       	adc	r27, r1
    10e4:	80 93 1a 0e 	sts	0x0E1A, r24
    10e8:	90 93 1b 0e 	sts	0x0E1B, r25
    10ec:	a0 93 1c 0e 	sts	0x0E1C, r26
    10f0:	b0 93 1d 0e 	sts	0x0E1D, r27
  if(chameleon_create(c)) {
    10f4:	ce 01       	movw	r24, r28
    10f6:	0e 94 14 0b 	call	0x1628	; 0x1628 <chameleon_create>
    10fa:	00 97       	sbiw	r24, 0x00	; 0
    10fc:	69 f0       	breq	.+26     	; 0x1118 <__stack+0x19>
    packetbuf_compact();
    10fe:	0e 94 32 1a 	call	0x3464	; 0x3464 <packetbuf_compact>

    NETSTACK_MAC.send(packet_sent, c);
    1102:	e0 91 03 04 	lds	r30, 0x0403
    1106:	f0 91 04 04 	lds	r31, 0x0404
    110a:	89 e2       	ldi	r24, 0x29	; 41
    110c:	98 e0       	ldi	r25, 0x08	; 8
    110e:	be 01       	movw	r22, r28
    1110:	09 95       	icall
    return 1;
    1112:	21 e0       	ldi	r18, 0x01	; 1
    1114:	30 e0       	ldi	r19, 0x00	; 0
    1116:	02 c0       	rjmp	.+4      	; 0x111c <__stack+0x1d>
  }
  return 0;
    1118:	20 e0       	ldi	r18, 0x00	; 0
    111a:	30 e0       	ldi	r19, 0x00	; 0
}
    111c:	c9 01       	movw	r24, r18
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	08 95       	ret

00001124 <announcement_init>:

/*---------------------------------------------------------------------------*/
void
announcement_init(void)
{
  list_init(announcements);
    1124:	88 e2       	ldi	r24, 0x28	; 40
    1126:	96 e0       	ldi	r25, 0x06	; 6
    1128:	0e 94 67 17 	call	0x2ece	; 0x2ece <list_init>
}
    112c:	08 95       	ret

0000112e <announcement_register>:
/*---------------------------------------------------------------------------*/
void
announcement_register(struct announcement *a, uint16_t id,
		      announcement_callback_t callback)
{
    112e:	0f 93       	push	r16
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	ec 01       	movw	r28, r24
  a->id = id;
    1136:	7b 83       	std	Y+3, r23	; 0x03
    1138:	6a 83       	std	Y+2, r22	; 0x02
  a->has_value = 0;
    113a:	18 86       	std	Y+8, r1	; 0x08
  a->callback = callback;
    113c:	5f 83       	std	Y+7, r21	; 0x07
    113e:	4e 83       	std	Y+6, r20	; 0x06
  list_add(announcements, a);
    1140:	88 e2       	ldi	r24, 0x28	; 40
    1142:	96 e0       	ldi	r25, 0x06	; 6
    1144:	be 01       	movw	r22, r28
    1146:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <list_add>
  if(observer_callback) {
    114a:	e0 91 2a 06 	lds	r30, 0x062A
    114e:	f0 91 2b 06 	lds	r31, 0x062B
    1152:	30 97       	sbiw	r30, 0x00	; 0
    1154:	49 f0       	breq	.+18     	; 0x1168 <announcement_register+0x3a>
    observer_callback(a->id, a->has_value,
    1156:	4c 81       	ldd	r20, Y+4	; 0x04
    1158:	5d 81       	ldd	r21, Y+5	; 0x05
    115a:	8a 81       	ldd	r24, Y+2	; 0x02
    115c:	9b 81       	ldd	r25, Y+3	; 0x03
    115e:	68 85       	ldd	r22, Y+8	; 0x08
    1160:	20 e0       	ldi	r18, 0x00	; 0
    1162:	30 e0       	ldi	r19, 0x00	; 0
    1164:	01 e0       	ldi	r16, 0x01	; 1
    1166:	09 95       	icall
                      a->value, 0, ANNOUNCEMENT_BUMP);
  }
}
    1168:	df 91       	pop	r29
    116a:	cf 91       	pop	r28
    116c:	0f 91       	pop	r16
    116e:	08 95       	ret

00001170 <announcement_remove>:
/*---------------------------------------------------------------------------*/
void
announcement_remove(struct announcement *a)
{
    1170:	bc 01       	movw	r22, r24
  list_remove(announcements, a);
    1172:	88 e2       	ldi	r24, 0x28	; 40
    1174:	96 e0       	ldi	r25, 0x06	; 6
    1176:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>
}
    117a:	08 95       	ret

0000117c <announcement_remove_value>:
/*---------------------------------------------------------------------------*/
void
announcement_remove_value(struct announcement *a)
{
    117c:	0f 93       	push	r16
    117e:	dc 01       	movw	r26, r24
  a->has_value = 0;
    1180:	18 96       	adiw	r26, 0x08	; 8
    1182:	1c 92       	st	X, r1
    1184:	18 97       	sbiw	r26, 0x08	; 8
  if(observer_callback) {
    1186:	e0 91 2a 06 	lds	r30, 0x062A
    118a:	f0 91 2b 06 	lds	r31, 0x062B
    118e:	30 97       	sbiw	r30, 0x00	; 0
    1190:	59 f0       	breq	.+22     	; 0x11a8 <announcement_remove_value+0x2c>
    observer_callback(a->id, 0, 0, 0, ANNOUNCEMENT_NOBUMP);
    1192:	12 96       	adiw	r26, 0x02	; 2
    1194:	8d 91       	ld	r24, X+
    1196:	9c 91       	ld	r25, X
    1198:	13 97       	sbiw	r26, 0x03	; 3
    119a:	60 e0       	ldi	r22, 0x00	; 0
    119c:	40 e0       	ldi	r20, 0x00	; 0
    119e:	50 e0       	ldi	r21, 0x00	; 0
    11a0:	20 e0       	ldi	r18, 0x00	; 0
    11a2:	30 e0       	ldi	r19, 0x00	; 0
    11a4:	00 e0       	ldi	r16, 0x00	; 0
    11a6:	09 95       	icall
  }

}
    11a8:	0f 91       	pop	r16
    11aa:	08 95       	ret

000011ac <announcement_set_value>:
/*---------------------------------------------------------------------------*/
void
announcement_set_value(struct announcement *a, uint16_t value)
{
    11ac:	0f 93       	push	r16
    11ae:	dc 01       	movw	r26, r24
    11b0:	ab 01       	movw	r20, r22
  uint16_t oldvalue = a->value;
    11b2:	14 96       	adiw	r26, 0x04	; 4
    11b4:	2d 91       	ld	r18, X+
    11b6:	3c 91       	ld	r19, X
    11b8:	15 97       	sbiw	r26, 0x05	; 5

  a->has_value = 1;
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	18 96       	adiw	r26, 0x08	; 8
    11be:	8c 93       	st	X, r24
    11c0:	18 97       	sbiw	r26, 0x08	; 8
  a->value = value;
    11c2:	15 96       	adiw	r26, 0x05	; 5
    11c4:	7c 93       	st	X, r23
    11c6:	6e 93       	st	-X, r22
    11c8:	14 97       	sbiw	r26, 0x04	; 4
  if(observer_callback) {
    11ca:	e0 91 2a 06 	lds	r30, 0x062A
    11ce:	f0 91 2b 06 	lds	r31, 0x062B
    11d2:	30 97       	sbiw	r30, 0x00	; 0
    11d4:	39 f0       	breq	.+14     	; 0x11e4 <announcement_set_value+0x38>
    observer_callback(a->id, a->has_value,
    11d6:	12 96       	adiw	r26, 0x02	; 2
    11d8:	8d 91       	ld	r24, X+
    11da:	9c 91       	ld	r25, X
    11dc:	13 97       	sbiw	r26, 0x03	; 3
    11de:	61 e0       	ldi	r22, 0x01	; 1
    11e0:	00 e0       	ldi	r16, 0x00	; 0
    11e2:	09 95       	icall
                      value, oldvalue, ANNOUNCEMENT_NOBUMP);
  }
}
    11e4:	0f 91       	pop	r16
    11e6:	08 95       	ret

000011e8 <announcement_bump>:
/*---------------------------------------------------------------------------*/
void
announcement_bump(struct announcement *a)
{
    11e8:	0f 93       	push	r16
    11ea:	dc 01       	movw	r26, r24
  if(observer_callback) {
    11ec:	e0 91 2a 06 	lds	r30, 0x062A
    11f0:	f0 91 2b 06 	lds	r31, 0x062B
    11f4:	30 97       	sbiw	r30, 0x00	; 0
    11f6:	69 f0       	breq	.+26     	; 0x1212 <announcement_bump+0x2a>
    observer_callback(a->id, a->has_value,
    11f8:	14 96       	adiw	r26, 0x04	; 4
    11fa:	2d 91       	ld	r18, X+
    11fc:	3c 91       	ld	r19, X
    11fe:	15 97       	sbiw	r26, 0x05	; 5
    1200:	12 96       	adiw	r26, 0x02	; 2
    1202:	8d 91       	ld	r24, X+
    1204:	9c 91       	ld	r25, X
    1206:	13 97       	sbiw	r26, 0x03	; 3
    1208:	18 96       	adiw	r26, 0x08	; 8
    120a:	6c 91       	ld	r22, X
    120c:	a9 01       	movw	r20, r18
    120e:	01 e0       	ldi	r16, 0x01	; 1
    1210:	09 95       	icall
                      a->value, a->value, ANNOUNCEMENT_BUMP);
  }
}
    1212:	0f 91       	pop	r16
    1214:	08 95       	ret

00001216 <announcement_listen>:
/*---------------------------------------------------------------------------*/
void
announcement_listen(int time)
{
  if(listen_callback) {
    1216:	e0 91 2c 06 	lds	r30, 0x062C
    121a:	f0 91 2d 06 	lds	r31, 0x062D
    121e:	30 97       	sbiw	r30, 0x00	; 0
    1220:	09 f0       	breq	.+2      	; 0x1224 <announcement_listen+0xe>
    listen_callback(time);
    1222:	09 95       	icall
    1224:	08 95       	ret

00001226 <announcement_register_listen_callback>:
}
/*---------------------------------------------------------------------------*/
void
announcement_register_listen_callback(void (*callback)(int time))
{
  listen_callback = callback;
    1226:	90 93 2d 06 	sts	0x062D, r25
    122a:	80 93 2c 06 	sts	0x062C, r24
}
    122e:	08 95       	ret

00001230 <announcement_register_observer_callback>:
/*---------------------------------------------------------------------------*/
void
announcement_register_observer_callback(announcement_observer callback)
{
  observer_callback = callback;
    1230:	90 93 2b 06 	sts	0x062B, r25
    1234:	80 93 2a 06 	sts	0x062A, r24
}
    1238:	08 95       	ret

0000123a <announcement_list>:
/*---------------------------------------------------------------------------*/
struct announcement *
announcement_list(void)
{
  return list_head(announcements);
    123a:	88 e2       	ldi	r24, 0x28	; 40
    123c:	96 e0       	ldi	r25, 0x06	; 6
    123e:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
}
    1242:	08 95       	ret

00001244 <announcement_heard>:
/*---------------------------------------------------------------------------*/
void
announcement_heard(const rimeaddr_t *from, uint16_t id, uint16_t value)
{
    1244:	ef 92       	push	r14
    1246:	ff 92       	push	r15
    1248:	0f 93       	push	r16
    124a:	1f 93       	push	r17
    124c:	cf 93       	push	r28
    124e:	df 93       	push	r29
    1250:	8c 01       	movw	r16, r24
    1252:	eb 01       	movw	r28, r22
    1254:	7a 01       	movw	r14, r20
  struct announcement *a;
  for(a = list_head(announcements); a != NULL; a = list_item_next(a)) {
    1256:	88 e2       	ldi	r24, 0x28	; 40
    1258:	96 e0       	ldi	r25, 0x06	; 6
    125a:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
    125e:	15 c0       	rjmp	.+42     	; 0x128a <announcement_heard+0x46>
    if(a->id == id) {
    1260:	dc 01       	movw	r26, r24
    1262:	12 96       	adiw	r26, 0x02	; 2
    1264:	2d 91       	ld	r18, X+
    1266:	3c 91       	ld	r19, X
    1268:	13 97       	sbiw	r26, 0x03	; 3
    126a:	2c 17       	cp	r18, r28
    126c:	3d 07       	cpc	r19, r29
    126e:	59 f4       	brne	.+22     	; 0x1286 <announcement_heard+0x42>
      if(a->callback != NULL) {
    1270:	16 96       	adiw	r26, 0x06	; 6
    1272:	ed 91       	ld	r30, X+
    1274:	fc 91       	ld	r31, X
    1276:	17 97       	sbiw	r26, 0x07	; 7
    1278:	30 97       	sbiw	r30, 0x00	; 0
    127a:	61 f0       	breq	.+24     	; 0x1294 <announcement_heard+0x50>
	a->callback(a, from, id, value);
    127c:	b8 01       	movw	r22, r16
    127e:	ae 01       	movw	r20, r28
    1280:	97 01       	movw	r18, r14
    1282:	09 95       	icall
    1284:	07 c0       	rjmp	.+14     	; 0x1294 <announcement_heard+0x50>
/*---------------------------------------------------------------------------*/
void
announcement_heard(const rimeaddr_t *from, uint16_t id, uint16_t value)
{
  struct announcement *a;
  for(a = list_head(announcements); a != NULL; a = list_item_next(a)) {
    1286:	0e 94 31 18 	call	0x3062	; 0x3062 <list_item_next>
    128a:	28 2f       	mov	r18, r24
    128c:	39 2f       	mov	r19, r25
    128e:	c9 01       	movw	r24, r18
    1290:	00 97       	sbiw	r24, 0x00	; 0
    1292:	31 f7       	brne	.-52     	; 0x1260 <announcement_heard+0x1c>
	a->callback(a, from, id, value);
      }
      return;
    }
  }
}
    1294:	df 91       	pop	r29
    1296:	cf 91       	pop	r28
    1298:	1f 91       	pop	r17
    129a:	0f 91       	pop	r16
    129c:	ff 90       	pop	r15
    129e:	ef 90       	pop	r14
    12a0:	08 95       	ret

000012a2 <adv_packet_sent>:
}
/*---------------------------------------------------------------------------*/
static void
adv_packet_sent(struct broadcast_conn *bc, int status, int num_tx)
{
}
    12a2:	08 95       	ret

000012a4 <adv_packet_received>:
	 c.val);
}
/*---------------------------------------------------------------------------*/
static void
adv_packet_received(struct broadcast_conn *ibc, const rimeaddr_t *from)
{
    12a4:	af 92       	push	r10
    12a6:	bf 92       	push	r11
    12a8:	cf 92       	push	r12
    12aa:	df 92       	push	r13
    12ac:	ef 92       	push	r14
    12ae:	ff 92       	push	r15
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	df 93       	push	r29
    12b6:	cf 93       	push	r28
    12b8:	00 d0       	rcall	.+0      	; 0x12ba <adv_packet_received+0x16>
    12ba:	cd b7       	in	r28, 0x3d	; 61
    12bc:	de b7       	in	r29, 0x3e	; 62
    12be:	5b 01       	movw	r10, r22
  struct announcement_msg adata;
  struct announcement_data data;
  uint8_t *ptr;
  int i;

  ptr = packetbuf_dataptr();
    12c0:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    12c4:	8c 01       	movw	r16, r24

  /* Copy number of announcements */
  memcpy(&adata, ptr, sizeof(struct announcement_msg));
    12c6:	fc 01       	movw	r30, r24
    12c8:	e0 80       	ld	r14, Z
    12ca:	f1 80       	ldd	r15, Z+1	; 0x01
    12cc:	fa 82       	std	Y+2, r15	; 0x02
    12ce:	e9 82       	std	Y+1, r14	; 0x01
  PRINTF("%d.%d: adv_packet_received from %d.%d with %d announcements\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	 from->u8[0], from->u8[1], adata.num);

  if(ANNOUNCEMENT_MSG_HEADERLEN + adata.num * sizeof(struct announcement_data) > packetbuf_datalen()) {
    12d0:	0e 94 67 1a 	call	0x34ce	; 0x34ce <packetbuf_datalen>
    12d4:	97 01       	movw	r18, r14
    12d6:	22 0f       	add	r18, r18
    12d8:	33 1f       	adc	r19, r19
    12da:	22 0f       	add	r18, r18
    12dc:	33 1f       	adc	r19, r19
    12de:	2e 5f       	subi	r18, 0xFE	; 254
    12e0:	3f 4f       	sbci	r19, 0xFF	; 255
    12e2:	82 17       	cp	r24, r18
    12e4:	93 07       	cpc	r25, r19
    12e6:	98 f0       	brcs	.+38     	; 0x130e <adv_packet_received+0x6a>
    PRINTF("adata.num way out there: %d\n", adata.num);
    return;
  }

  ptr += ANNOUNCEMENT_MSG_HEADERLEN;
  for(i = 0; i < adata.num; ++i) {
    12e8:	cc 24       	eor	r12, r12
    12ea:	dd 24       	eor	r13, r13
    12ec:	0d c0       	rjmp	.+26     	; 0x1308 <adv_packet_received+0x64>
    /* Copy announcements */
    memcpy(&data, ptr, sizeof(struct announcement_data));
    announcement_heard(from, data.id, data.value);
    12ee:	f8 01       	movw	r30, r16
    12f0:	62 81       	ldd	r22, Z+2	; 0x02
    12f2:	73 81       	ldd	r23, Z+3	; 0x03
    12f4:	44 81       	ldd	r20, Z+4	; 0x04
    12f6:	55 81       	ldd	r21, Z+5	; 0x05
    12f8:	c5 01       	movw	r24, r10
    12fa:	0e 94 22 09 	call	0x1244	; 0x1244 <announcement_heard>
    PRINTF("adata.num way out there: %d\n", adata.num);
    return;
  }

  ptr += ANNOUNCEMENT_MSG_HEADERLEN;
  for(i = 0; i < adata.num; ++i) {
    12fe:	08 94       	sec
    1300:	c1 1c       	adc	r12, r1
    1302:	d1 1c       	adc	r13, r1
    1304:	0c 5f       	subi	r16, 0xFC	; 252
    1306:	1f 4f       	sbci	r17, 0xFF	; 255
    1308:	ce 14       	cp	r12, r14
    130a:	df 04       	cpc	r13, r15
    130c:	80 f3       	brcs	.-32     	; 0x12ee <adv_packet_received+0x4a>
    /* Copy announcements */
    memcpy(&data, ptr, sizeof(struct announcement_data));
    announcement_heard(from, data.id, data.value);
    ptr += sizeof(struct announcement_data);
  }
}
    130e:	0f 90       	pop	r0
    1310:	0f 90       	pop	r0
    1312:	cf 91       	pop	r28
    1314:	df 91       	pop	r29
    1316:	1f 91       	pop	r17
    1318:	0f 91       	pop	r16
    131a:	ff 90       	pop	r15
    131c:	ef 90       	pop	r14
    131e:	df 90       	pop	r13
    1320:	cf 90       	pop	r12
    1322:	bf 90       	pop	r11
    1324:	af 90       	pop	r10
    1326:	08 95       	ret

00001328 <set_timers>:
/*---------------------------------------------------------------------------*/
static void send_timer(void *ptr);

static void
set_timers(void)
{
    1328:	cf 93       	push	r28
    132a:	df 93       	push	r29
  ctimer_set(&c.interval_timer, c.current_interval, send_timer, NULL);
    132c:	c9 e4       	ldi	r28, 0x49	; 73
    132e:	d6 e0       	ldi	r29, 0x06	; 6
    1330:	60 91 5f 06 	lds	r22, 0x065F
    1334:	70 91 60 06 	lds	r23, 0x0660
    1338:	ce 01       	movw	r24, r28
    133a:	46 ec       	ldi	r20, 0xC6	; 198
    133c:	59 e0       	ldi	r21, 0x09	; 9
    133e:	20 e0       	ldi	r18, 0x00	; 0
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	0e 94 bb 18 	call	0x3176	; 0x3176 <ctimer_set>
  ctimer_set(&c.send_timer, random_rand() % c.current_interval,
    1346:	0e 94 89 19 	call	0x3312	; 0x3312 <random_rand>
    134a:	60 91 5f 06 	lds	r22, 0x065F
    134e:	70 91 60 06 	lds	r23, 0x0660
    1352:	0e 94 73 25 	call	0x4ae6	; 0x4ae6 <__udivmodhi4>
    1356:	bc 01       	movw	r22, r24
    1358:	ce 01       	movw	r24, r28
    135a:	40 97       	sbiw	r24, 0x10	; 16
    135c:	4b ed       	ldi	r20, 0xDB	; 219
    135e:	59 e0       	ldi	r21, 0x09	; 9
    1360:	20 e0       	ldi	r18, 0x00	; 0
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	0e 94 bb 18 	call	0x3176	; 0x3176 <ctimer_set>
             send_adv, NULL);
}
    1368:	df 91       	pop	r29
    136a:	cf 91       	pop	r28
    136c:	08 95       	ret

0000136e <new_announcement>:
}
/*---------------------------------------------------------------------------*/
static void
new_announcement(uint16_t id, uint8_t has_value,
                 uint16_t newval, uint16_t oldval, uint8_t bump)
{
    136e:	0f 93       	push	r16
  if(bump == ANNOUNCEMENT_BUMP) {
    1370:	01 30       	cpi	r16, 0x01	; 1
    1372:	51 f4       	brne	.+20     	; 0x1388 <new_announcement+0x1a>
    c.current_interval = c.initial_interval;
    1374:	80 91 59 06 	lds	r24, 0x0659
    1378:	90 91 5a 06 	lds	r25, 0x065A
    137c:	90 93 60 06 	sts	0x0660, r25
    1380:	80 93 5f 06 	sts	0x065F, r24
    set_timers();
    1384:	0e 94 94 09 	call	0x1328	; 0x1328 <set_timers>
    /*  } else if(newval != oldval) {
    c.current_interval = c.min_interval;
    set_timers();*/
  }
}
    1388:	0f 91       	pop	r16
    138a:	08 95       	ret

0000138c <send_timer>:
static void
send_timer(void *ptr)
{
  clock_time_t interval;

  interval = c.current_interval * 2;
    138c:	80 91 5f 06 	lds	r24, 0x065F
    1390:	90 91 60 06 	lds	r25, 0x0660

  if(interval > c.max_interval) {
    interval = c.max_interval;
  }

  c.current_interval = interval;
    1394:	20 91 5d 06 	lds	r18, 0x065D
    1398:	30 91 5e 06 	lds	r19, 0x065E
    139c:	88 0f       	add	r24, r24
    139e:	99 1f       	adc	r25, r25
    13a0:	28 17       	cp	r18, r24
    13a2:	39 07       	cpc	r19, r25
    13a4:	08 f4       	brcc	.+2      	; 0x13a8 <send_timer+0x1c>
    13a6:	c9 01       	movw	r24, r18
    13a8:	90 93 60 06 	sts	0x0660, r25
    13ac:	80 93 5f 06 	sts	0x065F, r24

  /*  printf("current_interval %lu\n", (long unsigned int) interval);*/

  set_timers();
    13b0:	0e 94 94 09 	call	0x1328	; 0x1328 <set_timers>
}
    13b4:	08 95       	ret

000013b6 <send_adv>:
#define MIN(a, b) ((a)<(b)?(a):(b))

/*---------------------------------------------------------------------------*/
static void
send_adv(void *ptr)
{
    13b6:	ef 92       	push	r14
    13b8:	ff 92       	push	r15
    13ba:	cf 93       	push	r28
    13bc:	df 93       	push	r29
  struct announcement_msg *adata;
  struct announcement *a;

  packetbuf_clear();
    13be:	0e 94 b8 1a 	call	0x3570	; 0x3570 <packetbuf_clear>
  adata = packetbuf_dataptr();
    13c2:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    13c6:	e8 2e       	mov	r14, r24
    13c8:	e7 01       	movw	r28, r14
    13ca:	7e 01       	movw	r14, r28
    13cc:	f9 2e       	mov	r15, r25
    13ce:	e7 01       	movw	r28, r14
  adata->num = 0;
    13d0:	19 82       	std	Y+1, r1	; 0x01
    13d2:	18 82       	st	Y, r1
  for(a = announcement_list(); a != NULL && a->has_value; a = list_item_next(a)) {
    13d4:	0e 94 1d 09 	call	0x123a	; 0x123a <announcement_list>
    13d8:	26 c0       	rjmp	.+76     	; 0x1426 <send_adv+0x70>
    adata->data[adata->num].id = a->id;
    13da:	28 81       	ld	r18, Y
    13dc:	39 81       	ldd	r19, Y+1	; 0x01
    13de:	f9 01       	movw	r30, r18
    13e0:	ee 0f       	add	r30, r30
    13e2:	ff 1f       	adc	r31, r31
    13e4:	ee 0f       	add	r30, r30
    13e6:	ff 1f       	adc	r31, r31
    13e8:	ec 0f       	add	r30, r28
    13ea:	fd 1f       	adc	r31, r29
    13ec:	dc 01       	movw	r26, r24
    13ee:	12 96       	adiw	r26, 0x02	; 2
    13f0:	4d 91       	ld	r20, X+
    13f2:	5c 91       	ld	r21, X
    13f4:	13 97       	sbiw	r26, 0x03	; 3
    13f6:	53 83       	std	Z+3, r21	; 0x03
    13f8:	42 83       	std	Z+2, r20	; 0x02
    adata->data[adata->num].value = a->value;
    13fa:	2f 5f       	subi	r18, 0xFF	; 255
    13fc:	3f 4f       	sbci	r19, 0xFF	; 255
    13fe:	f9 01       	movw	r30, r18
    1400:	ee 0f       	add	r30, r30
    1402:	ff 1f       	adc	r31, r31
    1404:	ee 0f       	add	r30, r30
    1406:	ff 1f       	adc	r31, r31
    1408:	ec 0f       	add	r30, r28
    140a:	fd 1f       	adc	r31, r29
    140c:	14 96       	adiw	r26, 0x04	; 4
    140e:	4d 91       	ld	r20, X+
    1410:	5c 91       	ld	r21, X
    1412:	15 97       	sbiw	r26, 0x05	; 5
    1414:	51 83       	std	Z+1, r21	; 0x01
    1416:	40 83       	st	Z, r20
    adata->num++;
    1418:	39 83       	std	Y+1, r19	; 0x01
    141a:	28 83       	st	Y, r18
  struct announcement *a;

  packetbuf_clear();
  adata = packetbuf_dataptr();
  adata->num = 0;
  for(a = announcement_list(); a != NULL && a->has_value; a = list_item_next(a)) {
    141c:	0e 94 31 18 	call	0x3062	; 0x3062 <list_item_next>
    1420:	28 2f       	mov	r18, r24
    1422:	39 2f       	mov	r19, r25
    1424:	c9 01       	movw	r24, r18
    1426:	00 97       	sbiw	r24, 0x00	; 0
    1428:	21 f0       	breq	.+8      	; 0x1432 <send_adv+0x7c>
    142a:	fc 01       	movw	r30, r24
    142c:	20 85       	ldd	r18, Z+8	; 0x08
    142e:	22 23       	and	r18, r18
    1430:	a1 f6       	brne	.-88     	; 0x13da <send_adv+0x24>
    adata->data[adata->num].value = a->value;
    adata->num++;
  }

  packetbuf_set_datalen(ANNOUNCEMENT_MSG_HEADERLEN +
		      sizeof(struct announcement_data) * adata->num);
    1432:	88 81       	ld	r24, Y
    1434:	99 81       	ldd	r25, Y+1	; 0x01
    1436:	88 0f       	add	r24, r24
    1438:	99 1f       	adc	r25, r25
    143a:	88 0f       	add	r24, r24
    143c:	99 1f       	adc	r25, r25
    adata->data[adata->num].id = a->id;
    adata->data[adata->num].value = a->value;
    adata->num++;
  }

  packetbuf_set_datalen(ANNOUNCEMENT_MSG_HEADERLEN +
    143e:	02 96       	adiw	r24, 0x02	; 2
    1440:	0e 94 10 1a 	call	0x3420	; 0x3420 <packetbuf_set_datalen>
		      sizeof(struct announcement_data) * adata->num);

  PRINTF("%d.%d: sending neighbor advertisement with %d announcements\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1], adata->num);

  if(adata->num > 0) {
    1444:	88 81       	ld	r24, Y
    1446:	99 81       	ldd	r25, Y+1	; 0x01
    1448:	00 97       	sbiw	r24, 0x00	; 0
    144a:	21 f0       	breq	.+8      	; 0x1454 <send_adv+0x9e>
    /* Send the packet only if it contains more than zero announcements. */
    broadcast_send(&c.c);
    144c:	8e e2       	ldi	r24, 0x2E	; 46
    144e:	96 e0       	ldi	r25, 0x06	; 6
    1450:	0e 94 bf 0a 	call	0x157e	; 0x157e <broadcast_send>
  }
  PRINTF("%d.%d: sending neighbor advertisement with val %d\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	 c.val);
}
    1454:	df 91       	pop	r29
    1456:	cf 91       	pop	r28
    1458:	ff 90       	pop	r15
    145a:	ef 90       	pop	r14
    145c:	08 95       	ret

0000145e <broadcast_announcement_init>:
void
broadcast_announcement_init(uint16_t channel,
                            clock_time_t initial,
                            clock_time_t min,
                            clock_time_t max)
{
    145e:	ef 92       	push	r14
    1460:	ff 92       	push	r15
    1462:	0f 93       	push	r16
    1464:	1f 93       	push	r17
    1466:	cf 93       	push	r28
    1468:	df 93       	push	r29
    146a:	fc 01       	movw	r30, r24
    146c:	8b 01       	movw	r16, r22
    146e:	7a 01       	movw	r14, r20
    1470:	e9 01       	movw	r28, r18
  broadcast_open(&c.c, channel, &broadcast_callbacks);
    1472:	8e e2       	ldi	r24, 0x2E	; 46
    1474:	96 e0       	ldi	r25, 0x06	; 6
    1476:	bf 01       	movw	r22, r30
    1478:	44 e9       	ldi	r20, 0x94	; 148
    147a:	53 e0       	ldi	r21, 0x03	; 3
    147c:	0e 94 a1 0a 	call	0x1542	; 0x1542 <broadcast_open>
  c.initial_interval = initial;
    1480:	10 93 5a 06 	sts	0x065A, r17
    1484:	00 93 59 06 	sts	0x0659, r16
  c.min_interval = min;
    1488:	f0 92 5c 06 	sts	0x065C, r15
    148c:	e0 92 5b 06 	sts	0x065B, r14
  c.max_interval = max;
    1490:	d0 93 5e 06 	sts	0x065E, r29
    1494:	c0 93 5d 06 	sts	0x065D, r28

  announcement_register_observer_callback(new_announcement);
    1498:	87 eb       	ldi	r24, 0xB7	; 183
    149a:	99 e0       	ldi	r25, 0x09	; 9
    149c:	0e 94 18 09 	call	0x1230	; 0x1230 <announcement_register_observer_callback>
}
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	1f 91       	pop	r17
    14a6:	0f 91       	pop	r16
    14a8:	ff 90       	pop	r15
    14aa:	ef 90       	pop	r14
    14ac:	08 95       	ret

000014ae <broadcast_announcement_stop>:
/*---------------------------------------------------------------------------*/
void
broadcast_announcement_stop(void)
{
    14ae:	cf 93       	push	r28
    14b0:	df 93       	push	r29
  ctimer_stop(&c.interval_timer);
    14b2:	c9 e4       	ldi	r28, 0x49	; 73
    14b4:	d6 e0       	ldi	r29, 0x06	; 6
    14b6:	ce 01       	movw	r24, r28
    14b8:	0e 94 42 19 	call	0x3284	; 0x3284 <ctimer_stop>
  ctimer_stop(&c.send_timer);
    14bc:	ce 01       	movw	r24, r28
    14be:	40 97       	sbiw	r24, 0x10	; 16
    14c0:	0e 94 42 19 	call	0x3284	; 0x3284 <ctimer_stop>
  broadcast_close(&c.c);
    14c4:	ce 01       	movw	r24, r28
    14c6:	4b 97       	sbiw	r24, 0x1b	; 27
    14c8:	0e 94 bc 0a 	call	0x1578	; 0x1578 <broadcast_close>
}
    14cc:	df 91       	pop	r29
    14ce:	cf 91       	pop	r28
    14d0:	08 95       	ret

000014d2 <broadcast_announcement_beacon_interval>:
/*---------------------------------------------------------------------------*/
clock_time_t
broadcast_announcement_beacon_interval(void)
{
  return c.current_interval;
}
    14d2:	80 91 5f 06 	lds	r24, 0x065F
    14d6:	90 91 60 06 	lds	r25, 0x0660
    14da:	08 95       	ret

000014dc <sent_by_abc>:
}
/*---------------------------------------------------------------------------*/
static void
sent_by_abc(struct abc_conn *bc, int status, int num_tx)
{
  struct broadcast_conn *c = (struct broadcast_conn *)bc;
    14dc:	dc 01       	movw	r26, r24
  PRINTF("%d.%d: sent to %d.%d status %d num_tx %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 packetbuf_addr(PACKETBUF_ADDR_SENDER)->u8[0],
         packetbuf_addr(PACKETBUF_ADDR_SENDER)->u8[1],
         status, num_tx);
  if(c->u->sent) {
    14de:	19 96       	adiw	r26, 0x09	; 9
    14e0:	ed 91       	ld	r30, X+
    14e2:	fc 91       	ld	r31, X
    14e4:	1a 97       	sbiw	r26, 0x0a	; 10
    14e6:	02 80       	ldd	r0, Z+2	; 0x02
    14e8:	f3 81       	ldd	r31, Z+3	; 0x03
    14ea:	e0 2d       	mov	r30, r0
    14ec:	30 97       	sbiw	r30, 0x00	; 0
    14ee:	09 f0       	breq	.+2      	; 0x14f2 <sent_by_abc+0x16>
    c->u->sent(c, status, num_tx);
    14f0:	09 95       	icall
    14f2:	08 95       	ret

000014f4 <recv_from_abc>:
#endif

/*---------------------------------------------------------------------------*/
static void
recv_from_abc(struct abc_conn *bc)
{
    14f4:	ef 92       	push	r14
    14f6:	ff 92       	push	r15
    14f8:	0f 93       	push	r16
    14fa:	1f 93       	push	r17
    14fc:	df 93       	push	r29
    14fe:	cf 93       	push	r28
    1500:	00 d0       	rcall	.+0      	; 0x1502 <recv_from_abc+0xe>
    1502:	cd b7       	in	r28, 0x3d	; 61
    1504:	de b7       	in	r29, 0x3e	; 62
  rimeaddr_t sender;
  struct broadcast_conn *c = (struct broadcast_conn *)bc;
    1506:	8c 01       	movw	r16, r24

  rimeaddr_copy(&sender, packetbuf_addr(PACKETBUF_ADDR_SENDER));
    1508:	7e 01       	movw	r14, r28
    150a:	08 94       	sec
    150c:	e1 1c       	adc	r14, r1
    150e:	f1 1c       	adc	r15, r1
    1510:	c7 01       	movw	r24, r14
    1512:	6b e6       	ldi	r22, 0x6B	; 107
    1514:	7e e0       	ldi	r23, 0x0E	; 14
    1516:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
  
  PRINTF("%d.%d: broadcast: from %d.%d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 sender.u8[0], sender.u8[1]);
  c->u->recv(c, &sender);
    151a:	d8 01       	movw	r26, r16
    151c:	19 96       	adiw	r26, 0x09	; 9
    151e:	ed 91       	ld	r30, X+
    1520:	fc 91       	ld	r31, X
    1522:	1a 97       	sbiw	r26, 0x0a	; 10
    1524:	01 90       	ld	r0, Z+
    1526:	f0 81       	ld	r31, Z
    1528:	e0 2d       	mov	r30, r0
    152a:	c8 01       	movw	r24, r16
    152c:	b7 01       	movw	r22, r14
    152e:	09 95       	icall
}
    1530:	0f 90       	pop	r0
    1532:	0f 90       	pop	r0
    1534:	cf 91       	pop	r28
    1536:	df 91       	pop	r29
    1538:	1f 91       	pop	r17
    153a:	0f 91       	pop	r16
    153c:	ff 90       	pop	r15
    153e:	ef 90       	pop	r14
    1540:	08 95       	ret

00001542 <broadcast_open>:
static const struct abc_callbacks broadcast = {recv_from_abc, sent_by_abc};
/*---------------------------------------------------------------------------*/
void
broadcast_open(struct broadcast_conn *c, uint16_t channel,
	  const struct broadcast_callbacks *u)
{
    1542:	ef 92       	push	r14
    1544:	ff 92       	push	r15
    1546:	0f 93       	push	r16
    1548:	1f 93       	push	r17
    154a:	cf 93       	push	r28
    154c:	df 93       	push	r29
    154e:	ec 01       	movw	r28, r24
    1550:	8b 01       	movw	r16, r22
    1552:	7a 01       	movw	r14, r20
  abc_open(&c->c, channel, &broadcast);
    1554:	48 e9       	ldi	r20, 0x98	; 152
    1556:	53 e0       	ldi	r21, 0x03	; 3
    1558:	0e 94 ce 0a 	call	0x159c	; 0x159c <abc_open>
  c->u = u;
    155c:	fa 86       	std	Y+10, r15	; 0x0a
    155e:	e9 86       	std	Y+9, r14	; 0x09
  channel_set_attributes(channel, attributes);
    1560:	c8 01       	movw	r24, r16
    1562:	6c e9       	ldi	r22, 0x9C	; 156
    1564:	73 e0       	ldi	r23, 0x03	; 3
    1566:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <channel_set_attributes>
}
    156a:	df 91       	pop	r29
    156c:	cf 91       	pop	r28
    156e:	1f 91       	pop	r17
    1570:	0f 91       	pop	r16
    1572:	ff 90       	pop	r15
    1574:	ef 90       	pop	r14
    1576:	08 95       	ret

00001578 <broadcast_close>:
/*---------------------------------------------------------------------------*/
void
broadcast_close(struct broadcast_conn *c)
{
  abc_close(&c->c);
    1578:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <abc_close>
}
    157c:	08 95       	ret

0000157e <broadcast_send>:
/*---------------------------------------------------------------------------*/
int
broadcast_send(struct broadcast_conn *c)
{
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	ec 01       	movw	r28, r24

static inline int
packetbuf_set_addr(uint8_t type, const rimeaddr_t *addr)
{
/*   packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].type = type; */
  rimeaddr_copy(&packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].addr, addr);
    1584:	8b e6       	ldi	r24, 0x6B	; 107
    1586:	9e e0       	ldi	r25, 0x0E	; 14
    1588:	68 e1       	ldi	r22, 0x18	; 24
    158a:	7e e0       	ldi	r23, 0x0E	; 14
    158c:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
  PRINTF("%d.%d: broadcast_send\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
  packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &rimeaddr_node_addr);
  return abc_send(&c->c);
    1590:	ce 01       	movw	r24, r28
    1592:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <abc_send>
}
    1596:	df 91       	pop	r29
    1598:	cf 91       	pop	r28
    159a:	08 95       	ret

0000159c <abc_open>:

/*---------------------------------------------------------------------------*/
void
abc_open(struct abc_conn *c, uint16_t channelno,
	  const struct abc_callbacks *callbacks)
{
    159c:	ef 92       	push	r14
    159e:	ff 92       	push	r15
    15a0:	0f 93       	push	r16
    15a2:	1f 93       	push	r17
    15a4:	cf 93       	push	r28
    15a6:	df 93       	push	r29
    15a8:	ec 01       	movw	r28, r24
    15aa:	8b 01       	movw	r16, r22
    15ac:	7a 01       	movw	r14, r20
  channel_open(&c->channel, channelno);
    15ae:	0e 94 37 0b 	call	0x166e	; 0x166e <channel_open>
  c->u = callbacks;
    15b2:	f8 86       	std	Y+8, r15	; 0x08
    15b4:	ef 82       	std	Y+7, r14	; 0x07
  channel_set_attributes(channelno, attributes);
    15b6:	c8 01       	movw	r24, r16
    15b8:	60 ea       	ldi	r22, 0xA0	; 160
    15ba:	73 e0       	ldi	r23, 0x03	; 3
    15bc:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <channel_set_attributes>
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	1f 91       	pop	r17
    15c6:	0f 91       	pop	r16
    15c8:	ff 90       	pop	r15
    15ca:	ef 90       	pop	r14
    15cc:	08 95       	ret

000015ce <abc_close>:
/*---------------------------------------------------------------------------*/
void
abc_close(struct abc_conn *c)
{
  channel_close(&c->channel);
    15ce:	0e 94 40 0b 	call	0x1680	; 0x1680 <channel_close>
}
    15d2:	08 95       	ret

000015d4 <abc_send>:
abc_send(struct abc_conn *c)
{
  PRINTF("%d.%d: abc: abc_send on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 c->channel.channelno);
  return rime_output(&c->channel);
    15d4:	0e 94 64 08 	call	0x10c8	; 0x10c8 <rime_output>
}
    15d8:	08 95       	ret

000015da <abc_input>:
/*---------------------------------------------------------------------------*/
void
abc_input(struct channel *channel)
{
  struct abc_conn *c = (struct abc_conn *)channel;
    15da:	fc 01       	movw	r30, r24
  PRINTF("%d.%d: abc: abc_input_packet on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 channel->channelno);

  c->u->recv(c);
    15dc:	a7 81       	ldd	r26, Z+7	; 0x07
    15de:	b0 85       	ldd	r27, Z+8	; 0x08
    15e0:	2d 91       	ld	r18, X+
    15e2:	3c 91       	ld	r19, X
    15e4:	f9 01       	movw	r30, r18
    15e6:	09 95       	icall
}
    15e8:	08 95       	ret

000015ea <abc_sent>:
/*---------------------------------------------------------------------------*/
void
abc_sent(struct channel *channel, int status, int num_tx)
{
  struct abc_conn *c = (struct abc_conn *)channel;
    15ea:	dc 01       	movw	r26, r24
  PRINTF("%d.%d: abc: abc_sent on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 channel->channelno);

  if(c->u->sent) {
    15ec:	17 96       	adiw	r26, 0x07	; 7
    15ee:	ed 91       	ld	r30, X+
    15f0:	fc 91       	ld	r31, X
    15f2:	18 97       	sbiw	r26, 0x08	; 8
    15f4:	02 80       	ldd	r0, Z+2	; 0x02
    15f6:	f3 81       	ldd	r31, Z+3	; 0x03
    15f8:	e0 2d       	mov	r30, r0
    15fa:	30 97       	sbiw	r30, 0x00	; 0
    15fc:	09 f0       	breq	.+2      	; 0x1600 <abc_sent+0x16>
    c->u->sent(c, status, num_tx);
    15fe:	09 95       	icall
    1600:	08 95       	ret

00001602 <chameleon_init>:

/*---------------------------------------------------------------------------*/
void
chameleon_init(void)
{
  channel_init();
    1602:	0e 94 32 0b 	call	0x1664	; 0x1664 <channel_init>
}
    1606:	08 95       	ret

00001608 <chameleon_parse>:
  PRINTF("%d.%d: chameleon_input\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
#if DEBUG
  printhdr(packetbuf_dataptr(), packetbuf_datalen());
#endif /* DEBUG */
  c = CHAMELEON_MODULE.input();
    1608:	e0 91 a2 03 	lds	r30, 0x03A2
    160c:	f0 91 a3 03 	lds	r31, 0x03A3
    1610:	09 95       	icall
    1612:	fc 01       	movw	r30, r24
  if(c != NULL) {
    1614:	00 97       	sbiw	r24, 0x00	; 0
    1616:	31 f0       	breq	.+12     	; 0x1624 <chameleon_parse+0x1c>

static inline int
packetbuf_set_attr(uint8_t type, const packetbuf_attr_t val)
{
/*   packetbuf_attrs[type].type = type; */
  packetbuf_attrs[type].val = val;
    1618:	82 81       	ldd	r24, Z+2	; 0x02
    161a:	93 81       	ldd	r25, Z+3	; 0x03
    161c:	90 93 76 0e 	sts	0x0E76, r25
    1620:	80 93 75 0e 	sts	0x0E75, r24
  } else {
    PRINTF("%d.%d: chameleon_input channel not found for incoming packet\n",
           rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
  }
  return c;
}
    1624:	cf 01       	movw	r24, r30
    1626:	08 95       	ret

00001628 <chameleon_create>:
/*---------------------------------------------------------------------------*/
int
chameleon_create(struct channel *c)
{
    1628:	cf 93       	push	r28
    162a:	df 93       	push	r29
    162c:	ec 01       	movw	r28, r24

  PRINTF("%d.%d: chameleon_output channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 c->channelno);

  ret = CHAMELEON_MODULE.output(c);
    162e:	e0 91 a4 03 	lds	r30, 0x03A4
    1632:	f0 91 a5 03 	lds	r31, 0x03A5
    1636:	09 95       	icall
    1638:	2a 81       	ldd	r18, Y+2	; 0x02
    163a:	3b 81       	ldd	r19, Y+3	; 0x03
    163c:	30 93 76 0e 	sts	0x0E76, r19
    1640:	20 93 75 0e 	sts	0x0E75, r18
  packetbuf_set_attr(PACKETBUF_ATTR_CHANNEL, c->channelno);
#if DEBUG
  printhdr(packetbuf_hdrptr(), packetbuf_hdrlen());
#endif /* DEBUG */
  if(ret) {
    return 1;
    1644:	21 e0       	ldi	r18, 0x01	; 1
    1646:	30 e0       	ldi	r19, 0x00	; 0
    1648:	00 97       	sbiw	r24, 0x00	; 0
    164a:	11 f4       	brne	.+4      	; 0x1650 <chameleon_create+0x28>
    164c:	20 e0       	ldi	r18, 0x00	; 0
    164e:	30 e0       	ldi	r19, 0x00	; 0
  }
  return 0;
}
    1650:	c9 01       	movw	r24, r18
    1652:	df 91       	pop	r29
    1654:	cf 91       	pop	r28
    1656:	08 95       	ret

00001658 <chameleon_hdrsize>:
/*---------------------------------------------------------------------------*/
int
chameleon_hdrsize(const struct packetbuf_attrlist attrlist[])
{
  return CHAMELEON_MODULE.hdrsize(attrlist);
    1658:	e0 91 a6 03 	lds	r30, 0x03A6
    165c:	f0 91 a7 03 	lds	r31, 0x03A7
    1660:	09 95       	icall
}
    1662:	08 95       	ret

00001664 <channel_init>:

/*---------------------------------------------------------------------------*/
void
channel_init(void)
{
  list_init(channel_list);
    1664:	83 e6       	ldi	r24, 0x63	; 99
    1666:	96 e0       	ldi	r25, 0x06	; 6
    1668:	0e 94 67 17 	call	0x2ece	; 0x2ece <list_init>
}
    166c:	08 95       	ret

0000166e <channel_open>:
  }
}
/*---------------------------------------------------------------------------*/
void
channel_open(struct channel *c, uint16_t channelno)
{
    166e:	fc 01       	movw	r30, r24
  c->channelno = channelno;
    1670:	73 83       	std	Z+3, r23	; 0x03
    1672:	62 83       	std	Z+2, r22	; 0x02
  list_add(channel_list, c);
    1674:	83 e6       	ldi	r24, 0x63	; 99
    1676:	96 e0       	ldi	r25, 0x06	; 6
    1678:	bf 01       	movw	r22, r30
    167a:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <list_add>
}
    167e:	08 95       	ret

00001680 <channel_close>:
/*---------------------------------------------------------------------------*/
void
channel_close(struct channel *c)
{
    1680:	bc 01       	movw	r22, r24
  list_remove(channel_list, c);
    1682:	83 e6       	ldi	r24, 0x63	; 99
    1684:	96 e0       	ldi	r25, 0x06	; 6
    1686:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>
}
    168a:	08 95       	ret

0000168c <channel_lookup>:
/*---------------------------------------------------------------------------*/
struct channel *
channel_lookup(uint16_t channelno)
{
    168c:	cf 93       	push	r28
    168e:	df 93       	push	r29
    1690:	ec 01       	movw	r28, r24
  struct channel *c;
  for(c = list_head(channel_list); c != NULL; c = list_item_next(c)) {
    1692:	83 e6       	ldi	r24, 0x63	; 99
    1694:	96 e0       	ldi	r25, 0x06	; 6
    1696:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
    169a:	08 c0       	rjmp	.+16     	; 0x16ac <channel_lookup+0x20>
    if(c->channelno == channelno) {
    169c:	82 81       	ldd	r24, Z+2	; 0x02
    169e:	93 81       	ldd	r25, Z+3	; 0x03
    16a0:	8c 17       	cp	r24, r28
    16a2:	9d 07       	cpc	r25, r29
    16a4:	39 f0       	breq	.+14     	; 0x16b4 <channel_lookup+0x28>
/*---------------------------------------------------------------------------*/
struct channel *
channel_lookup(uint16_t channelno)
{
  struct channel *c;
  for(c = list_head(channel_list); c != NULL; c = list_item_next(c)) {
    16a6:	cf 01       	movw	r24, r30
    16a8:	0e 94 31 18 	call	0x3062	; 0x3062 <list_item_next>
    16ac:	e8 2f       	mov	r30, r24
    16ae:	f9 2f       	mov	r31, r25
    16b0:	30 97       	sbiw	r30, 0x00	; 0
    16b2:	a1 f7       	brne	.-24     	; 0x169c <channel_lookup+0x10>
    if(c->channelno == channelno) {
      return c;
    }
  }
  return NULL;
}
    16b4:	cf 01       	movw	r24, r30
    16b6:	df 91       	pop	r29
    16b8:	cf 91       	pop	r28
    16ba:	08 95       	ret

000016bc <channel_set_attributes>:
}
/*---------------------------------------------------------------------------*/
void
channel_set_attributes(uint16_t channelno,
		       const struct packetbuf_attrlist attrlist[])
{
    16bc:	0f 93       	push	r16
    16be:	1f 93       	push	r17
    16c0:	cf 93       	push	r28
    16c2:	df 93       	push	r29
    16c4:	8b 01       	movw	r16, r22
  struct channel *c;
  c = channel_lookup(channelno);
    16c6:	0e 94 46 0b 	call	0x168c	; 0x168c <channel_lookup>
    16ca:	ec 01       	movw	r28, r24
  if(c != NULL) {
    16cc:	00 97       	sbiw	r24, 0x00	; 0
    16ce:	31 f0       	breq	.+12     	; 0x16dc <channel_set_attributes+0x20>
    c->attrlist = attrlist;
    16d0:	1d 83       	std	Y+5, r17	; 0x05
    16d2:	0c 83       	std	Y+4, r16	; 0x04
    c->hdrsize = chameleon_hdrsize(attrlist);
    16d4:	c8 01       	movw	r24, r16
    16d6:	0e 94 2c 0b 	call	0x1658	; 0x1658 <chameleon_hdrsize>
    16da:	8e 83       	std	Y+6, r24	; 0x06
  }
}
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	1f 91       	pop	r17
    16e2:	0f 91       	pop	r16
    16e4:	08 95       	ret

000016e6 <header_size>:
  }
}
/*---------------------------------------------------------------------------*/
static int
header_size(const struct packetbuf_attrlist *a)
{
    16e6:	fc 01       	movw	r30, r24
  int size, len;
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */
  
  size = 0;
    16e8:	20 e0       	ldi	r18, 0x00	; 0
    16ea:	30 e0       	ldi	r19, 0x00	; 0
  for(; a->type != PACKETBUF_ATTR_NONE; ++a) {
    16ec:	04 c0       	rjmp	.+8      	; 0x16f6 <header_size+0x10>
      continue;
    }
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    /*    PRINTF("chameleon header_size: header type %d len %d\n",
	   a->type, a->len);*/
    len = a->len;
    16ee:	81 81       	ldd	r24, Z+1	; 0x01
    /*    if(len < 8) {
      len = 8;
      }*/
    size += len;
    16f0:	28 0f       	add	r18, r24
    16f2:	31 1d       	adc	r19, r1
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */
  
  size = 0;
  for(; a->type != PACKETBUF_ATTR_NONE; ++a) {
    16f4:	32 96       	adiw	r30, 0x02	; 2
    16f6:	80 81       	ld	r24, Z
    16f8:	88 23       	and	r24, r24
    16fa:	c9 f7       	brne	.-14     	; 0x16ee <header_size+0x8>
      len = 8;
      }*/
    size += len;
  }
  return size;
}
    16fc:	c9 01       	movw	r24, r18
    16fe:	08 95       	ret

00001700 <get_bits_in_byte>:
#endif

/*---------------------------------------------------------------------------*/
uint8_t CC_INLINE
get_bits_in_byte(uint8_t *from, int bitpos, int vallen)
{
    1700:	fc 01       	movw	r30, r24
  uint16_t shifted_val;

  shifted_val = (from[0] << 8) | from[1];
    1702:	81 81       	ldd	r24, Z+1	; 0x01
    1704:	90 e0       	ldi	r25, 0x00	; 0
    1706:	30 81       	ld	r19, Z
    1708:	20 e0       	ldi	r18, 0x00	; 0
    170a:	82 2b       	or	r24, r18
    170c:	93 2b       	or	r25, r19
	from[0], from[1], shifted_val,
	(((shifted_val << bitpos) >> 8) & bitmask[vallen]) >> (8 - vallen),
	vallen
	);*/
  
  return (((shifted_val << bitpos) >> 8) & bitmask[vallen]) >> (8 - vallen);
    170e:	02 c0       	rjmp	.+4      	; 0x1714 <get_bits_in_byte+0x14>
    1710:	88 0f       	add	r24, r24
    1712:	99 1f       	adc	r25, r25
    1714:	6a 95       	dec	r22
    1716:	e2 f7       	brpl	.-8      	; 0x1710 <get_bits_in_byte+0x10>
    1718:	89 2f       	mov	r24, r25
    171a:	99 27       	eor	r25, r25
    171c:	fa 01       	movw	r30, r20
    171e:	e8 55       	subi	r30, 0x58	; 88
    1720:	fc 4f       	sbci	r31, 0xFC	; 252
    1722:	20 81       	ld	r18, Z
    1724:	30 e0       	ldi	r19, 0x00	; 0
    1726:	82 23       	and	r24, r18
    1728:	93 23       	and	r25, r19
    172a:	28 e0       	ldi	r18, 0x08	; 8
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	24 1b       	sub	r18, r20
    1730:	35 0b       	sbc	r19, r21
    1732:	02 c0       	rjmp	.+4      	; 0x1738 <get_bits_in_byte+0x38>
    1734:	96 95       	lsr	r25
    1736:	87 95       	ror	r24
    1738:	2a 95       	dec	r18
    173a:	e2 f7       	brpl	.-8      	; 0x1734 <get_bits_in_byte+0x34>
}
    173c:	08 95       	ret

0000173e <get_bits>:
/*---------------------------------------------------------------------------*/
void
get_bits(uint8_t *to, uint8_t *from, int bitpos, int vallen)
{
    173e:	6f 92       	push	r6
    1740:	7f 92       	push	r7
    1742:	8f 92       	push	r8
    1744:	9f 92       	push	r9
    1746:	af 92       	push	r10
    1748:	bf 92       	push	r11
    174a:	cf 92       	push	r12
    174c:	df 92       	push	r13
    174e:	ef 92       	push	r14
    1750:	ff 92       	push	r15
    1752:	0f 93       	push	r16
    1754:	1f 93       	push	r17
    1756:	cf 93       	push	r28
    1758:	df 93       	push	r29
    175a:	6c 01       	movw	r12, r24
    175c:	7b 01       	movw	r14, r22
    175e:	5a 01       	movw	r10, r20
    1760:	89 01       	movw	r16, r18
  int i, bits;
  
  
  if(vallen < 8) {
    1762:	28 30       	cpi	r18, 0x08	; 8
    1764:	31 05       	cpc	r19, r1
    1766:	44 f4       	brge	.+16     	; 0x1778 <get_bits+0x3a>
    *to = get_bits_in_byte(from, bitpos, vallen);
    1768:	cb 01       	movw	r24, r22
    176a:	ba 01       	movw	r22, r20
    176c:	a9 01       	movw	r20, r18
    176e:	0e 94 80 0b 	call	0x1700	; 0x1700 <get_bits_in_byte>
    1772:	f6 01       	movw	r30, r12
    1774:	80 83       	st	Z, r24
    1776:	41 c0       	rjmp	.+130    	; 0x17fa <get_bits+0xbc>
    1778:	39 01       	movw	r6, r18
    177a:	33 e0       	ldi	r19, 0x03	; 3
    177c:	75 94       	asr	r7
    177e:	67 94       	ror	r6
    1780:	3a 95       	dec	r19
    1782:	e1 f7       	brne	.-8      	; 0x177c <get_bits+0x3e>
  } else {
    if(bitpos == 0) {
    1784:	41 15       	cp	r20, r1
    1786:	51 05       	cpc	r21, r1
    1788:	21 f0       	breq	.+8      	; 0x1792 <get_bits+0x54>
      bits = vallen & 7;
      if(bits) {
	to[i] = get_bits_in_byte(&from[i], 0, bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    178a:	4c 01       	movw	r8, r24
    178c:	c0 e0       	ldi	r28, 0x00	; 0
    178e:	d0 e0       	ldi	r29, 0x00	; 0
    1790:	16 c0       	rjmp	.+44     	; 0x17be <get_bits+0x80>
  
  if(vallen < 8) {
    *to = get_bits_in_byte(from, bitpos, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    1792:	db 01       	movw	r26, r22
    1794:	fc 01       	movw	r30, r24
    1796:	c0 e0       	ldi	r28, 0x00	; 0
    1798:	d0 e0       	ldi	r29, 0x00	; 0
	/*	PRINTF("get_bits i %d val 0x%02x\n",
		i, from[i]);*/
	to[i] = from[i];
    179a:	8d 91       	ld	r24, X+
    179c:	81 93       	st	Z+, r24
  
  if(vallen < 8) {
    *to = get_bits_in_byte(from, bitpos, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    179e:	21 96       	adiw	r28, 0x01	; 1
    17a0:	c6 15       	cp	r28, r6
    17a2:	d7 05       	cpc	r29, r7
    17a4:	d4 f3       	brlt	.-12     	; 0x179a <get_bits+0x5c>
	/*	PRINTF("get_bits i %d val 0x%02x\n",
		i, from[i]);*/
	to[i] = from[i];
      }
      bits = vallen & 7;
    17a6:	a8 01       	movw	r20, r16
    17a8:	47 70       	andi	r20, 0x07	; 7
    17aa:	50 70       	andi	r21, 0x00	; 0
      if(bits) {
    17ac:	41 15       	cp	r20, r1
    17ae:	51 05       	cpc	r21, r1
    17b0:	21 f1       	breq	.+72     	; 0x17fa <get_bits+0xbc>
	to[i] = get_bits_in_byte(&from[i], 0, bits);
    17b2:	c7 01       	movw	r24, r14
    17b4:	8c 0f       	add	r24, r28
    17b6:	9d 1f       	adc	r25, r29
    17b8:	60 e0       	ldi	r22, 0x00	; 0
    17ba:	70 e0       	ldi	r23, 0x00	; 0
    17bc:	19 c0       	rjmp	.+50     	; 0x17f0 <get_bits+0xb2>
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
	/*	PRINTF("get_bits i %d val 0x%02x bitpos %d\n",
		i, from[i], bitpos);*/
	to[i] = get_bits_in_byte(&from[i], bitpos, 8);
    17be:	c7 01       	movw	r24, r14
    17c0:	8c 0f       	add	r24, r28
    17c2:	9d 1f       	adc	r25, r29
    17c4:	b5 01       	movw	r22, r10
    17c6:	48 e0       	ldi	r20, 0x08	; 8
    17c8:	50 e0       	ldi	r21, 0x00	; 0
    17ca:	0e 94 80 0b 	call	0x1700	; 0x1700 <get_bits_in_byte>
    17ce:	f4 01       	movw	r30, r8
    17d0:	81 93       	st	Z+, r24
    17d2:	4f 01       	movw	r8, r30
      bits = vallen & 7;
      if(bits) {
	to[i] = get_bits_in_byte(&from[i], 0, bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    17d4:	21 96       	adiw	r28, 0x01	; 1
    17d6:	c6 15       	cp	r28, r6
    17d8:	d7 05       	cpc	r29, r7
    17da:	8c f3       	brlt	.-30     	; 0x17be <get_bits+0x80>
	/*	PRINTF("get_bits i %d val 0x%02x bitpos %d\n",
		i, from[i], bitpos);*/
	to[i] = get_bits_in_byte(&from[i], bitpos, 8);
      }
      bits = vallen & 7;
    17dc:	a8 01       	movw	r20, r16
    17de:	47 70       	andi	r20, 0x07	; 7
    17e0:	50 70       	andi	r21, 0x00	; 0
      if(bits) {
    17e2:	41 15       	cp	r20, r1
    17e4:	51 05       	cpc	r21, r1
    17e6:	49 f0       	breq	.+18     	; 0x17fa <get_bits+0xbc>
	to[i] = get_bits_in_byte(&from[i], bitpos, bits);
    17e8:	c7 01       	movw	r24, r14
    17ea:	8c 0f       	add	r24, r28
    17ec:	9d 1f       	adc	r25, r29
    17ee:	b5 01       	movw	r22, r10
    17f0:	0e 94 80 0b 	call	0x1700	; 0x1700 <get_bits_in_byte>
    17f4:	cc 0d       	add	r28, r12
    17f6:	dd 1d       	adc	r29, r13
    17f8:	88 83       	st	Y, r24
      }
    }
  }
}
    17fa:	df 91       	pop	r29
    17fc:	cf 91       	pop	r28
    17fe:	1f 91       	pop	r17
    1800:	0f 91       	pop	r16
    1802:	ff 90       	pop	r15
    1804:	ef 90       	pop	r14
    1806:	df 90       	pop	r13
    1808:	cf 90       	pop	r12
    180a:	bf 90       	pop	r11
    180c:	af 90       	pop	r10
    180e:	9f 90       	pop	r9
    1810:	8f 90       	pop	r8
    1812:	7f 90       	pop	r7
    1814:	6f 90       	pop	r6
    1816:	08 95       	ret

00001818 <unpack_header>:
  return 1; /* Send out packet */
}
/*---------------------------------------------------------------------------*/
static struct channel *
unpack_header(void)
{
    1818:	4f 92       	push	r4
    181a:	5f 92       	push	r5
    181c:	6f 92       	push	r6
    181e:	7f 92       	push	r7
    1820:	8f 92       	push	r8
    1822:	9f 92       	push	r9
    1824:	af 92       	push	r10
    1826:	bf 92       	push	r11
    1828:	cf 92       	push	r12
    182a:	df 92       	push	r13
    182c:	ef 92       	push	r14
    182e:	ff 92       	push	r15
    1830:	0f 93       	push	r16
    1832:	1f 93       	push	r17
    1834:	df 93       	push	r29
    1836:	cf 93       	push	r28
    1838:	00 d0       	rcall	.+0      	; 0x183a <unpack_header+0x22>
    183a:	00 d0       	rcall	.+0      	; 0x183c <unpack_header+0x24>
    183c:	cd b7       	in	r28, 0x3d	; 61
    183e:	de b7       	in	r29, 0x3e	; 62
  struct channel *c;
  

  /* The packet has a header that tells us what channel the packet is
     for. */
  hdr = (struct bitopt_hdr *)packetbuf_dataptr();
    1840:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    1844:	e8 2e       	mov	r14, r24
    1846:	09 2f       	mov	r16, r25
  if(packetbuf_hdrreduce(sizeof(struct bitopt_hdr)) == 0) {
    1848:	82 e0       	ldi	r24, 0x02	; 2
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	0e 94 f1 19 	call	0x33e2	; 0x33e2 <packetbuf_hdrreduce>
    1850:	00 97       	sbiw	r24, 0x00	; 0
    1852:	09 f4       	brne	.+2      	; 0x1856 <unpack_header+0x3e>
    1854:	73 c0       	rjmp	.+230    	; 0x193c <unpack_header+0x124>
  struct channel *c;
  

  /* The packet has a header that tells us what channel the packet is
     for. */
  hdr = (struct bitopt_hdr *)packetbuf_dataptr();
    1856:	ee 2d       	mov	r30, r14
    1858:	f0 2f       	mov	r31, r16
  if(packetbuf_hdrreduce(sizeof(struct bitopt_hdr)) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  c = channel_lookup((hdr->channel[1] << 8) + hdr->channel[0]);
    185a:	91 81       	ldd	r25, Z+1	; 0x01
    185c:	80 e0       	ldi	r24, 0x00	; 0
    185e:	20 81       	ld	r18, Z
    1860:	82 0f       	add	r24, r18
    1862:	91 1d       	adc	r25, r1
    1864:	0e 94 46 0b 	call	0x168c	; 0x168c <channel_lookup>
    1868:	7c 01       	movw	r14, r24
  if(c == NULL) {
    186a:	00 97       	sbiw	r24, 0x00	; 0
    186c:	09 f4       	brne	.+2      	; 0x1870 <unpack_header+0x58>
    186e:	68 c0       	rjmp	.+208    	; 0x1940 <unpack_header+0x128>
    PRINTF("chameleon-bitopt: input: channel %u not found\n",
           (hdr->channel[1] << 8) + hdr->channel[0]);
    return NULL;
  }

  hdrptr = packetbuf_dataptr();
    1870:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    1874:	3c 01       	movw	r6, r24
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
    1876:	d7 01       	movw	r26, r14
    1878:	16 96       	adiw	r26, 0x06	; 6
    187a:	4c 91       	ld	r20, X
    187c:	16 97       	sbiw	r26, 0x06	; 6
    187e:	24 2f       	mov	r18, r20
    1880:	30 e0       	ldi	r19, 0x00	; 0
    1882:	27 70       	andi	r18, 0x07	; 7
    1884:	30 70       	andi	r19, 0x00	; 0
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	90 e0       	ldi	r25, 0x00	; 0
    188a:	21 15       	cp	r18, r1
    188c:	31 05       	cpc	r19, r1
    188e:	11 f4       	brne	.+4      	; 0x1894 <unpack_header+0x7c>
    1890:	80 e0       	ldi	r24, 0x00	; 0
    1892:	90 e0       	ldi	r25, 0x00	; 0
    1894:	46 95       	lsr	r20
    1896:	46 95       	lsr	r20
    1898:	46 95       	lsr	r20
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    189a:	84 0f       	add	r24, r20
    189c:	91 1d       	adc	r25, r1
    189e:	0e 94 f1 19 	call	0x33e2	; 0x33e2 <packetbuf_hdrreduce>
    18a2:	00 97       	sbiw	r24, 0x00	; 0
    18a4:	09 f4       	brne	.+2      	; 0x18a8 <unpack_header+0x90>
    18a6:	4a c0       	rjmp	.+148    	; 0x193c <unpack_header+0x124>
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    18a8:	f7 01       	movw	r30, r14
    18aa:	04 81       	ldd	r16, Z+4	; 0x04
    18ac:	15 81       	ldd	r17, Z+5	; 0x05
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
    18ae:	cc 24       	eor	r12, r12
    18b0:	dd 24       	eor	r13, r13
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, addr.u8[0], addr.u8[1]);
      packetbuf_set_addr(a->type, &addr);
    } else {
      packetbuf_attr_t val = 0;
      get_bits((uint8_t *)&val, &hdrptr[byteptr], bitptr & 7, len);
    18b2:	f3 e0       	ldi	r31, 0x03	; 3
    18b4:	4f 2e       	mov	r4, r31
    18b6:	51 2c       	mov	r5, r1
    18b8:	4c 0e       	add	r4, r28
    18ba:	5d 1e       	adc	r5, r29
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    byteptr = bitptr / 8;
    if(PACKETBUF_IS_ADDR(a->type)) {
      rimeaddr_t addr;
      get_bits((uint8_t *)&addr, &hdrptr[byteptr], bitptr & 7, len);
    18bc:	4e 01       	movw	r8, r28
    18be:	08 94       	sec
    18c0:	81 1c       	adc	r8, r1
    18c2:	91 1c       	adc	r9, r1
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    18c4:	36 c0       	rjmp	.+108    	; 0x1932 <unpack_header+0x11a>
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    PRINTF("%d.%d: unpack_header type %d, len %d, bitptr %d\n",
	   rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	   a->type, a->len, bitptr);
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    18c6:	d8 01       	movw	r26, r16
    18c8:	11 96       	adiw	r26, 0x01	; 1
    18ca:	ac 90       	ld	r10, X
    18cc:	11 97       	sbiw	r26, 0x01	; 1
    18ce:	bb 24       	eor	r11, r11
    byteptr = bitptr / 8;
    18d0:	b6 01       	movw	r22, r12
    18d2:	e3 e0       	ldi	r30, 0x03	; 3
    18d4:	75 95       	asr	r23
    18d6:	67 95       	ror	r22
    18d8:	ea 95       	dec	r30
    18da:	e1 f7       	brne	.-8      	; 0x18d4 <unpack_header+0xbc>
    18dc:	66 0d       	add	r22, r6
    18de:	77 1d       	adc	r23, r7
    18e0:	a6 01       	movw	r20, r12
    18e2:	47 70       	andi	r20, 0x07	; 7
    18e4:	50 70       	andi	r21, 0x00	; 0
    if(PACKETBUF_IS_ADDR(a->type)) {
    18e6:	88 31       	cpi	r24, 0x18	; 24
    18e8:	78 f0       	brcs	.+30     	; 0x1908 <unpack_header+0xf0>
      rimeaddr_t addr;
      get_bits((uint8_t *)&addr, &hdrptr[byteptr], bitptr & 7, len);
    18ea:	c4 01       	movw	r24, r8
    18ec:	95 01       	movw	r18, r10
    18ee:	0e 94 9f 0b 	call	0x173e	; 0x173e <get_bits>

static inline int
packetbuf_set_addr(uint8_t type, const rimeaddr_t *addr)
{
/*   packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].type = type; */
  rimeaddr_copy(&packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].addr, addr);
    18f2:	f8 01       	movw	r30, r16
    18f4:	80 81       	ld	r24, Z
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	88 0f       	add	r24, r24
    18fa:	99 1f       	adc	r25, r25
    18fc:	85 5c       	subi	r24, 0xC5	; 197
    18fe:	91 4f       	sbci	r25, 0xF1	; 241
    1900:	b4 01       	movw	r22, r8
    1902:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    1906:	11 c0       	rjmp	.+34     	; 0x192a <unpack_header+0x112>
      PRINTF("%d.%d: unpack_header type %d, addr %d.%d\n",
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, addr.u8[0], addr.u8[1]);
      packetbuf_set_addr(a->type, &addr);
    } else {
      packetbuf_attr_t val = 0;
    1908:	1c 82       	std	Y+4, r1	; 0x04
    190a:	1b 82       	std	Y+3, r1	; 0x03
      get_bits((uint8_t *)&val, &hdrptr[byteptr], bitptr & 7, len);
    190c:	c2 01       	movw	r24, r4
    190e:	95 01       	movw	r18, r10
    1910:	0e 94 9f 0b 	call	0x173e	; 0x173e <get_bits>

static inline int
packetbuf_set_attr(uint8_t type, const packetbuf_attr_t val)
{
/*   packetbuf_attrs[type].type = type; */
  packetbuf_attrs[type].val = val;
    1914:	d8 01       	movw	r26, r16
    1916:	ec 91       	ld	r30, X
    1918:	f0 e0       	ldi	r31, 0x00	; 0
    191a:	ee 0f       	add	r30, r30
    191c:	ff 1f       	adc	r31, r31
    191e:	ed 58       	subi	r30, 0x8D	; 141
    1920:	f1 4f       	sbci	r31, 0xF1	; 241
    1922:	8b 81       	ldd	r24, Y+3	; 0x03
    1924:	9c 81       	ldd	r25, Y+4	; 0x04
    1926:	91 83       	std	Z+1, r25	; 0x01
    1928:	80 83       	st	Z, r24
      PRINTF("%d.%d: unpack_header type %d, val %d\n",
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, val);
    }
    /*    byteptr += len / 8;*/
    bitptr += len;
    192a:	ca 0c       	add	r12, r10
    192c:	db 1c       	adc	r13, r11
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    192e:	0e 5f       	subi	r16, 0xFE	; 254
    1930:	1f 4f       	sbci	r17, 0xFF	; 255
    1932:	f8 01       	movw	r30, r16
    1934:	80 81       	ld	r24, Z
    1936:	88 23       	and	r24, r24
    1938:	31 f6       	brne	.-116    	; 0x18c6 <unpack_header+0xae>
    193a:	02 c0       	rjmp	.+4      	; 0x1940 <unpack_header+0x128>

  hdrptr = packetbuf_dataptr();
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
    193c:	ee 24       	eor	r14, r14
    193e:	ff 24       	eor	r15, r15
    }
    /*    byteptr += len / 8;*/
    bitptr += len;
  }
  return c;
}
    1940:	c7 01       	movw	r24, r14
    1942:	0f 90       	pop	r0
    1944:	0f 90       	pop	r0
    1946:	0f 90       	pop	r0
    1948:	0f 90       	pop	r0
    194a:	cf 91       	pop	r28
    194c:	df 91       	pop	r29
    194e:	1f 91       	pop	r17
    1950:	0f 91       	pop	r16
    1952:	ff 90       	pop	r15
    1954:	ef 90       	pop	r14
    1956:	df 90       	pop	r13
    1958:	cf 90       	pop	r12
    195a:	bf 90       	pop	r11
    195c:	af 90       	pop	r10
    195e:	9f 90       	pop	r9
    1960:	8f 90       	pop	r8
    1962:	7f 90       	pop	r7
    1964:	6f 90       	pop	r6
    1966:	5f 90       	pop	r5
    1968:	4f 90       	pop	r4
    196a:	08 95       	ret

0000196c <set_bits_in_byte>:
  return size;
}
/*---------------------------------------------------------------------------*/
void CC_INLINE
set_bits_in_byte(uint8_t *target, int bitpos, uint8_t val, int vallen)
{
    196c:	fc 01       	movw	r30, r24
  unsigned short shifted_val;
  shifted_val = val << (8 - bitpos + 8 - vallen);
    196e:	50 e0       	ldi	r21, 0x00	; 0
    1970:	80 e1       	ldi	r24, 0x10	; 16
    1972:	90 e0       	ldi	r25, 0x00	; 0
    1974:	86 1b       	sub	r24, r22
    1976:	97 0b       	sbc	r25, r23
    1978:	82 1b       	sub	r24, r18
    197a:	93 0b       	sbc	r25, r19
    197c:	02 c0       	rjmp	.+4      	; 0x1982 <set_bits_in_byte+0x16>
    197e:	44 0f       	add	r20, r20
    1980:	55 1f       	adc	r21, r21
    1982:	8a 95       	dec	r24
    1984:	e2 f7       	brpl	.-8      	; 0x197e <set_bits_in_byte+0x12>
  /*  printf("set_bits_in_byte before target[0] 0x%02x target[1] 0x%02x shifted_val 0x%04x val 0x%02x vallen %d\n",
      target[0], target[1], shifted_val, val, vallen);*/
  target[0] |= shifted_val >> 8;
    1986:	80 81       	ld	r24, Z
    1988:	85 2b       	or	r24, r21
    198a:	80 83       	st	Z, r24
  target[1] |= shifted_val & 0xff;
    198c:	81 81       	ldd	r24, Z+1	; 0x01
    198e:	84 2b       	or	r24, r20
    1990:	81 83       	std	Z+1, r24	; 0x01
}
    1992:	08 95       	ret

00001994 <set_bits>:
/*---------------------------------------------------------------------------*/
void
set_bits(uint8_t *ptr, int bitpos, uint8_t *val, int vallen)
{
    1994:	6f 92       	push	r6
    1996:	7f 92       	push	r7
    1998:	8f 92       	push	r8
    199a:	9f 92       	push	r9
    199c:	af 92       	push	r10
    199e:	bf 92       	push	r11
    19a0:	cf 92       	push	r12
    19a2:	df 92       	push	r13
    19a4:	ef 92       	push	r14
    19a6:	ff 92       	push	r15
    19a8:	0f 93       	push	r16
    19aa:	1f 93       	push	r17
    19ac:	cf 93       	push	r28
    19ae:	df 93       	push	r29
    19b0:	8c 01       	movw	r16, r24
    19b2:	5b 01       	movw	r10, r22
    19b4:	6a 01       	movw	r12, r20
    19b6:	79 01       	movw	r14, r18
  int i, bits;

  /*  PRINTF("set_bits %p bitpos %d, val %p len %d\n",
      ptr, bitpos, val, vallen);*/

  if(vallen < 8) {
    19b8:	28 30       	cpi	r18, 0x08	; 8
    19ba:	31 05       	cpc	r19, r1
    19bc:	24 f4       	brge	.+8      	; 0x19c6 <set_bits+0x32>
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
    19be:	c8 01       	movw	r24, r16
    19c0:	fa 01       	movw	r30, r20
    19c2:	40 81       	ld	r20, Z
    19c4:	56 c0       	rjmp	.+172    	; 0x1a72 <set_bits+0xde>
    19c6:	39 01       	movw	r6, r18
    19c8:	a3 e0       	ldi	r26, 0x03	; 3
    19ca:	75 94       	asr	r7
    19cc:	67 94       	ror	r6
    19ce:	aa 95       	dec	r26
    19d0:	e1 f7       	brne	.-8      	; 0x19ca <set_bits+0x36>
  } else {
    if(bitpos == 0) {
    19d2:	61 15       	cp	r22, r1
    19d4:	71 05       	cpc	r23, r1
    19d6:	21 f0       	breq	.+8      	; 0x19e0 <set_bits+0x4c>
      bits = vallen & 7;
      if(bits) {
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    19d8:	4a 01       	movw	r8, r20
    19da:	c0 e0       	ldi	r28, 0x00	; 0
    19dc:	d0 e0       	ldi	r29, 0x00	; 0
    19de:	21 c0       	rjmp	.+66     	; 0x1a22 <set_bits+0x8e>

  if(vallen < 8) {
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    19e0:	da 01       	movw	r26, r20
    19e2:	f8 01       	movw	r30, r16
    19e4:	80 e0       	ldi	r24, 0x00	; 0
    19e6:	90 e0       	ldi	r25, 0x00	; 0
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	ptr[i] = val[i];
    19e8:	2d 91       	ld	r18, X+
    19ea:	21 93       	st	Z+, r18

  if(vallen < 8) {
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    19ec:	01 96       	adiw	r24, 0x01	; 1
    19ee:	86 15       	cp	r24, r6
    19f0:	97 05       	cpc	r25, r7
    19f2:	d4 f3       	brlt	.-12     	; 0x19e8 <set_bits+0x54>
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	ptr[i] = val[i];
      }
      bits = vallen & 7;
    19f4:	97 01       	movw	r18, r14
    19f6:	27 70       	andi	r18, 0x07	; 7
    19f8:	30 70       	andi	r19, 0x00	; 0
      if(bits) {
    19fa:	21 15       	cp	r18, r1
    19fc:	31 05       	cpc	r19, r1
    19fe:	d9 f1       	breq	.+118    	; 0x1a76 <set_bits+0xe2>
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
    1a00:	f6 01       	movw	r30, r12
    1a02:	e8 0f       	add	r30, r24
    1a04:	f9 1f       	adc	r31, r25
    1a06:	40 81       	ld	r20, Z
    1a08:	50 e0       	ldi	r21, 0x00	; 0
    1a0a:	68 e0       	ldi	r22, 0x08	; 8
    1a0c:	70 e0       	ldi	r23, 0x00	; 0
    1a0e:	62 1b       	sub	r22, r18
    1a10:	73 0b       	sbc	r23, r19
    1a12:	02 c0       	rjmp	.+4      	; 0x1a18 <set_bits+0x84>
    1a14:	55 95       	asr	r21
    1a16:	47 95       	ror	r20
    1a18:	6a 95       	dec	r22
    1a1a:	e2 f7       	brpl	.-8      	; 0x1a14 <set_bits+0x80>
    1a1c:	80 0f       	add	r24, r16
    1a1e:	91 1f       	adc	r25, r17
    1a20:	26 c0       	rjmp	.+76     	; 0x1a6e <set_bits+0xda>
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	set_bits_in_byte(&ptr[i], bitpos, val[i], 8);
    1a22:	f4 01       	movw	r30, r8
    1a24:	41 91       	ld	r20, Z+
    1a26:	4f 01       	movw	r8, r30
    1a28:	c8 01       	movw	r24, r16
    1a2a:	8c 0f       	add	r24, r28
    1a2c:	9d 1f       	adc	r25, r29
    1a2e:	b5 01       	movw	r22, r10
    1a30:	28 e0       	ldi	r18, 0x08	; 8
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	0e 94 b6 0c 	call	0x196c	; 0x196c <set_bits_in_byte>
      bits = vallen & 7;
      if(bits) {
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    1a38:	21 96       	adiw	r28, 0x01	; 1
    1a3a:	c6 15       	cp	r28, r6
    1a3c:	d7 05       	cpc	r29, r7
    1a3e:	8c f3       	brlt	.-30     	; 0x1a22 <set_bits+0x8e>
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	set_bits_in_byte(&ptr[i], bitpos, val[i], 8);
      }
      bits = vallen & 7;
    1a40:	97 01       	movw	r18, r14
    1a42:	27 70       	andi	r18, 0x07	; 7
    1a44:	30 70       	andi	r19, 0x00	; 0
      if(bits) {
    1a46:	21 15       	cp	r18, r1
    1a48:	31 05       	cpc	r19, r1
    1a4a:	a9 f0       	breq	.+42     	; 0x1a76 <set_bits+0xe2>
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits + bitpos), bits);
    1a4c:	f6 01       	movw	r30, r12
    1a4e:	ec 0f       	add	r30, r28
    1a50:	fd 1f       	adc	r31, r29
    1a52:	40 81       	ld	r20, Z
    1a54:	50 e0       	ldi	r21, 0x00	; 0
    1a56:	c5 01       	movw	r24, r10
    1a58:	08 96       	adiw	r24, 0x08	; 8
    1a5a:	82 1b       	sub	r24, r18
    1a5c:	93 0b       	sbc	r25, r19
    1a5e:	02 c0       	rjmp	.+4      	; 0x1a64 <set_bits+0xd0>
    1a60:	55 95       	asr	r21
    1a62:	47 95       	ror	r20
    1a64:	8a 95       	dec	r24
    1a66:	e2 f7       	brpl	.-8      	; 0x1a60 <set_bits+0xcc>
    1a68:	c8 01       	movw	r24, r16
    1a6a:	8c 0f       	add	r24, r28
    1a6c:	9d 1f       	adc	r25, r29
    1a6e:	60 e0       	ldi	r22, 0x00	; 0
    1a70:	70 e0       	ldi	r23, 0x00	; 0
    1a72:	0e 94 b6 0c 	call	0x196c	; 0x196c <set_bits_in_byte>
      }
    }
  }
}
    1a76:	df 91       	pop	r29
    1a78:	cf 91       	pop	r28
    1a7a:	1f 91       	pop	r17
    1a7c:	0f 91       	pop	r16
    1a7e:	ff 90       	pop	r15
    1a80:	ef 90       	pop	r14
    1a82:	df 90       	pop	r13
    1a84:	cf 90       	pop	r12
    1a86:	bf 90       	pop	r11
    1a88:	af 90       	pop	r10
    1a8a:	9f 90       	pop	r9
    1a8c:	8f 90       	pop	r8
    1a8e:	7f 90       	pop	r7
    1a90:	6f 90       	pop	r6
    1a92:	08 95       	ret

00001a94 <pack_header>:
}
#endif
/*---------------------------------------------------------------------------*/
static int
pack_header(struct channel *c)
{
    1a94:	8f 92       	push	r8
    1a96:	9f 92       	push	r9
    1a98:	af 92       	push	r10
    1a9a:	bf 92       	push	r11
    1a9c:	cf 92       	push	r12
    1a9e:	df 92       	push	r13
    1aa0:	ef 92       	push	r14
    1aa2:	ff 92       	push	r15
    1aa4:	0f 93       	push	r16
    1aa6:	1f 93       	push	r17
    1aa8:	df 93       	push	r29
    1aaa:	cf 93       	push	r28
    1aac:	00 d0       	rcall	.+0      	; 0x1aae <pack_header+0x1a>
    1aae:	cd b7       	in	r28, 0x3d	; 61
    1ab0:	de b7       	in	r29, 0x3e	; 62
    1ab2:	8c 01       	movw	r16, r24
  struct bitopt_hdr *hdr;
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */

  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
    1ab4:	dc 01       	movw	r26, r24
    1ab6:	16 96       	adiw	r26, 0x06	; 6
    1ab8:	4c 91       	ld	r20, X
    1aba:	16 97       	sbiw	r26, 0x06	; 6
    1abc:	84 2f       	mov	r24, r20
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	87 70       	andi	r24, 0x07	; 7
    1ac2:	90 70       	andi	r25, 0x00	; 0
    1ac4:	21 e0       	ldi	r18, 0x01	; 1
    1ac6:	30 e0       	ldi	r19, 0x00	; 0
    1ac8:	00 97       	sbiw	r24, 0x00	; 0
    1aca:	11 f4       	brne	.+4      	; 0x1ad0 <pack_header+0x3c>
    1acc:	20 e0       	ldi	r18, 0x00	; 0
    1ace:	30 e0       	ldi	r19, 0x00	; 0
    1ad0:	46 95       	lsr	r20
    1ad2:	46 95       	lsr	r20
    1ad4:	46 95       	lsr	r20
    1ad6:	79 01       	movw	r14, r18
    1ad8:	e4 0e       	add	r14, r20
    1ada:	f1 1c       	adc	r15, r1
  if(packetbuf_hdralloc(hdrbytesize + sizeof(struct bitopt_hdr)) == 0) {
    1adc:	c7 01       	movw	r24, r14
    1ade:	02 96       	adiw	r24, 0x02	; 2
    1ae0:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <packetbuf_hdralloc>
    1ae4:	00 97       	sbiw	r24, 0x00	; 0
    1ae6:	09 f4       	brne	.+2      	; 0x1aea <pack_header+0x56>
    1ae8:	55 c0       	rjmp	.+170    	; 0x1b94 <pack_header+0x100>
    PRINTF("chameleon-bitopt: insufficient space for headers\n");
    return 0;
  }
  hdr = (struct bitopt_hdr *)packetbuf_hdrptr();
    1aea:	0e 94 1d 1a 	call	0x343a	; 0x343a <packetbuf_hdrptr>
    1aee:	fc 01       	movw	r30, r24
  hdr->channel[0] = c->channelno & 0xff;
    1af0:	d8 01       	movw	r26, r16
    1af2:	12 96       	adiw	r26, 0x02	; 2
    1af4:	8c 91       	ld	r24, X
    1af6:	12 97       	sbiw	r26, 0x02	; 2
    1af8:	80 83       	st	Z, r24
  hdr->channel[1] = (c->channelno >> 8) & 0xff;
    1afa:	13 96       	adiw	r26, 0x03	; 3
    1afc:	8c 91       	ld	r24, X
    1afe:	81 83       	std	Z+1, r24	; 0x01

  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
    1b00:	0e 94 1d 1a 	call	0x343a	; 0x343a <packetbuf_hdrptr>
    1b04:	42 e0       	ldi	r20, 0x02	; 2
    1b06:	a4 2e       	mov	r10, r20
    1b08:	b1 2c       	mov	r11, r1
    1b0a:	a8 0e       	add	r10, r24
    1b0c:	b9 1e       	adc	r11, r25
  memset(hdrptr, 0, hdrbytesize);
    1b0e:	c5 01       	movw	r24, r10
    1b10:	60 e0       	ldi	r22, 0x00	; 0
    1b12:	70 e0       	ldi	r23, 0x00	; 0
    1b14:	a7 01       	movw	r20, r14
    1b16:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <memset>
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    1b1a:	f8 01       	movw	r30, r16
    1b1c:	e4 80       	ldd	r14, Z+4	; 0x04
    1b1e:	f5 80       	ldd	r15, Z+5	; 0x05
  hdr->channel[1] = (c->channelno >> 8) & 0xff;

  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
    1b20:	00 e0       	ldi	r16, 0x00	; 0
    1b22:	10 e0       	ldi	r17, 0x00	; 0
	    ((uint8_t *)packetbuf_addr(a->type))[0],
	    ((uint8_t *)packetbuf_addr(a->type))[1]);
    } else {
      packetbuf_attr_t val;
      val = packetbuf_attr(a->type);
      set_bits(&hdrptr[byteptr], bitptr & 7,
    1b24:	4e 01       	movw	r8, r28
    1b26:	08 94       	sec
    1b28:	81 1c       	adc	r8, r1
    1b2a:	91 1c       	adc	r9, r1
  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    1b2c:	2c c0       	rjmp	.+88     	; 0x1b86 <pack_header+0xf2>
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    PRINTF("%d.%d: pack_header type %d, len %d, bitptr %d, ",
	   rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	   a->type, a->len, bitptr);
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    1b2e:	d7 01       	movw	r26, r14
    1b30:	11 96       	adiw	r26, 0x01	; 1
    1b32:	cc 90       	ld	r12, X
    1b34:	11 97       	sbiw	r26, 0x01	; 1
    1b36:	dd 24       	eor	r13, r13
    byteptr = bitptr / 8;
    1b38:	c8 01       	movw	r24, r16
    1b3a:	33 e0       	ldi	r19, 0x03	; 3
    1b3c:	95 95       	asr	r25
    1b3e:	87 95       	ror	r24
    1b40:	3a 95       	dec	r19
    1b42:	e1 f7       	brne	.-8      	; 0x1b3c <pack_header+0xa8>
    1b44:	8a 0d       	add	r24, r10
    1b46:	9b 1d       	adc	r25, r11
    1b48:	b8 01       	movw	r22, r16
    1b4a:	67 70       	andi	r22, 0x07	; 7
    1b4c:	70 70       	andi	r23, 0x00	; 0
    1b4e:	42 2f       	mov	r20, r18
    1b50:	50 e0       	ldi	r21, 0x00	; 0
    if(PACKETBUF_IS_ADDR(a->type)) {
    1b52:	28 31       	cpi	r18, 0x18	; 24
    1b54:	28 f0       	brcs	.+10     	; 0x1b60 <pack_header+0xcc>
      set_bits(&hdrptr[byteptr], bitptr & 7,
	       (uint8_t *)packetbuf_addr(a->type), len);
    1b56:	44 0f       	add	r20, r20
    1b58:	55 1f       	adc	r21, r21
    1b5a:	45 5c       	subi	r20, 0xC5	; 197
    1b5c:	51 4f       	sbci	r21, 0xF1	; 241
    1b5e:	0a c0       	rjmp	.+20     	; 0x1b74 <pack_header+0xe0>
  return 1;
}
static inline packetbuf_attr_t
packetbuf_attr(uint8_t type)
{
  return packetbuf_attrs[type].val;
    1b60:	fa 01       	movw	r30, r20
    1b62:	ee 0f       	add	r30, r30
    1b64:	ff 1f       	adc	r31, r31
    1b66:	ed 58       	subi	r30, 0x8D	; 141
    1b68:	f1 4f       	sbci	r31, 0xF1	; 241
	    /*	    rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],*/
	    ((uint8_t *)packetbuf_addr(a->type))[0],
	    ((uint8_t *)packetbuf_addr(a->type))[1]);
    } else {
      packetbuf_attr_t val;
      val = packetbuf_attr(a->type);
    1b6a:	20 81       	ld	r18, Z
    1b6c:	31 81       	ldd	r19, Z+1	; 0x01
    1b6e:	3a 83       	std	Y+2, r19	; 0x02
    1b70:	29 83       	std	Y+1, r18	; 0x01
      set_bits(&hdrptr[byteptr], bitptr & 7,
    1b72:	a4 01       	movw	r20, r8
    1b74:	96 01       	movw	r18, r12
    1b76:	0e 94 ca 0c 	call	0x1994	; 0x1994 <set_bits>
      PRINTF("value %d\n",
	    /*rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],*/
	    val);
    }
    /*    printhdr(hdrptr, hdrbytesize);*/
    bitptr += len;
    1b7a:	0c 0d       	add	r16, r12
    1b7c:	1d 1d       	adc	r17, r13
  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    1b7e:	e2 e0       	ldi	r30, 0x02	; 2
    1b80:	f0 e0       	ldi	r31, 0x00	; 0
    1b82:	ee 0e       	add	r14, r30
    1b84:	ff 1e       	adc	r15, r31
    1b86:	d7 01       	movw	r26, r14
    1b88:	2c 91       	ld	r18, X
    1b8a:	22 23       	and	r18, r18
    1b8c:	81 f6       	brne	.-96     	; 0x1b2e <pack_header+0x9a>
    /*    printhdr(hdrptr, hdrbytesize);*/
    bitptr += len;
  }
  /*  printhdr(hdrptr, hdrbytesize);*/

  return 1; /* Send out packet */
    1b8e:	21 e0       	ldi	r18, 0x01	; 1
    1b90:	30 e0       	ldi	r19, 0x00	; 0
    1b92:	02 c0       	rjmp	.+4      	; 0x1b98 <pack_header+0x104>
     all attributes that are used on this channel. */

  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdralloc(hdrbytesize + sizeof(struct bitopt_hdr)) == 0) {
    PRINTF("chameleon-bitopt: insufficient space for headers\n");
    return 0;
    1b94:	20 e0       	ldi	r18, 0x00	; 0
    1b96:	30 e0       	ldi	r19, 0x00	; 0
    bitptr += len;
  }
  /*  printhdr(hdrptr, hdrbytesize);*/

  return 1; /* Send out packet */
}
    1b98:	c9 01       	movw	r24, r18
    1b9a:	0f 90       	pop	r0
    1b9c:	0f 90       	pop	r0
    1b9e:	cf 91       	pop	r28
    1ba0:	df 91       	pop	r29
    1ba2:	1f 91       	pop	r17
    1ba4:	0f 91       	pop	r16
    1ba6:	ff 90       	pop	r15
    1ba8:	ef 90       	pop	r14
    1baa:	df 90       	pop	r13
    1bac:	cf 90       	pop	r12
    1bae:	bf 90       	pop	r11
    1bb0:	af 90       	pop	r10
    1bb2:	9f 90       	pop	r9
    1bb4:	8f 90       	pop	r8
    1bb6:	08 95       	ret

00001bb8 <on>:

/*---------------------------------------------------------------------------*/
static void
on(void)
{
  if(cxmac_is_on && radio_is_on == 0) {
    1bb8:	80 91 65 06 	lds	r24, 0x0665
    1bbc:	88 23       	and	r24, r24
    1bbe:	61 f0       	breq	.+24     	; 0x1bd8 <on+0x20>
    1bc0:	80 91 82 06 	lds	r24, 0x0682
    1bc4:	88 23       	and	r24, r24
    1bc6:	41 f4       	brne	.+16     	; 0x1bd8 <on+0x20>
    radio_is_on = 1;
    1bc8:	81 e0       	ldi	r24, 0x01	; 1
    1bca:	80 93 82 06 	sts	0x0682, r24
    NETSTACK_RADIO.on();
    1bce:	e0 91 f0 05 	lds	r30, 0x05F0
    1bd2:	f0 91 f1 05 	lds	r31, 0x05F1
    1bd6:	09 95       	icall
    1bd8:	08 95       	ret

00001bda <off>:
}
/*---------------------------------------------------------------------------*/
static void
off(void)
{
  if(cxmac_is_on && radio_is_on != 0 && is_listening == 0 &&
    1bda:	80 91 65 06 	lds	r24, 0x0665
    1bde:	88 23       	and	r24, r24
    1be0:	79 f0       	breq	.+30     	; 0x1c00 <off+0x26>
    1be2:	80 91 82 06 	lds	r24, 0x0682
    1be6:	88 23       	and	r24, r24
    1be8:	59 f0       	breq	.+22     	; 0x1c00 <off+0x26>
    1bea:	80 91 76 06 	lds	r24, 0x0676
    1bee:	88 23       	and	r24, r24
    1bf0:	39 f4       	brne	.+14     	; 0x1c00 <off+0x26>
     is_streaming == 0) {
    radio_is_on = 0;
    1bf2:	10 92 82 06 	sts	0x0682, r1
    NETSTACK_RADIO.off();
    1bf6:	e0 91 f2 05 	lds	r30, 0x05F2
    1bfa:	f0 91 f3 05 	lds	r31, 0x05F3
    1bfe:	09 95       	icall
    1c00:	08 95       	ret

00001c02 <turn_off>:
}
/*---------------------------------------------------------------------------*/
static int
turn_off(int keep_radio_on)
{
  cxmac_is_on = 0;
    1c02:	10 92 65 06 	sts	0x0665, r1
  if(keep_radio_on) {
    1c06:	00 97       	sbiw	r24, 0x00	; 0
    1c08:	31 f0       	breq	.+12     	; 0x1c16 <turn_off+0x14>
    return NETSTACK_RADIO.on();
    1c0a:	e0 91 f0 05 	lds	r30, 0x05F0
    1c0e:	f0 91 f1 05 	lds	r31, 0x05F1
    1c12:	09 95       	icall
    1c14:	08 95       	ret
  } else {
    return NETSTACK_RADIO.off();
    1c16:	e0 91 f2 05 	lds	r30, 0x05F2
    1c1a:	f0 91 f3 05 	lds	r31, 0x05F3
    1c1e:	09 95       	icall
  }
}
    1c20:	08 95       	ret

00001c22 <channel_check_interval>:
/*---------------------------------------------------------------------------*/
static unsigned short
channel_check_interval(void)
{
  return (1ul * CLOCK_SECOND * DEFAULT_PERIOD) / RTIMER_ARCH_SECOND;
}
    1c22:	80 e1       	ldi	r24, 0x10	; 16
    1c24:	90 e0       	ldi	r25, 0x00	; 0
    1c26:	08 95       	ret

00001c28 <cschedule_powercycle>:
static struct ctimer cpowercycle_ctimer;
#define CSCHEDULE_POWERCYCLE(rtime) cschedule_powercycle((1ul * CLOCK_SECOND * (rtime)) / RTIMER_ARCH_SECOND)
static char cpowercycle(void *ptr);
static void
cschedule_powercycle(clock_time_t time)
{
    1c28:	bc 01       	movw	r22, r24

  if(cxmac_is_on) {
    1c2a:	80 91 65 06 	lds	r24, 0x0665
    1c2e:	88 23       	and	r24, r24
    1c30:	69 f0       	breq	.+26     	; 0x1c4c <cschedule_powercycle+0x24>
    if(time == 0) {
    1c32:	61 15       	cp	r22, r1
    1c34:	71 05       	cpc	r23, r1
    1c36:	11 f4       	brne	.+4      	; 0x1c3c <cschedule_powercycle+0x14>
      time = 1;
    1c38:	61 e0       	ldi	r22, 0x01	; 1
    1c3a:	70 e0       	ldi	r23, 0x00	; 0
    }
    ctimer_set(&cpowercycle_ctimer, time,
    1c3c:	86 e6       	ldi	r24, 0x66	; 102
    1c3e:	96 e0       	ldi	r25, 0x06	; 6
    1c40:	40 e4       	ldi	r20, 0x40	; 64
    1c42:	5e e0       	ldi	r21, 0x0E	; 14
    1c44:	20 e0       	ldi	r18, 0x00	; 0
    1c46:	30 e0       	ldi	r19, 0x00	; 0
    1c48:	0e 94 bb 18 	call	0x3176	; 0x3176 <ctimer_set>
    1c4c:	08 95       	ret

00001c4e <turn_on>:
}
/*---------------------------------------------------------------------------*/
static int
turn_on(void)
{
  cxmac_is_on = 1;
    1c4e:	81 e0       	ldi	r24, 0x01	; 1
    1c50:	80 93 65 06 	sts	0x0665, r24
  /*  rtimer_set(&rt, RTIMER_NOW() + cxmac_config.off_time, 1,
      (void (*)(struct rtimer *, void *))powercycle, NULL);*/
  CSCHEDULE_POWERCYCLE(DEFAULT_OFF_TIME);
    1c54:	8f e0       	ldi	r24, 0x0F	; 15
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <cschedule_powercycle>
  return 1;
}
    1c5c:	81 e0       	ldi	r24, 0x01	; 1
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	08 95       	ret

00001c62 <powercycle_turn_radio_off>:
}
/*---------------------------------------------------------------------------*/
static void
powercycle_turn_radio_off(void)
{
  if(we_are_sending == 0 &&
    1c62:	80 91 81 06 	lds	r24, 0x0681
    1c66:	88 23       	and	r24, r24
    1c68:	31 f4       	brne	.+12     	; 0x1c76 <powercycle_turn_radio_off+0x14>
     waiting_for_packet == 0) {
    1c6a:	80 91 80 06 	lds	r24, 0x0680
}
/*---------------------------------------------------------------------------*/
static void
powercycle_turn_radio_off(void)
{
  if(we_are_sending == 0 &&
    1c6e:	88 23       	and	r24, r24
    1c70:	11 f4       	brne	.+4      	; 0x1c76 <powercycle_turn_radio_off+0x14>
     waiting_for_packet == 0) {
    off();
    1c72:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <off>
  }
#if CXMAC_CONF_COMPOWER
  compower_accumulate(&compower_idle_activity);
    1c76:	83 e6       	ldi	r24, 0x63	; 99
    1c78:	9e e0       	ldi	r25, 0x0E	; 14
    1c7a:	0e 94 ed 15 	call	0x2bda	; 0x2bda <compower_accumulate>
#endif /* CXMAC_CONF_COMPOWER */
}
    1c7e:	08 95       	ret

00001c80 <cpowercycle>:
}
/*---------------------------------------------------------------------------*/
static char
cpowercycle(void *ptr)
{
  if(is_streaming) {
    1c80:	80 91 76 06 	lds	r24, 0x0676
    1c84:	88 23       	and	r24, r24
    1c86:	d1 f0       	breq	.+52     	; 0x1cbc <cpowercycle+0x3c>
    if(!RTIMER_CLOCK_LT(RTIMER_NOW(), stream_until)) {
    1c88:	80 91 88 00 	lds	r24, 0x0088
    1c8c:	90 91 89 00 	lds	r25, 0x0089
    1c90:	20 91 77 06 	lds	r18, 0x0677
    1c94:	30 91 78 06 	lds	r19, 0x0678
    1c98:	82 1b       	sub	r24, r18
    1c9a:	93 0b       	sbc	r25, r19
    1c9c:	97 fd       	sbrc	r25, 7
    1c9e:	0e c0       	rjmp	.+28     	; 0x1cbc <cpowercycle+0x3c>
      is_streaming = 0;
    1ca0:	10 92 76 06 	sts	0x0676, r1
      rimeaddr_copy(&is_streaming_to, &rimeaddr_null);
    1ca4:	89 e7       	ldi	r24, 0x79	; 121
    1ca6:	96 e0       	ldi	r25, 0x06	; 6
    1ca8:	67 e8       	ldi	r22, 0x87	; 135
    1caa:	73 e0       	ldi	r23, 0x03	; 3
    1cac:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
      rimeaddr_copy(&is_streaming_to_too, &rimeaddr_null);
    1cb0:	8b e7       	ldi	r24, 0x7B	; 123
    1cb2:	96 e0       	ldi	r25, 0x06	; 6
    1cb4:	67 e8       	ldi	r22, 0x87	; 135
    1cb6:	73 e0       	ldi	r23, 0x03	; 3
    1cb8:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    }
  }

  PT_BEGIN(&pt);
    1cbc:	80 91 7d 06 	lds	r24, 0x067D
    1cc0:	90 91 7e 06 	lds	r25, 0x067E
    1cc4:	21 e0       	ldi	r18, 0x01	; 1
    1cc6:	8e 32       	cpi	r24, 0x2E	; 46
    1cc8:	92 07       	cpc	r25, r18
    1cca:	09 f1       	breq	.+66     	; 0x1d0e <cpowercycle+0x8e>
    1ccc:	21 e0       	ldi	r18, 0x01	; 1
    1cce:	8d 33       	cpi	r24, 0x3D	; 61
    1cd0:	92 07       	cpc	r25, r18
    1cd2:	19 f0       	breq	.+6      	; 0x1cda <cpowercycle+0x5a>
    1cd4:	00 97       	sbiw	r24, 0x00	; 0
    1cd6:	09 f0       	breq	.+2      	; 0x1cda <cpowercycle+0x5a>
    1cd8:	43 c0       	rjmp	.+134    	; 0x1d60 <cpowercycle+0xe0>

  while(1) {
    /* Only wait for some cycles to pass for someone to start sending */
    if(someone_is_sending > 0) {
    1cda:	80 91 7f 06 	lds	r24, 0x067F
    1cde:	88 23       	and	r24, r24
    1ce0:	29 f0       	breq	.+10     	; 0x1cec <cpowercycle+0x6c>
      someone_is_sending--;
    1ce2:	80 91 7f 06 	lds	r24, 0x067F
    1ce6:	81 50       	subi	r24, 0x01	; 1
    1ce8:	80 93 7f 06 	sts	0x067F, r24
#endif /* CXMAC_CONF_COMPOWER */
}
static void
powercycle_turn_radio_on(void)
{
  if(we_are_sending == 0 &&
    1cec:	80 91 81 06 	lds	r24, 0x0681
    1cf0:	88 23       	and	r24, r24
    1cf2:	31 f4       	brne	.+12     	; 0x1d00 <cpowercycle+0x80>
     waiting_for_packet == 0) {
    1cf4:	80 91 80 06 	lds	r24, 0x0680
#endif /* CXMAC_CONF_COMPOWER */
}
static void
powercycle_turn_radio_on(void)
{
  if(we_are_sending == 0 &&
    1cf8:	88 23       	and	r24, r24
    1cfa:	11 f4       	brne	.+4      	; 0x1d00 <cpowercycle+0x80>
     waiting_for_packet == 0) {
    on();
    1cfc:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <on>
      someone_is_sending--;
    }

    /* If there were a strobe in the air, turn radio on */
    powercycle_turn_radio_on();
    CSCHEDULE_POWERCYCLE(DEFAULT_ON_TIME);
    1d00:	80 e0       	ldi	r24, 0x00	; 0
    1d02:	90 e0       	ldi	r25, 0x00	; 0
    1d04:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <cschedule_powercycle>
    PT_YIELD(&pt);
    1d08:	8e e2       	ldi	r24, 0x2E	; 46
    1d0a:	91 e0       	ldi	r25, 0x01	; 1
    1d0c:	1f c0       	rjmp	.+62     	; 0x1d4c <cpowercycle+0xcc>

    if(cxmac_config.off_time > 0) {
    1d0e:	80 91 d2 03 	lds	r24, 0x03D2
    1d12:	90 91 d3 03 	lds	r25, 0x03D3
    1d16:	00 97       	sbiw	r24, 0x00	; 0
    1d18:	01 f3       	breq	.-64     	; 0x1cda <cpowercycle+0x5a>
      powercycle_turn_radio_off();
    1d1a:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <powercycle_turn_radio_off>
      if(waiting_for_packet != 0) {
    1d1e:	80 91 80 06 	lds	r24, 0x0680
    1d22:	88 23       	and	r24, r24
    1d24:	69 f0       	breq	.+26     	; 0x1d40 <cpowercycle+0xc0>
	waiting_for_packet++;
    1d26:	80 91 80 06 	lds	r24, 0x0680
    1d2a:	8f 5f       	subi	r24, 0xFF	; 255
    1d2c:	80 93 80 06 	sts	0x0680, r24
	if(waiting_for_packet > 2) {
    1d30:	80 91 80 06 	lds	r24, 0x0680
    1d34:	83 30       	cpi	r24, 0x03	; 3
    1d36:	20 f0       	brcs	.+8      	; 0x1d40 <cpowercycle+0xc0>
	  /* We should not be awake for more than two consecutive
	     power cycles without having heard a packet, so we turn off
	     the radio. */
	  waiting_for_packet = 0;
    1d38:	10 92 80 06 	sts	0x0680, r1
	  powercycle_turn_radio_off();
    1d3c:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <powercycle_turn_radio_off>
	}
      }
      CSCHEDULE_POWERCYCLE(DEFAULT_OFF_TIME);
    1d40:	8f e0       	ldi	r24, 0x0F	; 15
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <cschedule_powercycle>
      PT_YIELD(&pt);
    1d48:	8d e3       	ldi	r24, 0x3D	; 61
    1d4a:	91 e0       	ldi	r25, 0x01	; 1
    1d4c:	90 93 7e 06 	sts	0x067E, r25
    1d50:	80 93 7d 06 	sts	0x067D, r24
    1d54:	81 eb       	ldi	r24, 0xB1	; 177
    1d56:	93 e0       	ldi	r25, 0x03	; 3
    1d58:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <puts>
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	08 95       	ret
    }
  }

  PT_END(&pt);
    1d60:	10 92 7e 06 	sts	0x067E, r1
    1d64:	10 92 7d 06 	sts	0x067D, r1
    1d68:	83 e0       	ldi	r24, 0x03	; 3
}
    1d6a:	08 95       	ret

00001d6c <input_packet>:
  }
}
/*---------------------------------------------------------------------------*/
static void
input_packet(void)
{
    1d6c:	ef 92       	push	r14
    1d6e:	ff 92       	push	r15
    1d70:	0f 93       	push	r16
    1d72:	1f 93       	push	r17
    1d74:	cf 93       	push	r28
    1d76:	df 93       	push	r29
  struct cxmac_hdr *hdr;

  if(NETSTACK_FRAMER.parse() >= 0) {
    1d78:	e0 91 0f 04 	lds	r30, 0x040F
    1d7c:	f0 91 10 04 	lds	r31, 0x0410
    1d80:	09 95       	icall
    1d82:	97 fd       	sbrc	r25, 7
    1d84:	7b c0       	rjmp	.+246    	; 0x1e7c <input_packet+0x110>
    hdr = packetbuf_dataptr();
    1d86:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    1d8a:	e8 2e       	mov	r14, r24
    1d8c:	e7 01       	movw	r28, r14
    1d8e:	7e 01       	movw	r14, r28
    1d90:	f9 2e       	mov	r15, r25
    1d92:	e7 01       	movw	r28, r14

    if(hdr->dispatch != DISPATCH) {
    1d94:	88 81       	ld	r24, Y
    1d96:	88 23       	and	r24, r24
    1d98:	49 f1       	breq	.+82     	; 0x1dec <input_packet+0x80>
      someone_is_sending = 0;
    1d9a:	10 92 7f 06 	sts	0x067F, r1
      if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    1d9e:	8d e6       	ldi	r24, 0x6D	; 109
    1da0:	9e e0       	ldi	r25, 0x0E	; 14
    1da2:	68 e1       	ldi	r22, 0x18	; 24
    1da4:	7e e0       	ldi	r23, 0x0E	; 14
    1da6:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    1daa:	00 97       	sbiw	r24, 0x00	; 0
    1dac:	49 f4       	brne	.+18     	; 0x1dc0 <input_packet+0x54>
                                     &rimeaddr_node_addr) ||
	 rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    1dae:	8d e6       	ldi	r24, 0x6D	; 109
    1db0:	9e e0       	ldi	r25, 0x0E	; 14
    1db2:	67 e8       	ldi	r22, 0x87	; 135
    1db4:	73 e0       	ldi	r23, 0x03	; 3
    1db6:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    hdr = packetbuf_dataptr();

    if(hdr->dispatch != DISPATCH) {
      someone_is_sending = 0;
      if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
                                     &rimeaddr_node_addr) ||
    1dba:	00 97       	sbiw	r24, 0x00	; 0
    1dbc:	09 f4       	brne	.+2      	; 0x1dc0 <input_packet+0x54>
    1dbe:	5e c0       	rjmp	.+188    	; 0x1e7c <input_packet+0x110>
	/* This is a regular packet that is destined to us or to the
	   broadcast address. */

	/* We have received the final packet, so we can go back to being
	   asleep. */
	off();
    1dc0:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <off>

#if CXMAC_CONF_COMPOWER
	/* Accumulate the power consumption for the packet reception. */
	compower_accumulate(&current_packet);
    1dc4:	83 e8       	ldi	r24, 0x83	; 131
    1dc6:	96 e0       	ldi	r25, 0x06	; 6
    1dc8:	0e 94 ed 15 	call	0x2bda	; 0x2bda <compower_accumulate>
	/* Convert the accumulated power consumption for the received
	   packet to packet attributes so that the higher levels can
	   keep track of the amount of energy spent on receiving the
	   packet. */
	compower_attrconv(&current_packet);
    1dcc:	83 e8       	ldi	r24, 0x83	; 131
    1dce:	96 e0       	ldi	r25, 0x06	; 6
    1dd0:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <compower_attrconv>

	/* Clear the accumulated power consumption so that it is ready
	   for the next packet. */
	compower_clear(&current_packet);
    1dd4:	83 e8       	ldi	r24, 0x83	; 131
    1dd6:	96 e0       	ldi	r25, 0x06	; 6
    1dd8:	0e 94 49 16 	call	0x2c92	; 0x2c92 <compower_clear>
#endif /* CXMAC_CONF_COMPOWER */

	waiting_for_packet = 0;
    1ddc:	10 92 80 06 	sts	0x0680, r1

        PRINTDEBUG("cxmac: data(%u)\n", packetbuf_datalen());
	NETSTACK_MAC.input();
    1de0:	e0 91 05 04 	lds	r30, 0x0405
    1de4:	f0 91 06 04 	lds	r31, 0x0406
    1de8:	09 95       	icall
        return;
    1dea:	48 c0       	rjmp	.+144    	; 0x1e7c <input_packet+0x110>
      } else {
        PRINTDEBUG("cxmac: data not for us\n");
      }

    } else if(hdr->type == TYPE_STROBE) {
    1dec:	89 81       	ldd	r24, Y+1	; 0x01
    1dee:	80 31       	cpi	r24, 0x10	; 16
    1df0:	09 f0       	breq	.+2      	; 0x1df4 <input_packet+0x88>
    1df2:	44 c0       	rjmp	.+136    	; 0x1e7c <input_packet+0x110>
      someone_is_sending = 2;
    1df4:	82 e0       	ldi	r24, 0x02	; 2
    1df6:	80 93 7f 06 	sts	0x067F, r24

      if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    1dfa:	8d e6       	ldi	r24, 0x6D	; 109
    1dfc:	9e e0       	ldi	r25, 0x0E	; 14
    1dfe:	68 e1       	ldi	r22, 0x18	; 24
    1e00:	7e e0       	ldi	r23, 0x0E	; 14
    1e02:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    1e06:	00 97       	sbiw	r24, 0x00	; 0
    1e08:	61 f1       	breq	.+88     	; 0x1e62 <input_packet+0xf6>

	/* If the sender address is someone else, we should
	   acknowledge the strobe and wait for the packet. By using
	   the same address as both sender and receiver, we flag the
	   message is a strobe ack. */
	hdr->type = TYPE_STROBE_ACK;
    1e0a:	83 e1       	ldi	r24, 0x13	; 19
    1e0c:	89 83       	std	Y+1, r24	; 0x01

static inline int
packetbuf_set_addr(uint8_t type, const rimeaddr_t *addr)
{
/*   packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].type = type; */
  rimeaddr_copy(&packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].addr, addr);
    1e0e:	8d e6       	ldi	r24, 0x6D	; 109
    1e10:	9e e0       	ldi	r25, 0x0E	; 14
    1e12:	6b e6       	ldi	r22, 0x6B	; 107
    1e14:	7e e0       	ldi	r23, 0x0E	; 14
    1e16:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    1e1a:	8b e6       	ldi	r24, 0x6B	; 107
    1e1c:	9e e0       	ldi	r25, 0x0E	; 14
    1e1e:	68 e1       	ldi	r22, 0x18	; 24
    1e20:	7e e0       	ldi	r23, 0x0E	; 14
    1e22:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
	packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER,
			   packetbuf_addr(PACKETBUF_ADDR_SENDER));
	packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &rimeaddr_node_addr);
	packetbuf_compact();
    1e26:	0e 94 32 1a 	call	0x3464	; 0x3464 <packetbuf_compact>
	if(NETSTACK_FRAMER.create() >= 0) {
    1e2a:	e0 91 0d 04 	lds	r30, 0x040D
    1e2e:	f0 91 0e 04 	lds	r31, 0x040E
    1e32:	09 95       	icall
    1e34:	97 fd       	sbrc	r25, 7
    1e36:	22 c0       	rjmp	.+68     	; 0x1e7c <input_packet+0x110>
	  /* We turn on the radio in anticipation of the incoming
	     packet. */
	  someone_is_sending = 1;
    1e38:	81 e0       	ldi	r24, 0x01	; 1
    1e3a:	80 93 7f 06 	sts	0x067F, r24
	  waiting_for_packet = 1;
    1e3e:	80 93 80 06 	sts	0x0680, r24
	  on();
    1e42:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <on>
	  NETSTACK_RADIO.send(packetbuf_hdrptr(), packetbuf_totlen());
    1e46:	c0 91 e6 05 	lds	r28, 0x05E6
    1e4a:	d0 91 e7 05 	lds	r29, 0x05E7
    1e4e:	0e 94 1d 1a 	call	0x343a	; 0x343a <packetbuf_hdrptr>
    1e52:	8c 01       	movw	r16, r24
    1e54:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <packetbuf_totlen>
    1e58:	bc 01       	movw	r22, r24
    1e5a:	c8 01       	movw	r24, r16
    1e5c:	fe 01       	movw	r30, r28
    1e5e:	09 95       	icall
    1e60:	0d c0       	rjmp	.+26     	; 0x1e7c <input_packet+0x110>
	  PRINTDEBUG("cxmac: send strobe ack %u\n", packetbuf_totlen());
	} else {
	  PRINTF("cxmac: failed to send strobe ack\n");
	}
      } else if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    1e62:	8d e6       	ldi	r24, 0x6D	; 109
    1e64:	9e e0       	ldi	r25, 0x0E	; 14
    1e66:	67 e8       	ldi	r22, 0x87	; 135
    1e68:	73 e0       	ldi	r23, 0x03	; 3
    1e6a:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    1e6e:	00 97       	sbiw	r24, 0x00	; 0
    1e70:	29 f0       	breq	.+10     	; 0x1e7c <input_packet+0x110>
                             &rimeaddr_null)) {
	/* If the receiver address is null, the strobe is sent to
	   prepare for an incoming broadcast packet. If this is the
	   case, we turn on the radio and wait for the incoming
	   broadcast packet. */
	waiting_for_packet = 1;
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	80 93 80 06 	sts	0x0680, r24
	on();
    1e78:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <on>
             packetbuf_datalen());
    }
  } else {
    PRINTF("cxmac: failed to parse (%u)\n", packetbuf_totlen());
  }
}
    1e7c:	df 91       	pop	r29
    1e7e:	cf 91       	pop	r28
    1e80:	1f 91       	pop	r17
    1e82:	0f 91       	pop	r16
    1e84:	ff 90       	pop	r15
    1e86:	ef 90       	pop	r14
    1e88:	08 95       	ret

00001e8a <qsend_packet>:

}
/*---------------------------------------------------------------------------*/
static void
qsend_packet(mac_callback_t sent, void *ptr)
{
    1e8a:	2f 92       	push	r2
    1e8c:	3f 92       	push	r3
    1e8e:	4f 92       	push	r4
    1e90:	5f 92       	push	r5
    1e92:	6f 92       	push	r6
    1e94:	7f 92       	push	r7
    1e96:	8f 92       	push	r8
    1e98:	9f 92       	push	r9
    1e9a:	bf 92       	push	r11
    1e9c:	cf 92       	push	r12
    1e9e:	df 92       	push	r13
    1ea0:	ef 92       	push	r14
    1ea2:	ff 92       	push	r15
    1ea4:	0f 93       	push	r16
    1ea6:	1f 93       	push	r17
    1ea8:	df 93       	push	r29
    1eaa:	cf 93       	push	r28
    1eac:	cd b7       	in	r28, 0x3d	; 61
    1eae:	de b7       	in	r29, 0x3e	; 62
    1eb0:	c0 54       	subi	r28, 0x40	; 64
    1eb2:	d0 40       	sbci	r29, 0x00	; 0
    1eb4:	0f b6       	in	r0, 0x3f	; 63
    1eb6:	f8 94       	cli
    1eb8:	de bf       	out	0x3e, r29	; 62
    1eba:	0f be       	out	0x3f, r0	; 63
    1ebc:	cd bf       	out	0x3d, r28	; 61
    1ebe:	9a af       	std	Y+58, r25	; 0x3a
    1ec0:	89 af       	std	Y+57, r24	; 0x39
    1ec2:	7c af       	std	Y+60, r23	; 0x3c
    1ec4:	6b af       	std	Y+59, r22	; 0x3b
  int ret;
  if(someone_is_sending) {
    1ec6:	80 91 7f 06 	lds	r24, 0x067F
    1eca:	88 23       	and	r24, r24
    1ecc:	a1 f0       	breq	.+40     	; 0x1ef6 <qsend_packet+0x6c>
    PRINTF("cxmac: should queue packet, now just dropping %d %d %d %d.\n",
	   waiting_for_packet, someone_is_sending, we_are_sending, radio_is_on);
    RIMESTATS_ADD(sendingdrop);
    1ece:	80 91 56 0e 	lds	r24, 0x0E56
    1ed2:	90 91 57 0e 	lds	r25, 0x0E57
    1ed6:	a0 91 58 0e 	lds	r26, 0x0E58
    1eda:	b0 91 59 0e 	lds	r27, 0x0E59
    1ede:	01 96       	adiw	r24, 0x01	; 1
    1ee0:	a1 1d       	adc	r26, r1
    1ee2:	b1 1d       	adc	r27, r1
    1ee4:	80 93 56 0e 	sts	0x0E56, r24
    1ee8:	90 93 57 0e 	sts	0x0E57, r25
    1eec:	a0 93 58 0e 	sts	0x0E58, r26
    1ef0:	b0 93 59 0e 	sts	0x0E59, r27
    1ef4:	0c c2       	rjmp	.+1048   	; 0x230e <qsend_packet+0x484>
    1ef6:	8b e6       	ldi	r24, 0x6B	; 107
    1ef8:	9e e0       	ldi	r25, 0x0E	; 14
    1efa:	68 e1       	ldi	r22, 0x18	; 24
    1efc:	7e e0       	ldi	r23, 0x0E	; 14
    1efe:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
  uint8_t collisions;


  /* Create the X-MAC header for the data packet. */
  packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &rimeaddr_node_addr);
  if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER), &rimeaddr_null)) {
    1f02:	8d e6       	ldi	r24, 0x6D	; 109
    1f04:	9e e0       	ldi	r25, 0x0E	; 14
    1f06:	67 e8       	ldi	r22, 0x87	; 135
    1f08:	73 e0       	ldi	r23, 0x03	; 3
    1f0a:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    1f0e:	2c 01       	movw	r4, r24
           packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[1]);
#endif /* UIP_CONF_IPV6 */
  }
/* is_reliable = packetbuf_attr(PACKETBUF_ATTR_RELIABLE) ||
    packetbuf_attr(PACKETBUF_ATTR_ERELIABLE);*/
  len = NETSTACK_FRAMER.create();
    1f10:	e0 91 0d 04 	lds	r30, 0x040D
    1f14:	f0 91 0e 04 	lds	r31, 0x040E
    1f18:	09 95       	icall
    1f1a:	7c 01       	movw	r14, r24
  strobe_len = len + sizeof(struct cxmac_hdr);
  if(len < 0 || strobe_len > (int)sizeof(strobe)) {
    1f1c:	97 fd       	sbrc	r25, 7
    1f1e:	fa c1       	rjmp	.+1012   	; 0x2314 <qsend_packet+0x48a>
#endif /* UIP_CONF_IPV6 */
  }
/* is_reliable = packetbuf_attr(PACKETBUF_ATTR_RELIABLE) ||
    packetbuf_attr(PACKETBUF_ATTR_ERELIABLE);*/
  len = NETSTACK_FRAMER.create();
  strobe_len = len + sizeof(struct cxmac_hdr);
    1f20:	9c 01       	movw	r18, r24
    1f22:	2e 5f       	subi	r18, 0xFE	; 254
    1f24:	3f 4f       	sbci	r19, 0xFF	; 255
    1f26:	3c ab       	std	Y+52, r19	; 0x34
    1f28:	2b ab       	std	Y+51, r18	; 0x33
  if(len < 0 || strobe_len > (int)sizeof(strobe)) {
    1f2a:	23 33       	cpi	r18, 0x33	; 51
    1f2c:	31 05       	cpc	r19, r1
    1f2e:	0c f0       	brlt	.+2      	; 0x1f32 <qsend_packet+0xa8>
    1f30:	f1 c1       	rjmp	.+994    	; 0x2314 <qsend_packet+0x48a>
    /* Failed to send */
   PRINTF("cxmac: send failed, too large header\n");
    return MAC_TX_ERR_FATAL;
  }
  memcpy(strobe, packetbuf_hdrptr(), len);
    1f32:	0e 94 1d 1a 	call	0x343a	; 0x343a <packetbuf_hdrptr>
    1f36:	bc 01       	movw	r22, r24
    1f38:	8e 01       	movw	r16, r28
    1f3a:	0f 5f       	subi	r16, 0xFF	; 255
    1f3c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f3e:	c8 01       	movw	r24, r16
    1f40:	a7 01       	movw	r20, r14
    1f42:	0e 94 e5 25 	call	0x4bca	; 0x4bca <memcpy>
  strobe[len] = DISPATCH; /* dispatch */
    1f46:	f8 01       	movw	r30, r16
    1f48:	ee 0d       	add	r30, r14
    1f4a:	ff 1d       	adc	r31, r15
    1f4c:	10 82       	st	Z, r1
  strobe[len + 1] = TYPE_STROBE; /* type */
    1f4e:	fe 01       	movw	r30, r28
    1f50:	ee 0d       	add	r30, r14
    1f52:	ff 1d       	adc	r31, r15
    1f54:	80 e1       	ldi	r24, 0x10	; 16
    1f56:	82 83       	std	Z+2, r24	; 0x02

  packetbuf_compact();
    1f58:	0e 94 32 1a 	call	0x3464	; 0x3464 <packetbuf_compact>
  packet = queuebuf_new_from_packetbuf();
    1f5c:	0e 94 4b 1b 	call	0x3696	; 0x3696 <queuebuf_new_from_packetbuf>
    1f60:	3c 01       	movw	r6, r24
  if(packet == NULL) {
    1f62:	00 97       	sbiw	r24, 0x00	; 0
    1f64:	09 f4       	brne	.+2      	; 0x1f68 <qsend_packet+0xde>
    1f66:	d9 c1       	rjmp	.+946    	; 0x231a <qsend_packet+0x490>
           QUEUEBUF_CONF_NUM);
    return MAC_TX_ERR;
  }

#if WITH_STREAMING
  if(is_streaming == 1 &&
    1f68:	80 91 76 06 	lds	r24, 0x0676
    1f6c:	81 30       	cpi	r24, 0x01	; 1
    1f6e:	81 f4       	brne	.+32     	; 0x1f90 <qsend_packet+0x106>
     (rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    1f70:	8d e6       	ldi	r24, 0x6D	; 109
    1f72:	9e e0       	ldi	r25, 0x0E	; 14
    1f74:	69 e7       	ldi	r22, 0x79	; 121
    1f76:	76 e0       	ldi	r23, 0x06	; 6
    1f78:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
           QUEUEBUF_CONF_NUM);
    return MAC_TX_ERR;
  }

#if WITH_STREAMING
  if(is_streaming == 1 &&
    1f7c:	00 97       	sbiw	r24, 0x00	; 0
    1f7e:	59 f4       	brne	.+22     	; 0x1f96 <qsend_packet+0x10c>
     (rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
		   &is_streaming_to) ||
      rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    1f80:	8d e6       	ldi	r24, 0x6D	; 109
    1f82:	9e e0       	ldi	r25, 0x0E	; 14
    1f84:	6b e7       	ldi	r22, 0x7B	; 123
    1f86:	76 e0       	ldi	r23, 0x06	; 6
    1f88:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
  }

#if WITH_STREAMING
  if(is_streaming == 1 &&
     (rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
		   &is_streaming_to) ||
    1f8c:	00 97       	sbiw	r24, 0x00	; 0
    1f8e:	19 f4       	brne	.+6      	; 0x1f96 <qsend_packet+0x10c>
  int is_broadcast = 0;
  int is_dispatch, is_strobe_ack;
  /*int is_reliable;*/
  struct encounter *e;
  struct queuebuf *packet;
  int is_already_streaming = 0;
    1f90:	ee 24       	eor	r14, r14
    1f92:	ff 24       	eor	r15, r15
    1f94:	03 c0       	rjmp	.+6      	; 0x1f9c <qsend_packet+0x112>
  if(is_streaming == 1 &&
     (rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
		   &is_streaming_to) ||
      rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
		   &is_streaming_to_too))) {
    is_already_streaming = 1;
    1f96:	41 e0       	ldi	r20, 0x01	; 1
    1f98:	e4 2e       	mov	r14, r20
    1f9a:	f1 2c       	mov	r15, r1
  }
  if(packetbuf_attr(PACKETBUF_ATTR_PACKET_TYPE) ==
    1f9c:	80 91 8f 0e 	lds	r24, 0x0E8F
    1fa0:	90 91 90 0e 	lds	r25, 0x0E90
    1fa4:	82 30       	cpi	r24, 0x02	; 2
    1fa6:	91 05       	cpc	r25, r1
    1fa8:	31 f5       	brne	.+76     	; 0x1ff6 <qsend_packet+0x16c>
     PACKETBUF_ATTR_PACKET_TYPE_STREAM) {
    is_streaming = 1;
    1faa:	81 e0       	ldi	r24, 0x01	; 1
    1fac:	80 93 76 06 	sts	0x0676, r24
    if(rimeaddr_cmp(&is_streaming_to, &rimeaddr_null)) {
    1fb0:	89 e7       	ldi	r24, 0x79	; 121
    1fb2:	96 e0       	ldi	r25, 0x06	; 6
    1fb4:	67 e8       	ldi	r22, 0x87	; 135
    1fb6:	73 e0       	ldi	r23, 0x03	; 3
    1fb8:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    1fbc:	00 97       	sbiw	r24, 0x00	; 0
    1fbe:	19 f0       	breq	.+6      	; 0x1fc6 <qsend_packet+0x13c>
      rimeaddr_copy(&is_streaming_to, packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
    1fc0:	89 e7       	ldi	r24, 0x79	; 121
    1fc2:	96 e0       	ldi	r25, 0x06	; 6
    1fc4:	0a c0       	rjmp	.+20     	; 0x1fda <qsend_packet+0x150>
    } else if(!rimeaddr_cmp(&is_streaming_to, packetbuf_addr(PACKETBUF_ADDR_RECEIVER))) {
    1fc6:	89 e7       	ldi	r24, 0x79	; 121
    1fc8:	96 e0       	ldi	r25, 0x06	; 6
    1fca:	6d e6       	ldi	r22, 0x6D	; 109
    1fcc:	7e e0       	ldi	r23, 0x0E	; 14
    1fce:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    1fd2:	00 97       	sbiw	r24, 0x00	; 0
    1fd4:	31 f4       	brne	.+12     	; 0x1fe2 <qsend_packet+0x158>
      rimeaddr_copy(&is_streaming_to_too, packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
    1fd6:	8b e7       	ldi	r24, 0x7B	; 123
    1fd8:	96 e0       	ldi	r25, 0x06	; 6
    1fda:	6d e6       	ldi	r22, 0x6D	; 109
    1fdc:	7e e0       	ldi	r23, 0x0E	; 14
    1fde:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    }
    stream_until = RTIMER_NOW() + DEFAULT_STREAM_TIME;
    1fe2:	80 91 88 00 	lds	r24, 0x0088
    1fe6:	90 91 89 00 	lds	r25, 0x0089
    1fea:	80 5e       	subi	r24, 0xE0	; 224
    1fec:	93 4e       	sbci	r25, 0xE3	; 227
    1fee:	90 93 78 06 	sts	0x0678, r25
    1ff2:	80 93 77 06 	sts	0x0677, r24
  }
#endif /* WITH_STREAMING */

  off();
    1ff6:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <off>
#if WITH_ENCOUNTER_OPTIMIZATION
  /* We go through the list of encounters to find if we have recorded
     an encounter with this particular neighbor. If so, we can compute
     the time for the next expected encounter and setup a ctimer to
     switch on the radio just before the encounter. */
  for(e = list_head(encounter_list); e != NULL; e = list_item_next(e)) {
    1ffa:	8b e8       	ldi	r24, 0x8B	; 139
    1ffc:	96 e0       	ldi	r25, 0x06	; 6
    1ffe:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
    2002:	08 2f       	mov	r16, r24
    2004:	19 2f       	mov	r17, r25
	 with clock_time(). Because we are only interested in turning
	 on the radio within the DEFAULT_PERIOD period, we compute the
	 waiting time with modulo DEFAULT_PERIOD. */

      now = RTIMER_NOW();
      wait = ((rtimer_clock_t)(e->time - now)) % (DEFAULT_PERIOD);
    2006:	34 e8       	ldi	r19, 0x84	; 132
    2008:	c3 2e       	mov	r12, r19
    200a:	33 e0       	ldi	r19, 0x03	; 3
    200c:	d3 2e       	mov	r13, r19
    200e:	32 c0       	rjmp	.+100    	; 0x2074 <qsend_packet+0x1ea>
     the time for the next expected encounter and setup a ctimer to
     switch on the radio just before the encounter. */
  for(e = list_head(encounter_list); e != NULL; e = list_item_next(e)) {
    const rimeaddr_t *neighbor = packetbuf_addr(PACKETBUF_ADDR_RECEIVER);

    if(rimeaddr_cmp(neighbor, &e->neighbor)) {
    2010:	b8 01       	movw	r22, r16
    2012:	6e 5f       	subi	r22, 0xFE	; 254
    2014:	7f 4f       	sbci	r23, 0xFF	; 255
    2016:	8d e6       	ldi	r24, 0x6D	; 109
    2018:	9e e0       	ldi	r25, 0x0E	; 14
    201a:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    201e:	00 97       	sbiw	r24, 0x00	; 0
    2020:	21 f1       	breq	.+72     	; 0x206a <qsend_packet+0x1e0>
	 DEFAULT_PERIOD. To compute a relative offset, we subtract
	 with clock_time(). Because we are only interested in turning
	 on the radio within the DEFAULT_PERIOD period, we compute the
	 waiting time with modulo DEFAULT_PERIOD. */

      now = RTIMER_NOW();
    2022:	40 91 88 00 	lds	r20, 0x0088
    2026:	50 91 89 00 	lds	r21, 0x0089
      wait = ((rtimer_clock_t)(e->time - now)) % (DEFAULT_PERIOD);
      expected = now + wait - 2 * DEFAULT_ON_TIME;
    202a:	9a 01       	movw	r18, r20
    202c:	2a 55       	subi	r18, 0x5A	; 90
    202e:	30 40       	sbci	r19, 0x00	; 0
	 with clock_time(). Because we are only interested in turning
	 on the radio within the DEFAULT_PERIOD period, we compute the
	 waiting time with modulo DEFAULT_PERIOD. */

      now = RTIMER_NOW();
      wait = ((rtimer_clock_t)(e->time - now)) % (DEFAULT_PERIOD);
    2030:	f8 01       	movw	r30, r16
    2032:	84 81       	ldd	r24, Z+4	; 0x04
    2034:	95 81       	ldd	r25, Z+5	; 0x05
    2036:	84 1b       	sub	r24, r20
    2038:	95 0b       	sbc	r25, r21
    203a:	b6 01       	movw	r22, r12
    203c:	0e 94 73 25 	call	0x4ae6	; 0x4ae6 <__udivmodhi4>
      expected = now + wait - 2 * DEFAULT_ON_TIME;
    2040:	28 0f       	add	r18, r24
    2042:	39 1f       	adc	r19, r25

#if WITH_ACK_OPTIMIZATION
      /* Wait until the receiver is expected to be awake */
      if(packetbuf_attr(PACKETBUF_ATTR_PACKET_TYPE) !=
    2044:	80 91 8f 0e 	lds	r24, 0x0E8F
    2048:	90 91 90 0e 	lds	r25, 0x0E90
    204c:	81 30       	cpi	r24, 0x01	; 1
    204e:	91 05       	cpc	r25, r1
    2050:	61 f0       	breq	.+24     	; 0x206a <qsend_packet+0x1e0>
	 PACKETBUF_ATTR_PACKET_TYPE_ACK &&
    2052:	80 91 76 06 	lds	r24, 0x0676
    2056:	88 23       	and	r24, r24
    2058:	41 f4       	brne	.+16     	; 0x206a <qsend_packet+0x1e0>
	 is_streaming == 0) {
	/* Do not wait if we are sending an ACK, because then the
	   receiver will already be awake. */
	while(RTIMER_CLOCK_LT(RTIMER_NOW(), expected));
    205a:	80 91 88 00 	lds	r24, 0x0088
    205e:	90 91 89 00 	lds	r25, 0x0089
    2062:	82 1b       	sub	r24, r18
    2064:	93 0b       	sbc	r25, r19
    2066:	97 fd       	sbrc	r25, 7
    2068:	f8 cf       	rjmp	.-16     	; 0x205a <qsend_packet+0x1d0>
#if WITH_ENCOUNTER_OPTIMIZATION
  /* We go through the list of encounters to find if we have recorded
     an encounter with this particular neighbor. If so, we can compute
     the time for the next expected encounter and setup a ctimer to
     switch on the radio just before the encounter. */
  for(e = list_head(encounter_list); e != NULL; e = list_item_next(e)) {
    206a:	c8 01       	movw	r24, r16
    206c:	0e 94 31 18 	call	0x3062	; 0x3062 <list_item_next>
    2070:	08 2f       	mov	r16, r24
    2072:	19 2f       	mov	r17, r25
    2074:	01 15       	cp	r16, r1
    2076:	11 05       	cpc	r17, r1
    2078:	59 f6       	brne	.-106    	; 0x2010 <qsend_packet+0x186>
  int strobes;
  struct cxmac_hdr *hdr;
  int got_strobe_ack = 0;
  uint8_t strobe[MAX_STROBE_SIZE];
  int strobe_len, len;
  int is_broadcast = 0;
    207a:	21 e0       	ldi	r18, 0x01	; 1
    207c:	82 2e       	mov	r8, r18
    207e:	91 2c       	mov	r9, r1
    2080:	41 14       	cp	r4, r1
    2082:	51 04       	cpc	r5, r1
    2084:	11 f4       	brne	.+4      	; 0x208a <qsend_packet+0x200>
    2086:	88 24       	eor	r8, r8
    2088:	99 24       	eor	r9, r9
  }
#endif /* WITH_ENCOUNTER_OPTIMIZATION */

  /* By setting we_are_sending to one, we ensure that the rtimer
     powercycle interrupt do not interfere with us sending the packet. */
  we_are_sending = 1;
    208a:	81 e0       	ldi	r24, 0x01	; 1
    208c:	80 93 81 06 	sts	0x0681, r24
  
  t0 = RTIMER_NOW();
    2090:	20 91 88 00 	lds	r18, 0x0088
    2094:	30 91 89 00 	lds	r19, 0x0089
    2098:	38 af       	std	Y+56, r19	; 0x38
    209a:	2f ab       	std	Y+55, r18	; 0x37
  LEDS_ON(LEDS_BLUE);

  /* Send a train of strobes until the receiver answers with an ACK. */

  /* Turn on the radio to listen for the strobe ACK. */
  on();
    209c:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <on>
  collisions = 0;
  if(!is_already_streaming) {
    20a0:	e1 14       	cp	r14, r1
    20a2:	f1 04       	cpc	r15, r1
    20a4:	09 f0       	breq	.+2      	; 0x20a8 <qsend_packet+0x21e>
    20a6:	a2 c0       	rjmp	.+324    	; 0x21ec <qsend_packet+0x362>
    watchdog_stop();
    20a8:	0e 94 2d 23 	call	0x465a	; 0x465a <watchdog_stop>
    got_strobe_ack = 0;
    t = RTIMER_NOW();
    20ac:	40 90 88 00 	lds	r4, 0x0088
    20b0:	50 90 89 00 	lds	r5, 0x0089
static int
send_packet(void)
{
  rtimer_clock_t t0;
  rtimer_clock_t t;
  rtimer_clock_t encounter_time = 0;
    20b4:	ee 24       	eor	r14, r14
    20b6:	ff 24       	eor	r15, r15
	    RTIMER_CLOCK_LT(RTIMER_NOW(), t + cxmac_config.strobe_wait_time)) {
	rtimer_clock_t now = RTIMER_NOW();

	/* See if we got an ACK */
	packetbuf_clear();
	len = NETSTACK_RADIO.read(packetbuf_dataptr(), PACKETBUF_SIZE);
    20b8:	40 91 e8 05 	lds	r20, 0x05E8
    20bc:	50 91 e9 05 	lds	r21, 0x05E9
    20c0:	5e af       	std	Y+62, r21	; 0x3e
    20c2:	4d af       	std	Y+61, r20	; 0x3d
	if(len > 0) {
	  packetbuf_set_datalen(len);
	  if(NETSTACK_FRAMER.parse() >= 0) {
    20c4:	80 91 0f 04 	lds	r24, 0x040F
    20c8:	90 91 10 04 	lds	r25, 0x0410
    20cc:	21 96       	adiw	r28, 0x01	; 1
    20ce:	9f af       	std	Y+63, r25	; 0x3f
    20d0:	8e af       	std	Y+62, r24	; 0x3e
    20d2:	21 97       	sbiw	r28, 0x01	; 1
    20d4:	e0 91 e6 05 	lds	r30, 0x05E6
    20d8:	f0 91 e7 05 	lds	r31, 0x05E7
    20dc:	fe ab       	std	Y+54, r31	; 0x36
    20de:	ed ab       	std	Y+53, r30	; 0x35
	  queuebuf_to_packetbuf(packet);
	  NETSTACK_RADIO.send(packetbuf_hdrptr(), packetbuf_totlen());
#endif
	  off();
	} else {
	  NETSTACK_RADIO.send(strobe, strobe_len);
    20e0:	1e 01       	movw	r2, r28
    20e2:	08 94       	sec
    20e4:	21 1c       	adc	r2, r1
    20e6:	31 1c       	adc	r3, r1
    20e8:	6d c0       	rjmp	.+218    	; 0x21c4 <qsend_packet+0x33a>
	  RTIMER_CLOCK_LT(RTIMER_NOW(), t0 + cxmac_config.strobe_time);
	strobes++) {

      while(got_strobe_ack == 0 &&
	    RTIMER_CLOCK_LT(RTIMER_NOW(), t + cxmac_config.strobe_wait_time)) {
	rtimer_clock_t now = RTIMER_NOW();
    20ea:	c0 90 88 00 	lds	r12, 0x0088
    20ee:	d0 90 89 00 	lds	r13, 0x0089

	/* See if we got an ACK */
	packetbuf_clear();
    20f2:	0e 94 b8 1a 	call	0x3570	; 0x3570 <packetbuf_clear>
	len = NETSTACK_RADIO.read(packetbuf_dataptr(), PACKETBUF_SIZE);
    20f6:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    20fa:	60 e8       	ldi	r22, 0x80	; 128
    20fc:	70 e0       	ldi	r23, 0x00	; 0
    20fe:	2d ad       	ldd	r18, Y+61	; 0x3d
    2100:	3e ad       	ldd	r19, Y+62	; 0x3e
    2102:	f9 01       	movw	r30, r18
    2104:	09 95       	icall
	if(len > 0) {
    2106:	18 16       	cp	r1, r24
    2108:	19 06       	cpc	r1, r25
    210a:	2c f5       	brge	.+74     	; 0x2156 <qsend_packet+0x2cc>
	  packetbuf_set_datalen(len);
    210c:	0e 94 10 1a 	call	0x3420	; 0x3420 <packetbuf_set_datalen>
	  if(NETSTACK_FRAMER.parse() >= 0) {
    2110:	21 96       	adiw	r28, 0x01	; 1
    2112:	4e ad       	ldd	r20, Y+62	; 0x3e
    2114:	5f ad       	ldd	r21, Y+63	; 0x3f
    2116:	21 97       	sbiw	r28, 0x01	; 1
    2118:	fa 01       	movw	r30, r20
    211a:	09 95       	icall
    211c:	97 fd       	sbrc	r25, 7
    211e:	1b c0       	rjmp	.+54     	; 0x2156 <qsend_packet+0x2cc>
	    hdr = packetbuf_dataptr();
    2120:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    2124:	fc 01       	movw	r30, r24
	    is_dispatch = hdr->dispatch == DISPATCH;
	    is_strobe_ack = hdr->type == TYPE_STROBE_ACK;
    2126:	81 81       	ldd	r24, Z+1	; 0x01
	    if(is_dispatch && is_strobe_ack) {
    2128:	90 81       	ld	r25, Z
    212a:	99 23       	and	r25, r25
    212c:	59 f4       	brne	.+22     	; 0x2144 <qsend_packet+0x2ba>
    212e:	83 31       	cpi	r24, 0x13	; 19
    2130:	49 f4       	brne	.+18     	; 0x2144 <qsend_packet+0x2ba>
	      if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    2132:	8d e6       	ldi	r24, 0x6D	; 109
    2134:	9e e0       	ldi	r25, 0x0E	; 14
    2136:	68 e1       	ldi	r22, 0x18	; 24
    2138:	7e e0       	ldi	r23, 0x0E	; 14
    213a:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    213e:	00 97       	sbiw	r24, 0x00	; 0
    2140:	21 f4       	brne	.+8      	; 0x214a <qsend_packet+0x2c0>
    2142:	01 c0       	rjmp	.+2      	; 0x2146 <qsend_packet+0x2bc>
	      } else {
		PRINTDEBUG("cxmac: strobe ack for someone else\n");
	      }
	    } else /*if(hdr->dispatch == DISPATCH && hdr->type == TYPE_STROBE)*/ {
	      PRINTDEBUG("cxmac: strobe from someone else\n");
	      collisions++;
    2144:	b3 94       	inc	r11
    2146:	67 01       	movw	r12, r14
    2148:	02 c0       	rjmp	.+4      	; 0x214e <qsend_packet+0x2c4>
	    if(is_dispatch && is_strobe_ack) {
	      if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
			      &rimeaddr_node_addr)) {
		/* We got an ACK from the receiver, so we can immediately send
		   the packet. */
		got_strobe_ack = 1;
    214a:	01 e0       	ldi	r16, 0x01	; 1
    214c:	10 e0       	ldi	r17, 0x00	; 0
    214e:	76 01       	movw	r14, r12
    for(strobes = 0, collisions = 0;
	got_strobe_ack == 0 && collisions == 0 &&
	  RTIMER_CLOCK_LT(RTIMER_NOW(), t0 + cxmac_config.strobe_time);
	strobes++) {

      while(got_strobe_ack == 0 &&
    2150:	01 15       	cp	r16, r1
    2152:	11 05       	cpc	r17, r1
    2154:	79 f4       	brne	.+30     	; 0x2174 <qsend_packet+0x2ea>
	    RTIMER_CLOCK_LT(RTIMER_NOW(), t + cxmac_config.strobe_wait_time)) {
    2156:	80 91 88 00 	lds	r24, 0x0088
    215a:	90 91 89 00 	lds	r25, 0x0089
    215e:	20 91 d6 03 	lds	r18, 0x03D6
    2162:	30 91 d7 03 	lds	r19, 0x03D7
    2166:	82 1b       	sub	r24, r18
    2168:	93 0b       	sbc	r25, r19
    216a:	84 19       	sub	r24, r4
    216c:	95 09       	sbc	r25, r5
    for(strobes = 0, collisions = 0;
	got_strobe_ack == 0 && collisions == 0 &&
	  RTIMER_CLOCK_LT(RTIMER_NOW(), t0 + cxmac_config.strobe_time);
	strobes++) {

      while(got_strobe_ack == 0 &&
    216e:	97 fd       	sbrc	r25, 7
    2170:	bc cf       	rjmp	.-136    	; 0x20ea <qsend_packet+0x260>
    2172:	02 c0       	rjmp	.+4      	; 0x2178 <qsend_packet+0x2ee>
    2174:	01 e0       	ldi	r16, 0x01	; 1
    2176:	10 e0       	ldi	r17, 0x00	; 0
	    PRINTF("cxmac: send failed to parse %u\n", len);
	  }
	}
      }

      t = RTIMER_NOW();
    2178:	40 90 88 00 	lds	r4, 0x0088
    217c:	50 90 89 00 	lds	r5, 0x0089
      /* Send the strobe packet. */
      if(got_strobe_ack == 0 && collisions == 0) {
    2180:	01 15       	cp	r16, r1
    2182:	11 05       	cpc	r17, r1
    2184:	09 f0       	breq	.+2      	; 0x2188 <qsend_packet+0x2fe>
    2186:	f2 c0       	rjmp	.+484    	; 0x236c <qsend_packet+0x4e2>
    2188:	bb 20       	and	r11, r11
    218a:	a9 f5       	brne	.+106    	; 0x21f6 <qsend_packet+0x36c>
	if(is_broadcast) {
    218c:	81 14       	cp	r8, r1
    218e:	91 04       	cpc	r9, r1
    2190:	81 f0       	breq	.+32     	; 0x21b2 <qsend_packet+0x328>
#if WITH_STROBE_BROADCAST
	  NETSTACK_RADIO.send(strobe, strobe_len);
#else
	  /* restore the packet to send */
	  queuebuf_to_packetbuf(packet);
    2192:	c3 01       	movw	r24, r6
    2194:	0e 94 c7 1b 	call	0x378e	; 0x378e <queuebuf_to_packetbuf>
	  NETSTACK_RADIO.send(packetbuf_hdrptr(), packetbuf_totlen());
    2198:	0e 94 1d 1a 	call	0x343a	; 0x343a <packetbuf_hdrptr>
    219c:	8c 01       	movw	r16, r24
    219e:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <packetbuf_totlen>
    21a2:	bc 01       	movw	r22, r24
    21a4:	c8 01       	movw	r24, r16
    21a6:	ed a9       	ldd	r30, Y+53	; 0x35
    21a8:	fe a9       	ldd	r31, Y+54	; 0x36
    21aa:	09 95       	icall
#endif
	  off();
    21ac:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <off>
    21b0:	09 c0       	rjmp	.+18     	; 0x21c4 <qsend_packet+0x33a>
	} else {
	  NETSTACK_RADIO.send(strobe, strobe_len);
    21b2:	c1 01       	movw	r24, r2
    21b4:	6b a9       	ldd	r22, Y+51	; 0x33
    21b6:	7c a9       	ldd	r23, Y+52	; 0x34
    21b8:	2d a9       	ldd	r18, Y+53	; 0x35
    21ba:	3e a9       	ldd	r19, Y+54	; 0x36
    21bc:	f9 01       	movw	r30, r18
    21be:	09 95       	icall
	     that the other side needs some time to produce a reply. */
	  off();
	  rtimer_clock_t wt = RTIMER_NOW();
	  while(RTIMER_CLOCK_LT(RTIMER_NOW(), wt + WAIT_TIME_BEFORE_STROBE_ACK));
#endif /* 0 */
	  on();
    21c0:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <on>
    watchdog_stop();
    got_strobe_ack = 0;
    t = RTIMER_NOW();
    for(strobes = 0, collisions = 0;
	got_strobe_ack == 0 && collisions == 0 &&
	  RTIMER_CLOCK_LT(RTIMER_NOW(), t0 + cxmac_config.strobe_time);
    21c4:	80 91 88 00 	lds	r24, 0x0088
    21c8:	90 91 89 00 	lds	r25, 0x0089
  }

}
/*---------------------------------------------------------------------------*/
static void
qsend_packet(mac_callback_t sent, void *ptr)
    21cc:	20 91 d4 03 	lds	r18, 0x03D4
    21d0:	30 91 d5 03 	lds	r19, 0x03D5
    watchdog_stop();
    got_strobe_ack = 0;
    t = RTIMER_NOW();
    for(strobes = 0, collisions = 0;
	got_strobe_ack == 0 && collisions == 0 &&
	  RTIMER_CLOCK_LT(RTIMER_NOW(), t0 + cxmac_config.strobe_time);
    21d4:	4f a9       	ldd	r20, Y+55	; 0x37
    21d6:	58 ad       	ldd	r21, Y+56	; 0x38
    21d8:	84 1b       	sub	r24, r20
    21da:	95 0b       	sbc	r25, r21
    21dc:	82 1b       	sub	r24, r18
    21de:	93 0b       	sbc	r25, r19
  if(!is_already_streaming) {
    watchdog_stop();
    got_strobe_ack = 0;
    t = RTIMER_NOW();
    for(strobes = 0, collisions = 0;
	got_strobe_ack == 0 && collisions == 0 &&
    21e0:	97 ff       	sbrs	r25, 7
    21e2:	08 c0       	rjmp	.+16     	; 0x21f4 <qsend_packet+0x36a>
    21e4:	bb 24       	eor	r11, r11
    21e6:	00 e0       	ldi	r16, 0x00	; 0
    21e8:	10 e0       	ldi	r17, 0x00	; 0
    21ea:	b2 cf       	rjmp	.-156    	; 0x2150 <qsend_packet+0x2c6>

  /* Send a train of strobes until the receiver answers with an ACK. */

  /* Turn on the radio to listen for the strobe ACK. */
  on();
  collisions = 0;
    21ec:	bb 24       	eor	r11, r11
static int
send_packet(void)
{
  rtimer_clock_t t0;
  rtimer_clock_t t;
  rtimer_clock_t encounter_time = 0;
    21ee:	ee 24       	eor	r14, r14
    21f0:	ff 24       	eor	r15, r15
    21f2:	01 c0       	rjmp	.+2      	; 0x21f6 <qsend_packet+0x36c>
  if(!is_already_streaming) {
    watchdog_stop();
    got_strobe_ack = 0;
    t = RTIMER_NOW();
    for(strobes = 0, collisions = 0;
	got_strobe_ack == 0 && collisions == 0 &&
    21f4:	bb 24       	eor	r11, r11
    21f6:	cc 24       	eor	r12, r12
    21f8:	dd 24       	eor	r13, r13
    21fa:	19 c0       	rjmp	.+50     	; 0x222e <qsend_packet+0x3a4>

#if WITH_ACK_OPTIMIZATION
  /* If we have received the strobe ACK, and we are sending a packet
     that will need an upper layer ACK (as signified by the
     PACKETBUF_ATTR_RELIABLE packet attribute), we keep the radio on. */
  if(got_strobe_ack && (packetbuf_attr(PACKETBUF_ATTR_RELIABLE) ||
    21fc:	80 91 a1 0e 	lds	r24, 0x0EA1
    2200:	90 91 a2 0e 	lds	r25, 0x0EA2
    2204:	00 97       	sbiw	r24, 0x00	; 0
    2206:	39 f4       	brne	.+14     	; 0x2216 <qsend_packet+0x38c>
			packetbuf_attr(PACKETBUF_ATTR_ERELIABLE) ||
    2208:	80 91 8f 0e 	lds	r24, 0x0E8F
    220c:	90 91 90 0e 	lds	r25, 0x0E90
    2210:	82 30       	cpi	r24, 0x02	; 2
    2212:	91 05       	cpc	r25, r1
    2214:	49 f4       	brne	.+18     	; 0x2228 <qsend_packet+0x39e>
			packetbuf_attr(PACKETBUF_ATTR_PACKET_TYPE) ==
			PACKETBUF_ATTR_PACKET_TYPE_STREAM)) {
    on(); /* Wait for ACK packet */
    2216:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <on>
    waiting_for_packet = 1;
    221a:	81 e0       	ldi	r24, 0x01	; 1
    221c:	80 93 80 06 	sts	0x0680, r24
    2220:	91 e0       	ldi	r25, 0x01	; 1
    2222:	c9 2e       	mov	r12, r25
    2224:	d1 2c       	mov	r13, r1
    2226:	05 c0       	rjmp	.+10     	; 0x2232 <qsend_packet+0x3a8>
#if WITH_ACK_OPTIMIZATION
  /* If we have received the strobe ACK, and we are sending a packet
     that will need an upper layer ACK (as signified by the
     PACKETBUF_ATTR_RELIABLE packet attribute), we keep the radio on. */
  if(got_strobe_ack && (packetbuf_attr(PACKETBUF_ATTR_RELIABLE) ||
			packetbuf_attr(PACKETBUF_ATTR_ERELIABLE) ||
    2228:	81 e0       	ldi	r24, 0x01	; 1
    222a:	c8 2e       	mov	r12, r24
    222c:	d1 2c       	mov	r13, r1
			packetbuf_attr(PACKETBUF_ATTR_PACKET_TYPE) ==
			PACKETBUF_ATTR_PACKET_TYPE_STREAM)) {
    on(); /* Wait for ACK packet */
    waiting_for_packet = 1;
  } else {
    off();
    222e:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <off>
#else /* WITH_ACK_OPTIMIZATION */
  off();
#endif /* WITH_ACK_OPTIMIZATION */

  /* restore the packet to send */
  queuebuf_to_packetbuf(packet);
    2232:	c3 01       	movw	r24, r6
    2234:	0e 94 c7 1b 	call	0x378e	; 0x378e <queuebuf_to_packetbuf>
  queuebuf_free(packet);
    2238:	c3 01       	movw	r24, r6
    223a:	0e 94 a5 1b 	call	0x374a	; 0x374a <queuebuf_free>

  /* Send the data packet. */
  if((is_broadcast || got_strobe_ack || is_streaming) && collisions == 0) {
    223e:	81 14       	cp	r8, r1
    2240:	91 04       	cpc	r9, r1
    2242:	41 f4       	brne	.+16     	; 0x2254 <qsend_packet+0x3ca>
    2244:	c1 14       	cp	r12, r1
    2246:	d1 04       	cpc	r13, r1
    2248:	29 f4       	brne	.+10     	; 0x2254 <qsend_packet+0x3ca>
    224a:	80 91 76 06 	lds	r24, 0x0676
    224e:	88 23       	and	r24, r24
    2250:	09 f4       	brne	.+2      	; 0x2254 <qsend_packet+0x3ca>
    2252:	3f c0       	rjmp	.+126    	; 0x22d2 <qsend_packet+0x448>
    2254:	bb 20       	and	r11, r11
    2256:	69 f4       	brne	.+26     	; 0x2272 <qsend_packet+0x3e8>
    NETSTACK_RADIO.send(packetbuf_hdrptr(), packetbuf_totlen());
    2258:	60 90 e6 05 	lds	r6, 0x05E6
    225c:	70 90 e7 05 	lds	r7, 0x05E7
    2260:	0e 94 1d 1a 	call	0x343a	; 0x343a <packetbuf_hdrptr>
    2264:	8c 01       	movw	r16, r24
    2266:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <packetbuf_totlen>
    226a:	bc 01       	movw	r22, r24
    226c:	c8 01       	movw	r24, r16
    226e:	f3 01       	movw	r30, r6
    2270:	09 95       	icall
  }

#if WITH_ENCOUNTER_OPTIMIZATION
  if(got_strobe_ack && !is_streaming) {
    2272:	c1 14       	cp	r12, r1
    2274:	d1 04       	cpc	r13, r1
    2276:	69 f1       	breq	.+90     	; 0x22d2 <qsend_packet+0x448>
    2278:	80 91 76 06 	lds	r24, 0x0676
    227c:	88 23       	and	r24, r24
    227e:	49 f5       	brne	.+82     	; 0x22d2 <qsend_packet+0x448>
register_encounter(const rimeaddr_t *neighbor, rtimer_clock_t time)
{
  struct encounter *e;

  /* If we have an entry for this neighbor already, we renew it. */
  for(e = list_head(encounter_list); e != NULL; e = list_item_next(e)) {
    2280:	8b e8       	ldi	r24, 0x8B	; 139
    2282:	96 e0       	ldi	r25, 0x06	; 6
    2284:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
    2288:	10 c0       	rjmp	.+32     	; 0x22aa <qsend_packet+0x420>
    if(rimeaddr_cmp(neighbor, &e->neighbor)) {
    228a:	b8 01       	movw	r22, r16
    228c:	6e 5f       	subi	r22, 0xFE	; 254
    228e:	7f 4f       	sbci	r23, 0xFF	; 255
    2290:	8d e6       	ldi	r24, 0x6D	; 109
    2292:	9e e0       	ldi	r25, 0x0E	; 14
    2294:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    2298:	00 97       	sbiw	r24, 0x00	; 0
    229a:	21 f0       	breq	.+8      	; 0x22a4 <qsend_packet+0x41a>
      e->time = time;
    229c:	f8 01       	movw	r30, r16
    229e:	f5 82       	std	Z+5, r15	; 0x05
    22a0:	e4 82       	std	Z+4, r14	; 0x04
    22a2:	17 c0       	rjmp	.+46     	; 0x22d2 <qsend_packet+0x448>
register_encounter(const rimeaddr_t *neighbor, rtimer_clock_t time)
{
  struct encounter *e;

  /* If we have an entry for this neighbor already, we renew it. */
  for(e = list_head(encounter_list); e != NULL; e = list_item_next(e)) {
    22a4:	c8 01       	movw	r24, r16
    22a6:	0e 94 31 18 	call	0x3062	; 0x3062 <list_item_next>
    22aa:	08 2f       	mov	r16, r24
    22ac:	19 2f       	mov	r17, r25
    22ae:	01 15       	cp	r16, r1
    22b0:	11 05       	cpc	r17, r1
    22b2:	59 f7       	brne	.-42     	; 0x228a <qsend_packet+0x400>
    22b4:	63 c0       	rjmp	.+198    	; 0x237c <qsend_packet+0x4f2>
    e = memb_alloc(&encounter_memb);
    if(e == NULL) {
      /* We could not allocate memory for this encounter, so we just drop it. */
      return;
    }
    rimeaddr_copy(&e->neighbor, neighbor);
    22b6:	c8 01       	movw	r24, r16
    22b8:	02 96       	adiw	r24, 0x02	; 2
    22ba:	6d e6       	ldi	r22, 0x6D	; 109
    22bc:	7e e0       	ldi	r23, 0x0E	; 14
    22be:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    e->time = time;
    22c2:	f8 01       	movw	r30, r16
    22c4:	f5 82       	std	Z+5, r15	; 0x05
    22c6:	e4 82       	std	Z+4, r14	; 0x04
    list_add(encounter_list, e);
    22c8:	8b e8       	ldi	r24, 0x8B	; 139
    22ca:	96 e0       	ldi	r25, 0x06	; 6
    22cc:	b8 01       	movw	r22, r16
    22ce:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <list_add>
#if WITH_ENCOUNTER_OPTIMIZATION
  if(got_strobe_ack && !is_streaming) {
    register_encounter(packetbuf_addr(PACKETBUF_ADDR_RECEIVER), encounter_time);
  }
#endif /* WITH_ENCOUNTER_OPTIMIZATION */
  watchdog_start();
    22d2:	0e 94 21 23 	call	0x4642	; 0x4642 <watchdog_start>
  PRINTF("cxmac: send (strobes=%u,len=%u,%s), done\n", strobes,
	 packetbuf_totlen(), got_strobe_ack ? "ack" : "no ack");

#if CXMAC_CONF_COMPOWER
  /* Accumulate the power consumption for the packet transmission. */
  compower_accumulate(&current_packet);
    22d6:	83 e8       	ldi	r24, 0x83	; 131
    22d8:	96 e0       	ldi	r25, 0x06	; 6
    22da:	0e 94 ed 15 	call	0x2bda	; 0x2bda <compower_accumulate>

  /* Convert the accumulated power consumption for the transmitted
     packet to packet attributes so that the higher levels can keep
     track of the amount of energy spent on transmitting the
     packet. */
  compower_attrconv(&current_packet);
    22de:	83 e8       	ldi	r24, 0x83	; 131
    22e0:	96 e0       	ldi	r25, 0x06	; 6
    22e2:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <compower_attrconv>

  /* Clear the accumulated power consumption so that it is ready for
     the next packet. */
  compower_clear(&current_packet);
    22e6:	83 e8       	ldi	r24, 0x83	; 131
    22e8:	96 e0       	ldi	r25, 0x06	; 6
    22ea:	0e 94 49 16 	call	0x2c92	; 0x2c92 <compower_clear>
#endif /* CXMAC_CONF_COMPOWER */

  we_are_sending = 0;
    22ee:	10 92 81 06 	sts	0x0681, r1

  LEDS_OFF(LEDS_BLUE);
  if(collisions == 0) {
    22f2:	bb 20       	and	r11, r11
    22f4:	39 f4       	brne	.+14     	; 0x2304 <qsend_packet+0x47a>
    if(!is_broadcast && !got_strobe_ack) {
    22f6:	81 14       	cp	r8, r1
    22f8:	91 04       	cpc	r9, r1
    22fa:	91 f4       	brne	.+36     	; 0x2320 <qsend_packet+0x496>
    22fc:	c1 14       	cp	r12, r1
    22fe:	d1 04       	cpc	r13, r1
    2300:	91 f0       	breq	.+36     	; 0x2326 <qsend_packet+0x49c>
    2302:	0e c0       	rjmp	.+28     	; 0x2320 <qsend_packet+0x496>
      return MAC_TX_NOACK;
    } else {
      return MAC_TX_OK;
    }
  } else {
    someone_is_sending++;
    2304:	80 91 7f 06 	lds	r24, 0x067F
    2308:	8f 5f       	subi	r24, 0xFF	; 255
    230a:	80 93 7f 06 	sts	0x067F, r24
    return MAC_TX_COLLISION;
    230e:	41 e0       	ldi	r20, 0x01	; 1
    2310:	50 e0       	ldi	r21, 0x00	; 0
    2312:	0b c0       	rjmp	.+22     	; 0x232a <qsend_packet+0x4a0>
  len = NETSTACK_FRAMER.create();
  strobe_len = len + sizeof(struct cxmac_hdr);
  if(len < 0 || strobe_len > (int)sizeof(strobe)) {
    /* Failed to send */
   PRINTF("cxmac: send failed, too large header\n");
    return MAC_TX_ERR_FATAL;
    2314:	45 e0       	ldi	r20, 0x05	; 5
    2316:	50 e0       	ldi	r21, 0x00	; 0
    2318:	08 c0       	rjmp	.+16     	; 0x232a <qsend_packet+0x4a0>
  packet = queuebuf_new_from_packetbuf();
  if(packet == NULL) {
    /* No buffer available */
    PRINTF("cxmac: send failed, no queue buffer available (of %u)\n",
           QUEUEBUF_CONF_NUM);
    return MAC_TX_ERR;
    231a:	44 e0       	ldi	r20, 0x04	; 4
    231c:	50 e0       	ldi	r21, 0x00	; 0
    231e:	05 c0       	rjmp	.+10     	; 0x232a <qsend_packet+0x4a0>
  LEDS_OFF(LEDS_BLUE);
  if(collisions == 0) {
    if(!is_broadcast && !got_strobe_ack) {
      return MAC_TX_NOACK;
    } else {
      return MAC_TX_OK;
    2320:	40 e0       	ldi	r20, 0x00	; 0
    2322:	50 e0       	ldi	r21, 0x00	; 0
    2324:	02 c0       	rjmp	.+4      	; 0x232a <qsend_packet+0x4a0>
  we_are_sending = 0;

  LEDS_OFF(LEDS_BLUE);
  if(collisions == 0) {
    if(!is_broadcast && !got_strobe_ack) {
      return MAC_TX_NOACK;
    2326:	42 e0       	ldi	r20, 0x02	; 2
    2328:	50 e0       	ldi	r21, 0x00	; 0
  } else {
    PRINTF("cxmac: send immediately.\n");
    ret = send_packet();
  }

  mac_call_sent_callback(sent, ptr, ret, 1);
    232a:	89 ad       	ldd	r24, Y+57	; 0x39
    232c:	9a ad       	ldd	r25, Y+58	; 0x3a
    232e:	6b ad       	ldd	r22, Y+59	; 0x3b
    2330:	7c ad       	ldd	r23, Y+60	; 0x3c
    2332:	21 e0       	ldi	r18, 0x01	; 1
    2334:	30 e0       	ldi	r19, 0x00	; 0
    2336:	0e 94 13 12 	call	0x2426	; 0x2426 <mac_call_sent_callback>
}
    233a:	c0 5c       	subi	r28, 0xC0	; 192
    233c:	df 4f       	sbci	r29, 0xFF	; 255
    233e:	0f b6       	in	r0, 0x3f	; 63
    2340:	f8 94       	cli
    2342:	de bf       	out	0x3e, r29	; 62
    2344:	0f be       	out	0x3f, r0	; 63
    2346:	cd bf       	out	0x3d, r28	; 61
    2348:	cf 91       	pop	r28
    234a:	df 91       	pop	r29
    234c:	1f 91       	pop	r17
    234e:	0f 91       	pop	r16
    2350:	ff 90       	pop	r15
    2352:	ef 90       	pop	r14
    2354:	df 90       	pop	r13
    2356:	cf 90       	pop	r12
    2358:	bf 90       	pop	r11
    235a:	9f 90       	pop	r9
    235c:	8f 90       	pop	r8
    235e:	7f 90       	pop	r7
    2360:	6f 90       	pop	r6
    2362:	5f 90       	pop	r5
    2364:	4f 90       	pop	r4
    2366:	3f 90       	pop	r3
    2368:	2f 90       	pop	r2
    236a:	08 95       	ret

#if WITH_ACK_OPTIMIZATION
  /* If we have received the strobe ACK, and we are sending a packet
     that will need an upper layer ACK (as signified by the
     PACKETBUF_ATTR_RELIABLE packet attribute), we keep the radio on. */
  if(got_strobe_ack && (packetbuf_attr(PACKETBUF_ATTR_RELIABLE) ||
    236c:	80 91 8b 0e 	lds	r24, 0x0E8B
    2370:	90 91 8c 0e 	lds	r25, 0x0E8C
    2374:	00 97       	sbiw	r24, 0x00	; 0
    2376:	09 f4       	brne	.+2      	; 0x237a <qsend_packet+0x4f0>
    2378:	41 cf       	rjmp	.-382    	; 0x21fc <qsend_packet+0x372>
    237a:	4d cf       	rjmp	.-358    	; 0x2216 <qsend_packet+0x38c>
      break;
    }
  }
  /* No matching encounter was found, so we allocate a new one. */
  if(e == NULL) {
    e = memb_alloc(&encounter_memb);
    237c:	8f ee       	ldi	r24, 0xEF	; 239
    237e:	93 e0       	ldi	r25, 0x03	; 3
    2380:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <memb_alloc>
    2384:	8c 01       	movw	r16, r24
    if(e == NULL) {
    2386:	00 97       	sbiw	r24, 0x00	; 0
    2388:	09 f0       	breq	.+2      	; 0x238c <qsend_packet+0x502>
    238a:	95 cf       	rjmp	.-214    	; 0x22b6 <qsend_packet+0x42c>
    238c:	a2 cf       	rjmp	.-188    	; 0x22d2 <qsend_packet+0x448>

0000238e <qsend_list>:
  mac_call_sent_callback(sent, ptr, ret, 1);
}
/*---------------------------------------------------------------------------*/
static void
qsend_list(mac_callback_t sent, void *ptr, struct rdc_buf_list *buf_list)
{
    238e:	0f 93       	push	r16
    2390:	1f 93       	push	r17
    2392:	cf 93       	push	r28
    2394:	df 93       	push	r29
    2396:	8c 01       	movw	r16, r24
    2398:	eb 01       	movw	r28, r22
  if(buf_list != NULL) {
    239a:	41 15       	cp	r20, r1
    239c:	51 05       	cpc	r21, r1
    239e:	49 f0       	breq	.+18     	; 0x23b2 <qsend_list+0x24>
    queuebuf_to_packetbuf(buf_list->buf);
    23a0:	fa 01       	movw	r30, r20
    23a2:	82 81       	ldd	r24, Z+2	; 0x02
    23a4:	93 81       	ldd	r25, Z+3	; 0x03
    23a6:	0e 94 c7 1b 	call	0x378e	; 0x378e <queuebuf_to_packetbuf>
    qsend_packet(sent, ptr);
    23aa:	c8 01       	movw	r24, r16
    23ac:	be 01       	movw	r22, r28
    23ae:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <qsend_packet>
  }
}
    23b2:	df 91       	pop	r29
    23b4:	cf 91       	pop	r28
    23b6:	1f 91       	pop	r17
    23b8:	0f 91       	pop	r16
    23ba:	08 95       	ret

000023bc <cxmac_init>:
}
/*---------------------------------------------------------------------------*/
void
cxmac_init(void)
{
  radio_is_on = 0;
    23bc:	10 92 82 06 	sts	0x0682, r1
  waiting_for_packet = 0;
    23c0:	10 92 80 06 	sts	0x0680, r1
  PT_INIT(&pt);
    23c4:	10 92 7e 06 	sts	0x067E, r1
    23c8:	10 92 7d 06 	sts	0x067D, r1
  /*  rtimer_set(&rt, RTIMER_NOW() + cxmac_config.off_time, 1,
      (void (*)(struct rtimer *, void *))powercycle, NULL);*/

  cxmac_is_on = 1;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	80 93 65 06 	sts	0x0665, r24

#if WITH_ENCOUNTER_OPTIMIZATION
  list_init(encounter_list);
    23d2:	8b e8       	ldi	r24, 0x8B	; 139
    23d4:	96 e0       	ldi	r25, 0x06	; 6
    23d6:	0e 94 67 17 	call	0x2ece	; 0x2ece <list_init>
  memb_init(&encounter_memb);
    23da:	8f ee       	ldi	r24, 0xEF	; 239
    23dc:	93 e0       	ldi	r25, 0x03	; 3
    23de:	0e 94 93 16 	call	0x2d26	; 0x2d26 <memb_init>
  announcement_register_listen_callback(listen_callback);
  ctimer_set(&announcement_cycle_ctimer, ANNOUNCEMENT_TIME,
	     cycle_announcement, NULL);
#endif /* CXMAC_CONF_ANNOUNCEMENTS */

  CSCHEDULE_POWERCYCLE(DEFAULT_OFF_TIME);
    23e2:	8f e0       	ldi	r24, 0x0F	; 15
    23e4:	90 e0       	ldi	r25, 0x00	; 0
    23e6:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <cschedule_powercycle>
}
    23ea:	08 95       	ret

000023ec <cxmac_set_announcement_radio_txpower>:
cxmac_set_announcement_radio_txpower(int txpower)
{
#if CXMAC_CONF_ANNOUNCEMENTS
  announcement_radio_txpower = txpower;
#endif /* CXMAC_CONF_ANNOUNCEMENTS */
}
    23ec:	08 95       	ret

000023ee <send_packet>:

/*---------------------------------------------------------------------------*/
static void
send_packet(mac_callback_t sent, void *ptr)
{
  NETSTACK_RDC.send(sent, ptr);
    23ee:	e0 91 e3 03 	lds	r30, 0x03E3
    23f2:	f0 91 e4 03 	lds	r31, 0x03E4
    23f6:	09 95       	icall
}
    23f8:	08 95       	ret

000023fa <packet_input>:
/*---------------------------------------------------------------------------*/
static void
packet_input(void)
{
  NETSTACK_NETWORK.input();
    23fa:	e0 91 92 03 	lds	r30, 0x0392
    23fe:	f0 91 93 03 	lds	r31, 0x0393
    2402:	09 95       	icall
}
    2404:	08 95       	ret

00002406 <on>:
/*---------------------------------------------------------------------------*/
static int
on(void)
{
  return NETSTACK_RDC.on();
    2406:	e0 91 e9 03 	lds	r30, 0x03E9
    240a:	f0 91 ea 03 	lds	r31, 0x03EA
    240e:	09 95       	icall
}
    2410:	08 95       	ret

00002412 <off>:
/*---------------------------------------------------------------------------*/
static int
off(int keep_radio_on)
{
  return NETSTACK_RDC.off(keep_radio_on);
    2412:	e0 91 eb 03 	lds	r30, 0x03EB
    2416:	f0 91 ec 03 	lds	r31, 0x03EC
    241a:	09 95       	icall
}
    241c:	08 95       	ret

0000241e <channel_check_interval>:
/*---------------------------------------------------------------------------*/
static unsigned short
channel_check_interval(void)
{
  return 0;
}
    241e:	80 e0       	ldi	r24, 0x00	; 0
    2420:	90 e0       	ldi	r25, 0x00	; 0
    2422:	08 95       	ret

00002424 <init>:
/*---------------------------------------------------------------------------*/
static void
init(void)
{
}
    2424:	08 95       	ret

00002426 <mac_call_sent_callback>:
#endif /* DEBUG */

/*---------------------------------------------------------------------------*/
void
mac_call_sent_callback(mac_callback_t sent, void *ptr, int status, int num_tx)
{
    2426:	fc 01       	movw	r30, r24
    2428:	cb 01       	movw	r24, r22
    break;
  default:
    PRINTF("mac: error %d after %d tx\n", status, num_tx);
  }

  if(sent) {
    242a:	30 97       	sbiw	r30, 0x00	; 0
    242c:	19 f0       	breq	.+6      	; 0x2434 <mac_call_sent_callback+0xe>
    sent(ptr, status, num_tx);
    242e:	ba 01       	movw	r22, r20
    2430:	a9 01       	movw	r20, r18
    2432:	09 95       	icall
    2434:	08 95       	ret

00002436 <parse>:
  }
}
/*---------------------------------------------------------------------------*/
static int
parse(void)
{
    2436:	0f 93       	push	r16
    2438:	1f 93       	push	r17
    243a:	df 93       	push	r29
    243c:	cf 93       	push	r28
    243e:	cd b7       	in	r28, 0x3d	; 61
    2440:	de b7       	in	r29, 0x3e	; 62
    2442:	e0 97       	sbiw	r28, 0x30	; 48
    2444:	0f b6       	in	r0, 0x3f	; 63
    2446:	f8 94       	cli
    2448:	de bf       	out	0x3e, r29	; 62
    244a:	0f be       	out	0x3f, r0	; 63
    244c:	cd bf       	out	0x3d, r28	; 61
  frame802154_t frame;
  int len;
  len = packetbuf_datalen();
    244e:	0e 94 67 1a 	call	0x34ce	; 0x34ce <packetbuf_datalen>
    2452:	8c 01       	movw	r16, r24
  if(frame802154_parse(packetbuf_dataptr(), len, &frame) &&
    2454:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    2458:	60 2f       	mov	r22, r16
    245a:	ae 01       	movw	r20, r28
    245c:	4f 5f       	subi	r20, 0xFF	; 255
    245e:	5f 4f       	sbci	r21, 0xFF	; 255
    2460:	0e 94 a1 24 	call	0x4942	; 0x4942 <frame802154_parse>
    2464:	88 23       	and	r24, r24
    2466:	09 f4       	brne	.+2      	; 0x246a <parse+0x34>
    2468:	47 c0       	rjmp	.+142    	; 0x24f8 <parse+0xc2>
     packetbuf_hdrreduce(len - frame.payload_len)) {
    246a:	88 a9       	ldd	r24, Y+48	; 0x30
    246c:	98 01       	movw	r18, r16
    246e:	28 1b       	sub	r18, r24
    2470:	31 09       	sbc	r19, r1
    2472:	c9 01       	movw	r24, r18
    2474:	0e 94 f1 19 	call	0x33e2	; 0x33e2 <packetbuf_hdrreduce>
parse(void)
{
  frame802154_t frame;
  int len;
  len = packetbuf_datalen();
  if(frame802154_parse(packetbuf_dataptr(), len, &frame) &&
    2478:	00 97       	sbiw	r24, 0x00	; 0
    247a:	f1 f1       	breq	.+124    	; 0x24f8 <parse+0xc2>
     packetbuf_hdrreduce(len - frame.payload_len)) {
    if(frame.fcf.dest_addr_mode) {
    247c:	2e 81       	ldd	r18, Y+6	; 0x06
    247e:	22 23       	and	r18, r18
    2480:	31 f1       	breq	.+76     	; 0x24ce <parse+0x98>
      if(frame.dest_pid != mac_src_pan_id &&
    2482:	8a 85       	ldd	r24, Y+10	; 0x0a
    2484:	9b 85       	ldd	r25, Y+11	; 0x0b
    2486:	3b ea       	ldi	r19, 0xAB	; 171
    2488:	8d 3c       	cpi	r24, 0xCD	; 205
    248a:	93 07       	cpc	r25, r19
    248c:	21 f0       	breq	.+8      	; 0x2496 <parse+0x60>
    248e:	3f ef       	ldi	r19, 0xFF	; 255
    2490:	8f 3f       	cpi	r24, 0xFF	; 255
    2492:	93 07       	cpc	r25, r19
    2494:	89 f5       	brne	.+98     	; 0x24f8 <parse+0xc2>

/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
    2496:	22 30       	cpi	r18, 0x02	; 2
    2498:	41 f0       	breq	.+16     	; 0x24aa <parse+0x74>
    249a:	88 e0       	ldi	r24, 0x08	; 8
    249c:	90 e0       	ldi	r25, 0x00	; 0
    249e:	07 c0       	rjmp	.+14     	; 0x24ae <parse+0x78>
  while(i-- > 0) {
    24a0:	01 97       	sbiw	r24, 0x01	; 1
    if(addr[i] != 0xff) {
    24a2:	22 91       	ld	r18, -Z
    24a4:	2f 3f       	cpi	r18, 0xFF	; 255
    24a6:	41 f0       	breq	.+16     	; 0x24b8 <parse+0x82>
    24a8:	0b c0       	rjmp	.+22     	; 0x24c0 <parse+0x8a>

/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
    24aa:	82 e0       	ldi	r24, 0x02	; 2
    24ac:	90 e0       	ldi	r25, 0x00	; 0
    return FRAMER_FAILED;
  }
}
/*---------------------------------------------------------------------------*/
static int
parse(void)
    24ae:	fe 01       	movw	r30, r28
    24b0:	e8 0f       	add	r30, r24
    24b2:	f9 1f       	adc	r31, r25
    24b4:	3c 96       	adiw	r30, 0x0c	; 12
    24b6:	f4 cf       	rjmp	.-24     	; 0x24a0 <parse+0x6a>
/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
  while(i-- > 0) {
    24b8:	18 16       	cp	r1, r24
    24ba:	19 06       	cpc	r1, r25
    24bc:	8c f3       	brlt	.-30     	; 0x24a0 <parse+0x6a>
    24be:	07 c0       	rjmp	.+14     	; 0x24ce <parse+0x98>
    24c0:	8d e6       	ldi	r24, 0x6D	; 109
    24c2:	9e e0       	ldi	r25, 0x0E	; 14
    24c4:	be 01       	movw	r22, r28
    24c6:	64 5f       	subi	r22, 0xF4	; 244
    24c8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ca:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    24ce:	8b e6       	ldi	r24, 0x6B	; 107
    24d0:	9e e0       	ldi	r25, 0x0E	; 14
    24d2:	be 01       	movw	r22, r28
    24d4:	6a 5e       	subi	r22, 0xEA	; 234
    24d6:	7f 4f       	sbci	r23, 0xFF	; 255
    24d8:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
      if(!is_broadcast_addr(frame.fcf.dest_addr_mode, frame.dest_addr)) {
        packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, (rimeaddr_t *)&frame.dest_addr);
      }
    }
    packetbuf_set_addr(PACKETBUF_ADDR_SENDER, (rimeaddr_t *)&frame.src_addr);
    packetbuf_set_attr(PACKETBUF_ATTR_PENDING, frame.fcf.frame_pending);
    24dc:	8b 81       	ldd	r24, Y+3	; 0x03
    24de:	80 93 97 0e 	sts	0x0E97, r24
    24e2:	10 92 98 0e 	sts	0x0E98, r1
    /*    packetbuf_set_attr(PACKETBUF_ATTR_RELIABLE, frame.fcf.ack_required);*/
    packetbuf_set_attr(PACKETBUF_ATTR_PACKET_ID, frame.seq);
    24e6:	89 85       	ldd	r24, Y+9	; 0x09
    24e8:	80 93 8d 0e 	sts	0x0E8D, r24
    24ec:	10 92 8e 0e 	sts	0x0E8E, r1
    PRINTF("15.4-IN: %2X", frame.fcf.frame_type);
    PRINTADDR(packetbuf_addr(PACKETBUF_ADDR_SENDER));
    PRINTADDR(packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
    PRINTF("%u (%u)\n", packetbuf_datalen(), len);

    return len - frame.payload_len;
    24f0:	88 a9       	ldd	r24, Y+48	; 0x30
    24f2:	08 1b       	sub	r16, r24
    24f4:	11 09       	sbc	r17, r1
    24f6:	02 c0       	rjmp	.+4      	; 0x24fc <parse+0xc6>
    if(frame.fcf.dest_addr_mode) {
      if(frame.dest_pid != mac_src_pan_id &&
         frame.dest_pid != FRAME802154_BROADCASTPANDID) {
        /* Packet to another PAN */
        PRINTF("15.4: for another pan %u\n", frame.dest_pid);
        return FRAMER_FAILED;
    24f8:	0f ef       	ldi	r16, 0xFF	; 255
    24fa:	1f ef       	ldi	r17, 0xFF	; 255
    PRINTF("%u (%u)\n", packetbuf_datalen(), len);

    return len - frame.payload_len;
  }
  return FRAMER_FAILED;
}
    24fc:	c8 01       	movw	r24, r16
    24fe:	e0 96       	adiw	r28, 0x30	; 48
    2500:	0f b6       	in	r0, 0x3f	; 63
    2502:	f8 94       	cli
    2504:	de bf       	out	0x3e, r29	; 62
    2506:	0f be       	out	0x3f, r0	; 63
    2508:	cd bf       	out	0x3d, r28	; 61
    250a:	cf 91       	pop	r28
    250c:	df 91       	pop	r29
    250e:	1f 91       	pop	r17
    2510:	0f 91       	pop	r16
    2512:	08 95       	ret

00002514 <create>:
  return 1;
}
/*---------------------------------------------------------------------------*/
static int
create(void)
{
    2514:	df 92       	push	r13
    2516:	ef 92       	push	r14
    2518:	ff 92       	push	r15
    251a:	0f 93       	push	r16
    251c:	1f 93       	push	r17
    251e:	df 93       	push	r29
    2520:	cf 93       	push	r28
    2522:	cd b7       	in	r28, 0x3d	; 61
    2524:	de b7       	in	r29, 0x3e	; 62
    2526:	e0 97       	sbiw	r28, 0x30	; 48
    2528:	0f b6       	in	r0, 0x3f	; 63
    252a:	f8 94       	cli
    252c:	de bf       	out	0x3e, r29	; 62
    252e:	0f be       	out	0x3f, r0	; 63
    2530:	cd bf       	out	0x3d, r28	; 61
  frame802154_t params;
  uint8_t len;

  /* init to zeros */
  memset(&params, 0, sizeof(params));
    2532:	fe 01       	movw	r30, r28
    2534:	31 96       	adiw	r30, 0x01	; 1
    2536:	80 e3       	ldi	r24, 0x30	; 48
    2538:	df 01       	movw	r26, r30
    253a:	1d 92       	st	X+, r1
    253c:	8a 95       	dec	r24
    253e:	e9 f7       	brne	.-6      	; 0x253a <create+0x26>

  if(!initialized) {
    2540:	80 91 a9 06 	lds	r24, 0x06A9
    2544:	88 23       	and	r24, r24
    2546:	39 f4       	brne	.+14     	; 0x2556 <create+0x42>
    initialized = 1;
    2548:	81 e0       	ldi	r24, 0x01	; 1
    254a:	80 93 a9 06 	sts	0x06A9, r24
    mac_dsn = random_rand() & 0xff;
    254e:	0e 94 89 19 	call	0x3312	; 0x3312 <random_rand>
    2552:	80 93 aa 06 	sts	0x06AA, r24
  }

  /* Build the FCF. */
  params.fcf.frame_type = FRAME802154_DATAFRAME;
    2556:	81 e0       	ldi	r24, 0x01	; 1
    2558:	89 83       	std	Y+1, r24	; 0x01
  params.fcf.security_enabled = 0;
    255a:	1a 82       	std	Y+2, r1	; 0x02
  params.fcf.frame_pending = packetbuf_attr(PACKETBUF_ATTR_PENDING);
    255c:	80 91 97 0e 	lds	r24, 0x0E97
    2560:	8b 83       	std	Y+3, r24	; 0x03
  if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER), &rimeaddr_null)) {
    2562:	8d e6       	ldi	r24, 0x6D	; 109
    2564:	9e e0       	ldi	r25, 0x0E	; 14
    2566:	67 e8       	ldi	r22, 0x87	; 135
    2568:	73 e0       	ldi	r23, 0x03	; 3
    256a:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    256e:	00 97       	sbiw	r24, 0x00	; 0
    2570:	11 f0       	breq	.+4      	; 0x2576 <create+0x62>
    params.fcf.ack_required = 0;
    2572:	1c 82       	std	Y+4, r1	; 0x04
    2574:	03 c0       	rjmp	.+6      	; 0x257c <create+0x68>
  } else {
    params.fcf.ack_required = packetbuf_attr(PACKETBUF_ATTR_MAC_ACK);
    2576:	80 91 89 0e 	lds	r24, 0x0E89
    257a:	8c 83       	std	Y+4, r24	; 0x04
  }
  params.fcf.panid_compression = 0;
    257c:	1d 82       	std	Y+5, r1	; 0x05

  /* Insert IEEE 802.15.4 (2003) version bit. */
  params.fcf.frame_version = FRAME802154_IEEE802154_2003;
    257e:	1f 82       	std	Y+7, r1	; 0x07
  return 1;
}
static inline packetbuf_attr_t
packetbuf_attr(uint8_t type)
{
  return packetbuf_attrs[type].val;
    2580:	80 91 87 0e 	lds	r24, 0x0E87
    2584:	90 91 88 0e 	lds	r25, 0x0E88

  /* Increment and set the data sequence number. */
  if(packetbuf_attr(PACKETBUF_ATTR_MAC_SEQNO)) {
    2588:	00 97       	sbiw	r24, 0x00	; 0
    258a:	11 f0       	breq	.+4      	; 0x2590 <create+0x7c>
    params.seq = packetbuf_attr(PACKETBUF_ATTR_MAC_SEQNO);
    258c:	89 87       	std	Y+9, r24	; 0x09
    258e:	0b c0       	rjmp	.+22     	; 0x25a6 <create+0x92>
  } else {
    params.seq = mac_dsn++;
    2590:	80 91 aa 06 	lds	r24, 0x06AA
    2594:	89 87       	std	Y+9, r24	; 0x09
    2596:	98 2f       	mov	r25, r24
    2598:	9f 5f       	subi	r25, 0xFF	; 255
    259a:	90 93 aa 06 	sts	0x06AA, r25
    packetbuf_set_attr(PACKETBUF_ATTR_MAC_SEQNO, params.seq);
    259e:	80 93 87 0e 	sts	0x0E87, r24
    25a2:	10 92 88 0e 	sts	0x0E88, r1
     \todo For phase 1 the addresses are all long. We'll need a mechanism
     in the rime attributes to tell the mac to use long or short for phase 2.
  */
  if(sizeof(rimeaddr_t) == 2) {
    /* Use short address mode if rimeaddr size is short. */
    params.fcf.src_addr_mode = FRAME802154_SHORTADDRMODE;
    25a6:	02 e0       	ldi	r16, 0x02	; 2
    25a8:	08 87       	std	Y+8, r16	; 0x08
  } else {
    params.fcf.src_addr_mode = FRAME802154_LONGADDRMODE;
  }
  params.dest_pid = mac_dst_pan_id;
    25aa:	8d ec       	ldi	r24, 0xCD	; 205
    25ac:	9b ea       	ldi	r25, 0xAB	; 171
    25ae:	9b 87       	std	Y+11, r25	; 0x0b
    25b0:	8a 87       	std	Y+10, r24	; 0x0a

  /*
   *  If the output address is NULL in the Rime buf, then it is broadcast
   *  on the 802.15.4 network.
   */
  if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER), &rimeaddr_null)) {
    25b2:	8d e6       	ldi	r24, 0x6D	; 109
    25b4:	9e e0       	ldi	r25, 0x0E	; 14
    25b6:	67 e8       	ldi	r22, 0x87	; 135
    25b8:	73 e0       	ldi	r23, 0x03	; 3
    25ba:	0e 94 c3 07 	call	0xf86	; 0xf86 <rimeaddr_cmp>
    25be:	00 97       	sbiw	r24, 0x00	; 0
    25c0:	29 f0       	breq	.+10     	; 0x25cc <create+0xb8>
    /* Broadcast requires short address mode. */
    params.fcf.dest_addr_mode = FRAME802154_SHORTADDRMODE;
    25c2:	0e 83       	std	Y+6, r16	; 0x06
    params.dest_addr[0] = 0xFF;
    25c4:	8f ef       	ldi	r24, 0xFF	; 255
    25c6:	8c 87       	std	Y+12, r24	; 0x0c
    params.dest_addr[1] = 0xFF;
    25c8:	8d 87       	std	Y+13, r24	; 0x0d
    25ca:	07 c0       	rjmp	.+14     	; 0x25da <create+0xc6>

  } else {
    rimeaddr_copy((rimeaddr_t *)&params.dest_addr,
    25cc:	ce 01       	movw	r24, r28
    25ce:	0c 96       	adiw	r24, 0x0c	; 12
    25d0:	6d e6       	ldi	r22, 0x6D	; 109
    25d2:	7e e0       	ldi	r23, 0x0E	; 14
    25d4:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
                  packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
    /* Use short address mode if rimeaddr size is small */
    if(sizeof(rimeaddr_t) == 2) {
      params.fcf.dest_addr_mode = FRAME802154_SHORTADDRMODE;
    25d8:	0e 83       	std	Y+6, r16	; 0x06
      params.fcf.dest_addr_mode = FRAME802154_LONGADDRMODE;
    }
  }

  /* Set the source PAN ID to the global variable. */
  params.src_pid = mac_src_pan_id;
    25da:	8d ec       	ldi	r24, 0xCD	; 205
    25dc:	9b ea       	ldi	r25, 0xAB	; 171
    25de:	9d 8b       	std	Y+21, r25	; 0x15
    25e0:	8c 8b       	std	Y+20, r24	; 0x14

  /*
   * Set up the source address using only the long address mode for
   * phase 1.
   */
  rimeaddr_copy((rimeaddr_t *)&params.src_addr, &rimeaddr_node_addr);
    25e2:	ce 01       	movw	r24, r28
    25e4:	46 96       	adiw	r24, 0x16	; 22
    25e6:	68 e1       	ldi	r22, 0x18	; 24
    25e8:	7e e0       	ldi	r23, 0x0E	; 14
    25ea:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>

  params.payload = packetbuf_dataptr();
    25ee:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    25f2:	9f a7       	std	Y+47, r25	; 0x2f
    25f4:	8e a7       	std	Y+46, r24	; 0x2e
  params.payload_len = packetbuf_datalen();
    25f6:	0e 94 67 1a 	call	0x34ce	; 0x34ce <packetbuf_datalen>
    25fa:	88 ab       	std	Y+48, r24	; 0x30
  len = frame802154_hdrlen(&params);
    25fc:	7e 01       	movw	r14, r28
    25fe:	08 94       	sec
    2600:	e1 1c       	adc	r14, r1
    2602:	f1 1c       	adc	r15, r1
    2604:	c7 01       	movw	r24, r14
    2606:	0e 94 98 23 	call	0x4730	; 0x4730 <frame802154_hdrlen>
    260a:	d8 2e       	mov	r13, r24
  if(packetbuf_hdralloc(len)) {
    260c:	08 2f       	mov	r16, r24
    260e:	10 e0       	ldi	r17, 0x00	; 0
    2610:	c8 01       	movw	r24, r16
    2612:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <packetbuf_hdralloc>
    2616:	00 97       	sbiw	r24, 0x00	; 0
    2618:	41 f0       	breq	.+16     	; 0x262a <create+0x116>
    frame802154_create(&params, packetbuf_hdrptr(), len);
    261a:	0e 94 1d 1a 	call	0x343a	; 0x343a <packetbuf_hdrptr>
    261e:	bc 01       	movw	r22, r24
    2620:	c7 01       	movw	r24, r14
    2622:	4d 2d       	mov	r20, r13
    2624:	0e 94 b6 23 	call	0x476c	; 0x476c <frame802154_create>

    PRINTF("15.4-OUT: %2X", params.fcf.frame_type);
    PRINTADDR(params.dest_addr.u8);
    PRINTF("%u %u (%u)\n", len, packetbuf_datalen(), packetbuf_totlen());

    return len;
    2628:	02 c0       	rjmp	.+4      	; 0x262e <create+0x11a>
  } else {
    PRINTF("15.4-OUT: too large header: %u\n", len);
    return FRAMER_FAILED;
    262a:	0f ef       	ldi	r16, 0xFF	; 255
    262c:	1f ef       	ldi	r17, 0xFF	; 255
  }
}
    262e:	c8 01       	movw	r24, r16
    2630:	e0 96       	adiw	r28, 0x30	; 48
    2632:	0f b6       	in	r0, 0x3f	; 63
    2634:	f8 94       	cli
    2636:	de bf       	out	0x3e, r29	; 62
    2638:	0f be       	out	0x3f, r0	; 63
    263a:	cd bf       	out	0x3d, r28	; 61
    263c:	cf 91       	pop	r28
    263e:	df 91       	pop	r29
    2640:	1f 91       	pop	r17
    2642:	0f 91       	pop	r16
    2644:	ff 90       	pop	r15
    2646:	ef 90       	pop	r14
    2648:	df 90       	pop	r13
    264a:	08 95       	ret

0000264c <call_process>:
  process_current = old_current;
}
/*---------------------------------------------------------------------------*/
static void
call_process(struct process *p, process_event_t ev, process_data_t data)
{
    264c:	ff 92       	push	r15
    264e:	0f 93       	push	r16
    2650:	1f 93       	push	r17
    2652:	cf 93       	push	r28
    2654:	df 93       	push	r29
    2656:	ec 01       	movw	r28, r24
    2658:	f6 2e       	mov	r15, r22
    265a:	8a 01       	movw	r16, r20
  if(p->state == PROCESS_STATE_CALLED) {
    printf("process: process '%s' called again with event %d\n", PROCESS_NAME_STRING(p), ev);
  }
#endif /* DEBUG */
  
  if((p->state & PROCESS_STATE_RUNNING) &&
    265c:	8e 81       	ldd	r24, Y+6	; 0x06
    265e:	80 ff       	sbrs	r24, 0
    2660:	47 c0       	rjmp	.+142    	; 0x26f0 <call_process+0xa4>
    2662:	8a 81       	ldd	r24, Y+2	; 0x02
    2664:	9b 81       	ldd	r25, Y+3	; 0x03
    2666:	00 97       	sbiw	r24, 0x00	; 0
    2668:	09 f4       	brne	.+2      	; 0x266c <call_process+0x20>
    266a:	42 c0       	rjmp	.+132    	; 0x26f0 <call_process+0xa4>
     p->thread != NULL) {
    // PRINTF("process: calling process '%s' with event %d\n", PROCESS_NAME_STRING(p), ev);
    if(ev == 129){
    266c:	61 38       	cpi	r22, 0x81	; 129
    266e:	29 f4       	brne	.+10     	; 0x267a <call_process+0x2e>
        printf("process: calling process '%s' with event PROCESS_EVENT_INIT\n", PROCESS_NAME_STRING(p));
    2670:	00 d0       	rcall	.+0      	; 0x2672 <call_process+0x26>
    2672:	00 d0       	rcall	.+0      	; 0x2674 <call_process+0x28>
    2674:	81 e1       	ldi	r24, 0x11	; 17
    2676:	94 e0       	ldi	r25, 0x04	; 4
    2678:	0f c0       	rjmp	.+30     	; 0x2698 <call_process+0x4c>
    }
    else if (ev == 130){
    267a:	ff 2d       	mov	r31, r15
    267c:	f2 38       	cpi	r31, 0x82	; 130
    267e:	29 f4       	brne	.+10     	; 0x268a <call_process+0x3e>
        printf("process: calling process '%s' with event PROCESS_EVENT_POLL\n", PROCESS_NAME_STRING(p));
    2680:	00 d0       	rcall	.+0      	; 0x2682 <call_process+0x36>
    2682:	00 d0       	rcall	.+0      	; 0x2684 <call_process+0x38>
    2684:	8f e4       	ldi	r24, 0x4F	; 79
    2686:	94 e0       	ldi	r25, 0x04	; 4
    2688:	07 c0       	rjmp	.+14     	; 0x2698 <call_process+0x4c>
    }
    else if (ev == 136){
    268a:	ff 2d       	mov	r31, r15
    268c:	f8 38       	cpi	r31, 0x88	; 136
    268e:	91 f4       	brne	.+36     	; 0x26b4 <call_process+0x68>
        printf("process: calling process '%s' with event PROCESS_EVENT_TIMER\n", PROCESS_NAME_STRING(p));
    2690:	00 d0       	rcall	.+0      	; 0x2692 <call_process+0x46>
    2692:	00 d0       	rcall	.+0      	; 0x2694 <call_process+0x48>
    2694:	8c e8       	ldi	r24, 0x8C	; 140
    2696:	94 e0       	ldi	r25, 0x04	; 4
    2698:	ed b7       	in	r30, 0x3d	; 61
    269a:	fe b7       	in	r31, 0x3e	; 62
    269c:	92 83       	std	Z+2, r25	; 0x02
    269e:	81 83       	std	Z+1, r24	; 0x01
    26a0:	8e e4       	ldi	r24, 0x4E	; 78
    26a2:	94 e0       	ldi	r25, 0x04	; 4
    26a4:	94 83       	std	Z+4, r25	; 0x04
    26a6:	83 83       	std	Z+3, r24	; 0x03
    26a8:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>
    26ac:	0f 90       	pop	r0
    26ae:	0f 90       	pop	r0
    26b0:	0f 90       	pop	r0
    26b2:	0f 90       	pop	r0
    }
    process_current = p;
    26b4:	d0 93 ae 06 	sts	0x06AE, r29
    26b8:	c0 93 ad 06 	sts	0x06AD, r28
    p->state = PROCESS_STATE_CALLED;
    26bc:	82 e0       	ldi	r24, 0x02	; 2
    26be:	8e 83       	std	Y+6, r24	; 0x06
    ret = p->thread(&p->pt, ev, data);
    26c0:	ea 81       	ldd	r30, Y+2	; 0x02
    26c2:	fb 81       	ldd	r31, Y+3	; 0x03
    26c4:	ce 01       	movw	r24, r28
    26c6:	04 96       	adiw	r24, 0x04	; 4
    26c8:	6f 2d       	mov	r22, r15
    26ca:	a8 01       	movw	r20, r16
    26cc:	09 95       	icall
    26ce:	99 27       	eor	r25, r25
    26d0:	87 fd       	sbrc	r24, 7
    26d2:	90 95       	com	r25
    if(ret == PT_EXITED ||
    26d4:	02 97       	sbiw	r24, 0x02	; 2
    26d6:	82 30       	cpi	r24, 0x02	; 2
    26d8:	91 05       	cpc	r25, r1
    26da:	18 f0       	brcs	.+6      	; 0x26e2 <call_process+0x96>
       ret == PT_ENDED ||
    26dc:	ff 2d       	mov	r31, r15
    26de:	f3 38       	cpi	r31, 0x83	; 131
    26e0:	29 f4       	brne	.+10     	; 0x26ec <call_process+0xa0>
       ev == PROCESS_EVENT_EXIT) {
      exit_process(p, p);
    26e2:	ce 01       	movw	r24, r28
    26e4:	be 01       	movw	r22, r28
    26e6:	0e 94 7e 13 	call	0x26fc	; 0x26fc <exit_process>
    26ea:	02 c0       	rjmp	.+4      	; 0x26f0 <call_process+0xa4>
    } else {
      p->state = PROCESS_STATE_RUNNING;
    26ec:	81 e0       	ldi	r24, 0x01	; 1
    26ee:	8e 83       	std	Y+6, r24	; 0x06
    }
  }
}
    26f0:	df 91       	pop	r29
    26f2:	cf 91       	pop	r28
    26f4:	1f 91       	pop	r17
    26f6:	0f 91       	pop	r16
    26f8:	ff 90       	pop	r15
    26fa:	08 95       	ret

000026fc <exit_process>:
  process_post_synch(p, PROCESS_EVENT_INIT, (process_data_t)arg);
}
/*---------------------------------------------------------------------------*/
static void
exit_process(struct process *p, struct process *fromprocess)
{
    26fc:	cf 92       	push	r12
    26fe:	df 92       	push	r13
    2700:	ef 92       	push	r14
    2702:	ff 92       	push	r15
    2704:	0f 93       	push	r16
    2706:	1f 93       	push	r17
    2708:	cf 93       	push	r28
    270a:	df 93       	push	r29
    270c:	ec 01       	movw	r28, r24
    270e:	7b 01       	movw	r14, r22
  register struct process *q;
  struct process *old_current = process_current;
    2710:	c0 90 ad 06 	lds	r12, 0x06AD
    2714:	d0 90 ae 06 	lds	r13, 0x06AE

  // PRINTF("process: exit_process '%s'\n", PROCESS_NAME_STRING(p));
  printf("process: exit_process '%s'\n", PROCESS_NAME_STRING(p));
    2718:	00 d0       	rcall	.+0      	; 0x271a <exit_process+0x1e>
    271a:	00 d0       	rcall	.+0      	; 0x271c <exit_process+0x20>
    271c:	8a ec       	ldi	r24, 0xCA	; 202
    271e:	94 e0       	ldi	r25, 0x04	; 4
    2720:	ed b7       	in	r30, 0x3d	; 61
    2722:	fe b7       	in	r31, 0x3e	; 62
    2724:	92 83       	std	Z+2, r25	; 0x02
    2726:	81 83       	std	Z+1, r24	; 0x01
    2728:	8e e4       	ldi	r24, 0x4E	; 78
    272a:	94 e0       	ldi	r25, 0x04	; 4
    272c:	94 83       	std	Z+4, r25	; 0x04
    272e:	83 83       	std	Z+3, r24	; 0x03
    2730:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>

  /* Make sure the process is in the process list before we try to
     exit it. */
  for(q = process_list; q != p && q != NULL; q = q->next);
    2734:	00 91 ab 06 	lds	r16, 0x06AB
    2738:	10 91 ac 06 	lds	r17, 0x06AC
    273c:	0f 90       	pop	r0
    273e:	0f 90       	pop	r0
    2740:	0f 90       	pop	r0
    2742:	0f 90       	pop	r0
    2744:	f8 01       	movw	r30, r16
    2746:	03 c0       	rjmp	.+6      	; 0x274e <exit_process+0x52>
    2748:	01 90       	ld	r0, Z+
    274a:	f0 81       	ld	r31, Z
    274c:	e0 2d       	mov	r30, r0
    274e:	ec 17       	cp	r30, r28
    2750:	fd 07       	cpc	r31, r29
    2752:	19 f0       	breq	.+6      	; 0x275a <exit_process+0x5e>
    2754:	30 97       	sbiw	r30, 0x00	; 0
    2756:	c1 f7       	brne	.-16     	; 0x2748 <exit_process+0x4c>
    2758:	46 c0       	rjmp	.+140    	; 0x27e6 <exit_process+0xea>
  if(q == NULL) {
    275a:	20 97       	sbiw	r28, 0x00	; 0
    275c:	09 f4       	brne	.+2      	; 0x2760 <exit_process+0x64>
    275e:	43 c0       	rjmp	.+134    	; 0x27e6 <exit_process+0xea>
    return;
  }

  if(process_is_running(p)) {
    2760:	8e 81       	ldd	r24, Y+6	; 0x06
    2762:	88 23       	and	r24, r24
    2764:	09 f1       	breq	.+66     	; 0x27a8 <exit_process+0xac>
    /* Process was running */
    p->state = PROCESS_STATE_NONE;
    2766:	1e 82       	std	Y+6, r1	; 0x06
    /*
     * Post a synchronous event to all processes to inform them that
     * this process is about to exit. This will allow services to
     * deallocate state associated with this process.
     */
    for(q = process_list; q != NULL; q = q->next) {
    2768:	0b c0       	rjmp	.+22     	; 0x2780 <exit_process+0x84>
      if(p != q) {
    276a:	c0 17       	cp	r28, r16
    276c:	d1 07       	cpc	r29, r17
    276e:	29 f0       	breq	.+10     	; 0x277a <exit_process+0x7e>
	call_process(q, PROCESS_EVENT_EXITED, (process_data_t)p);
    2770:	c8 01       	movw	r24, r16
    2772:	67 e8       	ldi	r22, 0x87	; 135
    2774:	ae 01       	movw	r20, r28
    2776:	0e 94 26 13 	call	0x264c	; 0x264c <call_process>
    /*
     * Post a synchronous event to all processes to inform them that
     * this process is about to exit. This will allow services to
     * deallocate state associated with this process.
     */
    for(q = process_list; q != NULL; q = q->next) {
    277a:	f8 01       	movw	r30, r16
    277c:	00 81       	ld	r16, Z
    277e:	11 81       	ldd	r17, Z+1	; 0x01
    2780:	01 15       	cp	r16, r1
    2782:	11 05       	cpc	r17, r1
    2784:	91 f7       	brne	.-28     	; 0x276a <exit_process+0x6e>
      if(p != q) {
	call_process(q, PROCESS_EVENT_EXITED, (process_data_t)p);
      }
    }

    if(p->thread != NULL && p != fromprocess) {
    2786:	ea 81       	ldd	r30, Y+2	; 0x02
    2788:	fb 81       	ldd	r31, Y+3	; 0x03
    278a:	30 97       	sbiw	r30, 0x00	; 0
    278c:	69 f0       	breq	.+26     	; 0x27a8 <exit_process+0xac>
    278e:	ce 15       	cp	r28, r14
    2790:	df 05       	cpc	r29, r15
    2792:	51 f0       	breq	.+20     	; 0x27a8 <exit_process+0xac>
      /* Post the exit event to the process that is about to exit. */
      process_current = p;
    2794:	d0 93 ae 06 	sts	0x06AE, r29
    2798:	c0 93 ad 06 	sts	0x06AD, r28
      p->thread(&p->pt, PROCESS_EVENT_EXIT, NULL);
    279c:	ce 01       	movw	r24, r28
    279e:	04 96       	adiw	r24, 0x04	; 4
    27a0:	63 e8       	ldi	r22, 0x83	; 131
    27a2:	40 e0       	ldi	r20, 0x00	; 0
    27a4:	50 e0       	ldi	r21, 0x00	; 0
    27a6:	09 95       	icall
    }
  }

  if(p == process_list) {
    27a8:	e0 91 ab 06 	lds	r30, 0x06AB
    27ac:	f0 91 ac 06 	lds	r31, 0x06AC
    27b0:	ce 17       	cp	r28, r30
    27b2:	df 07       	cpc	r29, r31
    27b4:	91 f4       	brne	.+36     	; 0x27da <exit_process+0xde>
    process_list = process_list->next;
    27b6:	88 81       	ld	r24, Y
    27b8:	99 81       	ldd	r25, Y+1	; 0x01
    27ba:	90 93 ac 06 	sts	0x06AC, r25
    27be:	80 93 ab 06 	sts	0x06AB, r24
    27c2:	0d c0       	rjmp	.+26     	; 0x27de <exit_process+0xe2>
  } else {
    for(q = process_list; q != NULL; q = q->next) {
      if(q->next == p) {
    27c4:	80 81       	ld	r24, Z
    27c6:	91 81       	ldd	r25, Z+1	; 0x01
    27c8:	8c 17       	cp	r24, r28
    27ca:	9d 07       	cpc	r25, r29
    27cc:	29 f4       	brne	.+10     	; 0x27d8 <exit_process+0xdc>
	q->next = p->next;
    27ce:	88 81       	ld	r24, Y
    27d0:	99 81       	ldd	r25, Y+1	; 0x01
    27d2:	91 83       	std	Z+1, r25	; 0x01
    27d4:	80 83       	st	Z, r24
	break;
    27d6:	03 c0       	rjmp	.+6      	; 0x27de <exit_process+0xe2>

  if(p == process_list) {
    process_list = process_list->next;
  } else {
    for(q = process_list; q != NULL; q = q->next) {
      if(q->next == p) {
    27d8:	fc 01       	movw	r30, r24
  }

  if(p == process_list) {
    process_list = process_list->next;
  } else {
    for(q = process_list; q != NULL; q = q->next) {
    27da:	30 97       	sbiw	r30, 0x00	; 0
    27dc:	99 f7       	brne	.-26     	; 0x27c4 <exit_process+0xc8>
	break;
      }
    }
  }

  process_current = old_current;
    27de:	d0 92 ae 06 	sts	0x06AE, r13
    27e2:	c0 92 ad 06 	sts	0x06AD, r12
}
    27e6:	df 91       	pop	r29
    27e8:	cf 91       	pop	r28
    27ea:	1f 91       	pop	r17
    27ec:	0f 91       	pop	r16
    27ee:	ff 90       	pop	r15
    27f0:	ef 90       	pop	r14
    27f2:	df 90       	pop	r13
    27f4:	cf 90       	pop	r12
    27f6:	08 95       	ret

000027f8 <do_poll>:
 * Call each process' poll handler.
 */
/*---------------------------------------------------------------------------*/
static void
do_poll(void)
{
    27f8:	1f 93       	push	r17
    27fa:	cf 93       	push	r28
    27fc:	df 93       	push	r29
  struct process *p;

  poll_requested = 0;
    27fe:	10 92 b1 06 	sts	0x06B1, r1
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    2802:	c0 91 ab 06 	lds	r28, 0x06AB
    2806:	d0 91 ac 06 	lds	r29, 0x06AC
    if(p->needspoll) {
      p->state = PROCESS_STATE_RUNNING;
    280a:	11 e0       	ldi	r17, 0x01	; 1
{
  struct process *p;

  poll_requested = 0;
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    280c:	0e c0       	rjmp	.+28     	; 0x282a <do_poll+0x32>
    if(p->needspoll) {
    280e:	8f 81       	ldd	r24, Y+7	; 0x07
    2810:	88 23       	and	r24, r24
    2812:	41 f0       	breq	.+16     	; 0x2824 <do_poll+0x2c>
      p->state = PROCESS_STATE_RUNNING;
    2814:	1e 83       	std	Y+6, r17	; 0x06
      p->needspoll = 0;
    2816:	1f 82       	std	Y+7, r1	; 0x07
      call_process(p, PROCESS_EVENT_POLL, NULL);
    2818:	ce 01       	movw	r24, r28
    281a:	62 e8       	ldi	r22, 0x82	; 130
    281c:	40 e0       	ldi	r20, 0x00	; 0
    281e:	50 e0       	ldi	r21, 0x00	; 0
    2820:	0e 94 26 13 	call	0x264c	; 0x264c <call_process>
{
  struct process *p;

  poll_requested = 0;
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    2824:	09 90       	ld	r0, Y+
    2826:	d8 81       	ld	r29, Y
    2828:	c0 2d       	mov	r28, r0
    282a:	20 97       	sbiw	r28, 0x00	; 0
    282c:	81 f7       	brne	.-32     	; 0x280e <do_poll+0x16>
      p->state = PROCESS_STATE_RUNNING;
      p->needspoll = 0;
      call_process(p, PROCESS_EVENT_POLL, NULL);
    }
  }
}
    282e:	df 91       	pop	r29
    2830:	cf 91       	pop	r28
    2832:	1f 91       	pop	r17
    2834:	08 95       	ret

00002836 <process_alloc_event>:

/*---------------------------------------------------------------------------*/
process_event_t
process_alloc_event(void)
{
  return lastevent++;
    2836:	80 91 e4 06 	lds	r24, 0x06E4
    283a:	98 2f       	mov	r25, r24
    283c:	9f 5f       	subi	r25, 0xFF	; 255
    283e:	90 93 e4 06 	sts	0x06E4, r25
}
    2842:	08 95       	ret

00002844 <process_exit>:
}
/*---------------------------------------------------------------------------*/
void
process_exit(struct process *p)
{
  exit_process(p, PROCESS_CURRENT());
    2844:	60 91 ad 06 	lds	r22, 0x06AD
    2848:	70 91 ae 06 	lds	r23, 0x06AE
    284c:	0e 94 7e 13 	call	0x26fc	; 0x26fc <exit_process>
}
    2850:	08 95       	ret

00002852 <process_init>:
/*---------------------------------------------------------------------------*/
void
process_init(void)
{
  lastevent = PROCESS_EVENT_MAX;
    2852:	8a e8       	ldi	r24, 0x8A	; 138
    2854:	80 93 e4 06 	sts	0x06E4, r24

  nevents = fevent = 0;
    2858:	10 92 b3 06 	sts	0x06B3, r1
    285c:	10 92 b2 06 	sts	0x06B2, r1
#if PROCESS_CONF_STATS
  process_maxevents = 0;
    2860:	10 92 62 0e 	sts	0x0E62, r1
#endif /* PROCESS_CONF_STATS */

  /* ysk changed */
  process_current = process_list = NULL;
    2864:	10 92 ac 06 	sts	0x06AC, r1
    2868:	10 92 ab 06 	sts	0x06AB, r1
    286c:	10 92 ae 06 	sts	0x06AE, r1
    2870:	10 92 ad 06 	sts	0x06AD, r1
  process_high_ready = NULL;    // +
    2874:	10 92 b0 06 	sts	0x06B0, r1
    2878:	10 92 af 06 	sts	0x06AF, r1
}
    287c:	08 95       	ret

0000287e <process_run>:
/*---------------------------------------------------------------------------*/
int
process_run(void)
{
  /* Process poll events. */
  if(poll_requested) {
    287e:	80 91 b1 06 	lds	r24, 0x06B1
    2882:	88 23       	and	r24, r24
    2884:	11 f0       	breq	.+4      	; 0x288a <process_run+0xc>
    do_poll();
    2886:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <do_poll>
   * delivered to any of them. If so, we call the event handler
   * function for the process. We only process one event at a time and
   * call the poll handlers inbetween.
   */

  if(nevents > 0) {
    288a:	70 91 b2 06 	lds	r23, 0x06B2
    288e:	77 23       	and	r23, r23
    2890:	09 f4       	brne	.+2      	; 0x2894 <process_run+0x16>
    2892:	55 c0       	rjmp	.+170    	; 0x293e <process_run+0xc0>
    
    /* There are events that we should deliver. */
    ev = events[fevent].ev;
    2894:	20 91 b3 06 	lds	r18, 0x06B3
    2898:	30 e0       	ldi	r19, 0x00	; 0
    289a:	f9 01       	movw	r30, r18
    289c:	ee 0f       	add	r30, r30
    289e:	ff 1f       	adc	r31, r31
    28a0:	ee 0f       	add	r30, r30
    28a2:	ff 1f       	adc	r31, r31
    28a4:	e2 0f       	add	r30, r18
    28a6:	f3 1f       	adc	r31, r19
    28a8:	ec 54       	subi	r30, 0x4C	; 76
    28aa:	f9 4f       	sbci	r31, 0xF9	; 249
    28ac:	60 81       	ld	r22, Z
    28ae:	60 93 e3 06 	sts	0x06E3, r22
    
    data = events[fevent].data;
    28b2:	41 81       	ldd	r20, Z+1	; 0x01
    28b4:	52 81       	ldd	r21, Z+2	; 0x02
    28b6:	50 93 e2 06 	sts	0x06E2, r21
    28ba:	40 93 e1 06 	sts	0x06E1, r20
    receiver = events[fevent].p;
    28be:	83 81       	ldd	r24, Z+3	; 0x03
    28c0:	94 81       	ldd	r25, Z+4	; 0x04
    28c2:	90 93 e0 06 	sts	0x06E0, r25
    28c6:	80 93 df 06 	sts	0x06DF, r24

    /* Since we have seen the new event, we move pointer upwards
       and decrese the number of events. */
    fevent = (fevent + 1) % PROCESS_CONF_NUMEVENTS;
    28ca:	2f 5f       	subi	r18, 0xFF	; 255
    28cc:	3f 4f       	sbci	r19, 0xFF	; 255
    28ce:	27 70       	andi	r18, 0x07	; 7
    28d0:	30 70       	andi	r19, 0x00	; 0
    28d2:	20 93 b3 06 	sts	0x06B3, r18
    --nevents;
    28d6:	71 50       	subi	r23, 0x01	; 1
    28d8:	70 93 b2 06 	sts	0x06B2, r23

    /* If this is a broadcast event, we deliver it to all events, in
       order of their priority. */
    if(receiver == PROCESS_BROADCAST) {
    28dc:	00 97       	sbiw	r24, 0x00	; 0
    28de:	41 f5       	brne	.+80     	; 0x2930 <process_run+0xb2>
      for(p = process_list; p != NULL; p = p->next) {
    28e0:	80 91 ab 06 	lds	r24, 0x06AB
    28e4:	90 91 ac 06 	lds	r25, 0x06AC
    28e8:	18 c0       	rjmp	.+48     	; 0x291a <process_run+0x9c>

	/* If we have been requested to poll a process, we do this in
	   between processing the broadcast event. */
	if(poll_requested) {
    28ea:	80 91 b1 06 	lds	r24, 0x06B1
    28ee:	88 23       	and	r24, r24
    28f0:	11 f0       	breq	.+4      	; 0x28f6 <process_run+0x78>
	  do_poll();
    28f2:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <do_poll>
	}
	call_process(p, ev, data);
    28f6:	40 91 e1 06 	lds	r20, 0x06E1
    28fa:	50 91 e2 06 	lds	r21, 0x06E2
    28fe:	80 91 dd 06 	lds	r24, 0x06DD
    2902:	90 91 de 06 	lds	r25, 0x06DE
    2906:	60 91 e3 06 	lds	r22, 0x06E3
    290a:	0e 94 26 13 	call	0x264c	; 0x264c <call_process>
    --nevents;

    /* If this is a broadcast event, we deliver it to all events, in
       order of their priority. */
    if(receiver == PROCESS_BROADCAST) {
      for(p = process_list; p != NULL; p = p->next) {
    290e:	e0 91 dd 06 	lds	r30, 0x06DD
    2912:	f0 91 de 06 	lds	r31, 0x06DE
    2916:	80 81       	ld	r24, Z
    2918:	91 81       	ldd	r25, Z+1	; 0x01
    291a:	90 93 de 06 	sts	0x06DE, r25
    291e:	80 93 dd 06 	sts	0x06DD, r24
    2922:	80 91 dd 06 	lds	r24, 0x06DD
    2926:	90 91 de 06 	lds	r25, 0x06DE
    292a:	00 97       	sbiw	r24, 0x00	; 0
    292c:	f1 f6       	brne	.-68     	; 0x28ea <process_run+0x6c>
    292e:	07 c0       	rjmp	.+14     	; 0x293e <process_run+0xc0>
    } else {
      /* This is not a broadcast event, so we deliver it to the
	 specified process. */
      /* If the event was an INIT event, we should also update the
	 state of the process. */
      if(ev == PROCESS_EVENT_INIT) {
    2930:	61 38       	cpi	r22, 0x81	; 129
    2932:	19 f4       	brne	.+6      	; 0x293a <process_run+0xbc>
	receiver->state = PROCESS_STATE_RUNNING;
    2934:	21 e0       	ldi	r18, 0x01	; 1
    2936:	fc 01       	movw	r30, r24
    2938:	26 83       	std	Z+6, r18	; 0x06
      }

      /* Make sure that the process actually is running. */
      call_process(receiver, ev, data);
    293a:	0e 94 26 13 	call	0x264c	; 0x264c <call_process>
  }

  /* Process one event from the queue */
  do_event();

  return nevents + poll_requested;
    293e:	80 91 b1 06 	lds	r24, 0x06B1
    2942:	20 91 b2 06 	lds	r18, 0x06B2
    2946:	30 e0       	ldi	r19, 0x00	; 0
    2948:	28 0f       	add	r18, r24
    294a:	31 1d       	adc	r19, r1
}
    294c:	c9 01       	movw	r24, r18
    294e:	08 95       	ret

00002950 <process_nevents>:
/*---------------------------------------------------------------------------*/
int
process_nevents(void)
{
  return nevents + poll_requested;
    2950:	80 91 b1 06 	lds	r24, 0x06B1
    2954:	20 91 b2 06 	lds	r18, 0x06B2
    2958:	30 e0       	ldi	r19, 0x00	; 0
    295a:	28 0f       	add	r18, r24
    295c:	31 1d       	adc	r19, r1
}
    295e:	c9 01       	movw	r24, r18
    2960:	08 95       	ret

00002962 <process_post>:
/*---------------------------------------------------------------------------*/
int
process_post(struct process *p, process_event_t ev, process_data_t data)
{
    2962:	ff 92       	push	r15
    2964:	0f 93       	push	r16
    2966:	1f 93       	push	r17
    2968:	cf 93       	push	r28
    296a:	df 93       	push	r29
    296c:	ec 01       	movw	r28, r24
    296e:	f6 2e       	mov	r15, r22
    2970:	8a 01       	movw	r16, r20
  static process_num_events_t snum;

  if(PROCESS_CURRENT() == NULL) {
    2972:	80 91 ad 06 	lds	r24, 0x06AD
    2976:	90 91 ae 06 	lds	r25, 0x06AE
    297a:	00 97       	sbiw	r24, 0x00	; 0
    297c:	29 f5       	brne	.+74     	; 0x29c8 <process_post+0x66>
    // PRINTF("process_post: NULL process posts event %d to process '%s', nevents %d\n",
    printf("process_post: NULL process posts event %d to process '%s', nevents %d\n",
    297e:	2d b7       	in	r18, 0x3d	; 61
    2980:	3e b7       	in	r19, 0x3e	; 62
    2982:	28 50       	subi	r18, 0x08	; 8
    2984:	30 40       	sbci	r19, 0x00	; 0
    2986:	0f b6       	in	r0, 0x3f	; 63
    2988:	f8 94       	cli
    298a:	3e bf       	out	0x3e, r19	; 62
    298c:	0f be       	out	0x3f, r0	; 63
    298e:	2d bf       	out	0x3d, r18	; 61
    2990:	ed b7       	in	r30, 0x3d	; 61
    2992:	fe b7       	in	r31, 0x3e	; 62
    2994:	31 96       	adiw	r30, 0x01	; 1
    2996:	82 ef       	ldi	r24, 0xF2	; 242
    2998:	94 e0       	ldi	r25, 0x04	; 4
    299a:	ad b7       	in	r26, 0x3d	; 61
    299c:	be b7       	in	r27, 0x3e	; 62
    299e:	12 96       	adiw	r26, 0x02	; 2
    29a0:	9c 93       	st	X, r25
    29a2:	8e 93       	st	-X, r24
    29a4:	11 97       	sbiw	r26, 0x01	; 1
    29a6:	62 83       	std	Z+2, r22	; 0x02
    29a8:	13 82       	std	Z+3, r1	; 0x03
    29aa:	8e e4       	ldi	r24, 0x4E	; 78
    29ac:	94 e0       	ldi	r25, 0x04	; 4
    29ae:	95 83       	std	Z+5, r25	; 0x05
    29b0:	84 83       	std	Z+4, r24	; 0x04
    29b2:	80 91 b2 06 	lds	r24, 0x06B2
    29b6:	86 83       	std	Z+6, r24	; 0x06
    29b8:	17 82       	std	Z+7, r1	; 0x07
    29ba:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>
    29be:	2d b7       	in	r18, 0x3d	; 61
    29c0:	3e b7       	in	r19, 0x3e	; 62
    29c2:	28 5f       	subi	r18, 0xF8	; 248
    29c4:	3f 4f       	sbci	r19, 0xFF	; 255
    29c6:	2a c0       	rjmp	.+84     	; 0x2a1c <process_post+0xba>
	   ev,PROCESS_NAME_STRING(p), nevents);
  } else {
    // PRINTF("process_post: Process '%s' posts event %d to process '%s', nevents %d\n",
    printf("process_post: Process '%s' posts event %d to process '%s', nevents %d\n",
    29c8:	20 97       	sbiw	r28, 0x00	; 0
    29ca:	19 f4       	brne	.+6      	; 0x29d2 <process_post+0x70>
    29cc:	86 ee       	ldi	r24, 0xE6	; 230
    29ce:	94 e0       	ldi	r25, 0x04	; 4
    29d0:	02 c0       	rjmp	.+4      	; 0x29d6 <process_post+0x74>
    29d2:	8e e4       	ldi	r24, 0x4E	; 78
    29d4:	94 e0       	ldi	r25, 0x04	; 4
    29d6:	ad b7       	in	r26, 0x3d	; 61
    29d8:	be b7       	in	r27, 0x3e	; 62
    29da:	1a 97       	sbiw	r26, 0x0a	; 10
    29dc:	0f b6       	in	r0, 0x3f	; 63
    29de:	f8 94       	cli
    29e0:	be bf       	out	0x3e, r27	; 62
    29e2:	0f be       	out	0x3f, r0	; 63
    29e4:	ad bf       	out	0x3d, r26	; 61
    29e6:	ed b7       	in	r30, 0x3d	; 61
    29e8:	fe b7       	in	r31, 0x3e	; 62
    29ea:	31 96       	adiw	r30, 0x01	; 1
    29ec:	29 e3       	ldi	r18, 0x39	; 57
    29ee:	35 e0       	ldi	r19, 0x05	; 5
    29f0:	12 96       	adiw	r26, 0x02	; 2
    29f2:	3c 93       	st	X, r19
    29f4:	2e 93       	st	-X, r18
    29f6:	11 97       	sbiw	r26, 0x01	; 1
    29f8:	2e e4       	ldi	r18, 0x4E	; 78
    29fa:	34 e0       	ldi	r19, 0x04	; 4
    29fc:	33 83       	std	Z+3, r19	; 0x03
    29fe:	22 83       	std	Z+2, r18	; 0x02
    2a00:	f4 82       	std	Z+4, r15	; 0x04
    2a02:	15 82       	std	Z+5, r1	; 0x05
    2a04:	97 83       	std	Z+7, r25	; 0x07
    2a06:	86 83       	std	Z+6, r24	; 0x06
    2a08:	80 91 b2 06 	lds	r24, 0x06B2
    2a0c:	80 87       	std	Z+8, r24	; 0x08
    2a0e:	11 86       	std	Z+9, r1	; 0x09
    2a10:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>
    2a14:	2d b7       	in	r18, 0x3d	; 61
    2a16:	3e b7       	in	r19, 0x3e	; 62
    2a18:	26 5f       	subi	r18, 0xF6	; 246
    2a1a:	3f 4f       	sbci	r19, 0xFF	; 255
    2a1c:	0f b6       	in	r0, 0x3f	; 63
    2a1e:	f8 94       	cli
    2a20:	3e bf       	out	0x3e, r19	; 62
    2a22:	0f be       	out	0x3f, r0	; 63
    2a24:	2d bf       	out	0x3d, r18	; 61
	   PROCESS_NAME_STRING(PROCESS_CURRENT()), ev,
	   p == PROCESS_BROADCAST? "<broadcast>": PROCESS_NAME_STRING(p), nevents);
  }
  
  if(nevents == PROCESS_CONF_NUMEVENTS) {
    2a26:	20 91 b2 06 	lds	r18, 0x06B2
    2a2a:	28 30       	cpi	r18, 0x08	; 8
    2a2c:	01 f1       	breq	.+64     	; 0x2a6e <process_post+0x10c>
    }
#endif /* DEBUG */
    return PROCESS_ERR_FULL;
  }
  
  snum = (process_num_events_t)(fevent + nevents) % PROCESS_CONF_NUMEVENTS;
    2a2e:	80 91 b3 06 	lds	r24, 0x06B3
    2a32:	82 0f       	add	r24, r18
    2a34:	87 70       	andi	r24, 0x07	; 7
    2a36:	80 93 dc 06 	sts	0x06DC, r24
  events[snum].ev = ev;
    2a3a:	90 e0       	ldi	r25, 0x00	; 0
    2a3c:	fc 01       	movw	r30, r24
    2a3e:	ee 0f       	add	r30, r30
    2a40:	ff 1f       	adc	r31, r31
    2a42:	ee 0f       	add	r30, r30
    2a44:	ff 1f       	adc	r31, r31
    2a46:	e8 0f       	add	r30, r24
    2a48:	f9 1f       	adc	r31, r25
    2a4a:	ec 54       	subi	r30, 0x4C	; 76
    2a4c:	f9 4f       	sbci	r31, 0xF9	; 249
    2a4e:	f0 82       	st	Z, r15
  events[snum].data = data;
    2a50:	12 83       	std	Z+2, r17	; 0x02
    2a52:	01 83       	std	Z+1, r16	; 0x01
  events[snum].p = p;
    2a54:	d4 83       	std	Z+4, r29	; 0x04
    2a56:	c3 83       	std	Z+3, r28	; 0x03
  ++nevents;
    2a58:	82 2f       	mov	r24, r18
    2a5a:	8f 5f       	subi	r24, 0xFF	; 255
    2a5c:	80 93 b2 06 	sts	0x06B2, r24

#if PROCESS_CONF_STATS
  if(nevents > process_maxevents) {
    2a60:	90 91 62 0e 	lds	r25, 0x0E62
    2a64:	98 17       	cp	r25, r24
    2a66:	30 f4       	brcc	.+12     	; 0x2a74 <process_post+0x112>
    process_maxevents = nevents;
    2a68:	80 93 62 0e 	sts	0x0E62, r24
    2a6c:	03 c0       	rjmp	.+6      	; 0x2a74 <process_post+0x112>
      printf("soft panic: event queue is full when broadcast event %d was posted from %s\n", ev, PROCESS_NAME_STRING(process_current));
    } else {
      printf("soft panic: event queue is full when event %d was posted to %s frpm %s\n", ev, PROCESS_NAME_STRING(p), PROCESS_NAME_STRING(process_current));
    }
#endif /* DEBUG */
    return PROCESS_ERR_FULL;
    2a6e:	21 e0       	ldi	r18, 0x01	; 1
    2a70:	30 e0       	ldi	r19, 0x00	; 0
    2a72:	02 c0       	rjmp	.+4      	; 0x2a78 <process_post+0x116>
  if(nevents > process_maxevents) {
    process_maxevents = nevents;
  }
#endif /* PROCESS_CONF_STATS */
  
  return PROCESS_ERR_OK;
    2a74:	20 e0       	ldi	r18, 0x00	; 0
    2a76:	30 e0       	ldi	r19, 0x00	; 0
}
    2a78:	c9 01       	movw	r24, r18
    2a7a:	df 91       	pop	r29
    2a7c:	cf 91       	pop	r28
    2a7e:	1f 91       	pop	r17
    2a80:	0f 91       	pop	r16
    2a82:	ff 90       	pop	r15
    2a84:	08 95       	ret

00002a86 <process_post_synch>:
/*---------------------------------------------------------------------------*/
void
process_post_synch(struct process *p, process_event_t ev, process_data_t data)
{
    2a86:	cf 93       	push	r28
    2a88:	df 93       	push	r29
  struct process *caller = process_current;
    2a8a:	c0 91 ad 06 	lds	r28, 0x06AD
    2a8e:	d0 91 ae 06 	lds	r29, 0x06AE

  call_process(p, ev, data);
    2a92:	0e 94 26 13 	call	0x264c	; 0x264c <call_process>
  process_current = caller;
    2a96:	d0 93 ae 06 	sts	0x06AE, r29
    2a9a:	c0 93 ad 06 	sts	0x06AD, r28
}
    2a9e:	df 91       	pop	r29
    2aa0:	cf 91       	pop	r28
    2aa2:	08 95       	ret

00002aa4 <process_start>:
  return lastevent++;
}
/*---------------------------------------------------------------------------*/
void
process_start(struct process *p, const char *arg)
{
    2aa4:	0f 93       	push	r16
    2aa6:	1f 93       	push	r17
    2aa8:	cf 93       	push	r28
    2aaa:	df 93       	push	r29
    2aac:	ec 01       	movw	r28, r24
    2aae:	8b 01       	movw	r16, r22
  struct process *q;

  /* First make sure that we don't try to start a process that is
     already running. */
  for(q = process_list; q != p && q != NULL; q = q->next);
    2ab0:	90 91 ab 06 	lds	r25, 0x06AB
    2ab4:	80 91 ac 06 	lds	r24, 0x06AC
    2ab8:	9c 01       	movw	r18, r24
    2aba:	e3 2f       	mov	r30, r19
    2abc:	f2 2f       	mov	r31, r18
    2abe:	03 c0       	rjmp	.+6      	; 0x2ac6 <process_start+0x22>
    2ac0:	01 90       	ld	r0, Z+
    2ac2:	f0 81       	ld	r31, Z
    2ac4:	e0 2d       	mov	r30, r0
    2ac6:	ec 17       	cp	r30, r28
    2ac8:	fd 07       	cpc	r31, r29
    2aca:	29 f1       	breq	.+74     	; 0x2b16 <process_start+0x72>
    2acc:	30 97       	sbiw	r30, 0x00	; 0
    2ace:	c1 f7       	brne	.-16     	; 0x2ac0 <process_start+0x1c>

  /* If we found the process on the process list, we bail out. */
  if(q == p) {
    2ad0:	20 97       	sbiw	r28, 0x00	; 0
    2ad2:	09 f1       	breq	.+66     	; 0x2b16 <process_start+0x72>
    return;
  }
  /* Put on the procs list.*/
  p->next = process_list;
    2ad4:	98 83       	st	Y, r25
    2ad6:	89 83       	std	Y+1, r24	; 0x01
  process_list = p;
    2ad8:	d0 93 ac 06 	sts	0x06AC, r29
    2adc:	c0 93 ab 06 	sts	0x06AB, r28
  p->state = PROCESS_STATE_RUNNING;
    2ae0:	81 e0       	ldi	r24, 0x01	; 1
    2ae2:	8e 83       	std	Y+6, r24	; 0x06
  PT_INIT(&p->pt);
    2ae4:	1d 82       	std	Y+5, r1	; 0x05
    2ae6:	1c 82       	std	Y+4, r1	; 0x04

  // PRINTF("process: starting '%s'\n", PROCESS_NAME_STRING(p));
  printf("process: starting '%s'\n", PROCESS_NAME_STRING(p));
    2ae8:	00 d0       	rcall	.+0      	; 0x2aea <process_start+0x46>
    2aea:	00 d0       	rcall	.+0      	; 0x2aec <process_start+0x48>
    2aec:	80 e8       	ldi	r24, 0x80	; 128
    2aee:	95 e0       	ldi	r25, 0x05	; 5
    2af0:	ed b7       	in	r30, 0x3d	; 61
    2af2:	fe b7       	in	r31, 0x3e	; 62
    2af4:	92 83       	std	Z+2, r25	; 0x02
    2af6:	81 83       	std	Z+1, r24	; 0x01
    2af8:	8e e4       	ldi	r24, 0x4E	; 78
    2afa:	94 e0       	ldi	r25, 0x04	; 4
    2afc:	94 83       	std	Z+4, r25	; 0x04
    2afe:	83 83       	std	Z+3, r24	; 0x03
    2b00:	0e 94 f5 25 	call	0x4bea	; 0x4bea <printf>

  /* Post a synchronous initialization event to the process. */
  process_post_synch(p, PROCESS_EVENT_INIT, (process_data_t)arg);
    2b04:	0f 90       	pop	r0
    2b06:	0f 90       	pop	r0
    2b08:	0f 90       	pop	r0
    2b0a:	0f 90       	pop	r0
    2b0c:	ce 01       	movw	r24, r28
    2b0e:	61 e8       	ldi	r22, 0x81	; 129
    2b10:	a8 01       	movw	r20, r16
    2b12:	0e 94 43 15 	call	0x2a86	; 0x2a86 <process_post_synch>
}
    2b16:	df 91       	pop	r29
    2b18:	cf 91       	pop	r28
    2b1a:	1f 91       	pop	r17
    2b1c:	0f 91       	pop	r16
    2b1e:	08 95       	ret

00002b20 <process_poll>:
  process_current = caller;
}
/*---------------------------------------------------------------------------*/
void
process_poll(struct process *p)
{
    2b20:	fc 01       	movw	r30, r24
  if(p != NULL) {
    2b22:	00 97       	sbiw	r24, 0x00	; 0
    2b24:	41 f0       	breq	.+16     	; 0x2b36 <process_poll+0x16>
    if(p->state == PROCESS_STATE_RUNNING ||
    2b26:	86 81       	ldd	r24, Z+6	; 0x06
    2b28:	81 50       	subi	r24, 0x01	; 1
    2b2a:	82 30       	cpi	r24, 0x02	; 2
    2b2c:	20 f4       	brcc	.+8      	; 0x2b36 <process_poll+0x16>
       p->state == PROCESS_STATE_CALLED) {
      p->needspoll = 1;
    2b2e:	81 e0       	ldi	r24, 0x01	; 1
    2b30:	87 83       	std	Z+7, r24	; 0x07
      poll_requested = 1;
    2b32:	80 93 b1 06 	sts	0x06B1, r24
    2b36:	08 95       	ret

00002b38 <process_is_running>:
}
/*---------------------------------------------------------------------------*/
int
process_is_running(struct process *p)
{
  return p->state != PROCESS_STATE_NONE;
    2b38:	21 e0       	ldi	r18, 0x01	; 1
    2b3a:	30 e0       	ldi	r19, 0x00	; 0
    2b3c:	fc 01       	movw	r30, r24
    2b3e:	86 81       	ldd	r24, Z+6	; 0x06
    2b40:	88 23       	and	r24, r24
    2b42:	11 f4       	brne	.+4      	; 0x2b48 <process_is_running+0x10>
    2b44:	20 e0       	ldi	r18, 0x00	; 0
    2b46:	30 e0       	ldi	r19, 0x00	; 0
}
    2b48:	c9 01       	movw	r24, r18
    2b4a:	08 95       	ret

00002b4c <process_interrupt>:
/*---------------------------------------------------------------------------*/
void
process_interrupt(struct process *p)
{
    // TODO call init change stack function
    process_current->state = PROCESS_STATE_SUSPENDED;
    2b4c:	e0 91 ad 06 	lds	r30, 0x06AD
    2b50:	f0 91 ae 06 	lds	r31, 0x06AE
    2b54:	25 e0       	ldi	r18, 0x05	; 5
    2b56:	26 83       	std	Z+6, r18	; 0x06
    p->state = PROCESS_STATE_RUNNING;
    2b58:	21 e0       	ldi	r18, 0x01	; 1
    2b5a:	fc 01       	movw	r30, r24
    2b5c:	26 83       	std	Z+6, r18	; 0x06
}
    2b5e:	08 95       	ret

00002b60 <autostart_start>:
#endif

/*---------------------------------------------------------------------------*/
void
autostart_start(struct process * const processes[])
{
    2b60:	ef 92       	push	r14
    2b62:	ff 92       	push	r15
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    2b68:	e8 2e       	mov	r14, r24
    2b6a:	e7 01       	movw	r28, r14
    2b6c:	7e 01       	movw	r14, r28
    2b6e:	f9 2e       	mov	r15, r25
    2b70:	e7 01       	movw	r28, r14
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    2b72:	04 c0       	rjmp	.+8      	; 0x2b7c <autostart_start+0x1c>
    process_start(processes[i], NULL);
    2b74:	60 e0       	ldi	r22, 0x00	; 0
    2b76:	70 e0       	ldi	r23, 0x00	; 0
    2b78:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <process_start>
void
autostart_start(struct process * const processes[])
{
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    2b7c:	89 91       	ld	r24, Y+
    2b7e:	99 91       	ld	r25, Y+
    2b80:	00 97       	sbiw	r24, 0x00	; 0
    2b82:	c1 f7       	brne	.-16     	; 0x2b74 <autostart_start+0x14>
    process_start(processes[i], NULL);
    PRINTF("autostart_start: starting process '%s'\n", processes[i]->name);
  }
}
    2b84:	df 91       	pop	r29
    2b86:	cf 91       	pop	r28
    2b88:	ff 90       	pop	r15
    2b8a:	ef 90       	pop	r14
    2b8c:	08 95       	ret

00002b8e <autostart_exit>:
/*---------------------------------------------------------------------------*/
void
autostart_exit(struct process * const processes[])
{
    2b8e:	ef 92       	push	r14
    2b90:	ff 92       	push	r15
    2b92:	cf 93       	push	r28
    2b94:	df 93       	push	r29
    2b96:	e8 2e       	mov	r14, r24
    2b98:	e7 01       	movw	r28, r14
    2b9a:	7e 01       	movw	r14, r28
    2b9c:	f9 2e       	mov	r15, r25
    2b9e:	e7 01       	movw	r28, r14
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    2ba0:	02 c0       	rjmp	.+4      	; 0x2ba6 <autostart_exit+0x18>
    process_exit(processes[i]);
    2ba2:	0e 94 22 14 	call	0x2844	; 0x2844 <process_exit>
void
autostart_exit(struct process * const processes[])
{
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    2ba6:	89 91       	ld	r24, Y+
    2ba8:	99 91       	ld	r25, Y+
    2baa:	00 97       	sbiw	r24, 0x00	; 0
    2bac:	d1 f7       	brne	.-12     	; 0x2ba2 <autostart_exit+0x14>
    process_exit(processes[i]);
    PRINTF("autostart_exit: stopping process '%s'\n", processes[i]->name);
  }
}
    2bae:	df 91       	pop	r29
    2bb0:	cf 91       	pop	r28
    2bb2:	ff 90       	pop	r15
    2bb4:	ef 90       	pop	r14
    2bb6:	08 95       	ret

00002bb8 <compower_init>:
}
/*---------------------------------------------------------------------------*/
void
compower_clear(struct compower_activity *e)
{
  e->listen = e->transmit = 0;
    2bb8:	10 92 67 0e 	sts	0x0E67, r1
    2bbc:	10 92 68 0e 	sts	0x0E68, r1
    2bc0:	10 92 69 0e 	sts	0x0E69, r1
    2bc4:	10 92 6a 0e 	sts	0x0E6A, r1
    2bc8:	10 92 63 0e 	sts	0x0E63, r1
    2bcc:	10 92 64 0e 	sts	0x0E64, r1
    2bd0:	10 92 65 0e 	sts	0x0E65, r1
    2bd4:	10 92 66 0e 	sts	0x0E66, r1
/*---------------------------------------------------------------------------*/
void
compower_init(void)
{
  compower_clear(&compower_idle_activity);
}
    2bd8:	08 95       	ret

00002bda <compower_accumulate>:
/*---------------------------------------------------------------------------*/
void
compower_accumulate(struct compower_activity *e)
{
    2bda:	ef 92       	push	r14
    2bdc:	ff 92       	push	r15
    2bde:	0f 93       	push	r16
    2be0:	1f 93       	push	r17
    2be2:	cf 93       	push	r28
    2be4:	df 93       	push	r29
    2be6:	ec 01       	movw	r28, r24
  static uint32_t last_listen, last_transmit;
  uint32_t listen, transmit;

  energest_flush();
    2be8:	0e 94 85 19 	call	0x330a	; 0x330a <energest_flush>

  listen = energest_type_time(ENERGEST_TYPE_LISTEN);
    2bec:	87 e0       	ldi	r24, 0x07	; 7
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	0e 94 81 19 	call	0x3302	; 0x3302 <energest_type_time>
    2bf4:	9b 01       	movw	r18, r22
    2bf6:	ac 01       	movw	r20, r24
  e->listen += listen - last_listen;
    2bf8:	88 81       	ld	r24, Y
    2bfa:	99 81       	ldd	r25, Y+1	; 0x01
    2bfc:	aa 81       	ldd	r26, Y+2	; 0x02
    2bfe:	bb 81       	ldd	r27, Y+3	; 0x03
    2c00:	e0 90 e9 06 	lds	r14, 0x06E9
    2c04:	f0 90 ea 06 	lds	r15, 0x06EA
    2c08:	00 91 eb 06 	lds	r16, 0x06EB
    2c0c:	10 91 ec 06 	lds	r17, 0x06EC
    2c10:	8e 19       	sub	r24, r14
    2c12:	9f 09       	sbc	r25, r15
    2c14:	a0 0b       	sbc	r26, r16
    2c16:	b1 0b       	sbc	r27, r17
    2c18:	82 0f       	add	r24, r18
    2c1a:	93 1f       	adc	r25, r19
    2c1c:	a4 1f       	adc	r26, r20
    2c1e:	b5 1f       	adc	r27, r21
    2c20:	88 83       	st	Y, r24
    2c22:	99 83       	std	Y+1, r25	; 0x01
    2c24:	aa 83       	std	Y+2, r26	; 0x02
    2c26:	bb 83       	std	Y+3, r27	; 0x03
  last_listen = listen;
    2c28:	20 93 e9 06 	sts	0x06E9, r18
    2c2c:	30 93 ea 06 	sts	0x06EA, r19
    2c30:	40 93 eb 06 	sts	0x06EB, r20
    2c34:	50 93 ec 06 	sts	0x06EC, r21

  transmit = energest_type_time(ENERGEST_TYPE_TRANSMIT);
    2c38:	86 e0       	ldi	r24, 0x06	; 6
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	0e 94 81 19 	call	0x3302	; 0x3302 <energest_type_time>
    2c40:	9b 01       	movw	r18, r22
    2c42:	ac 01       	movw	r20, r24
  e->transmit += transmit - last_transmit;
    2c44:	8c 81       	ldd	r24, Y+4	; 0x04
    2c46:	9d 81       	ldd	r25, Y+5	; 0x05
    2c48:	ae 81       	ldd	r26, Y+6	; 0x06
    2c4a:	bf 81       	ldd	r27, Y+7	; 0x07
    2c4c:	e0 90 e5 06 	lds	r14, 0x06E5
    2c50:	f0 90 e6 06 	lds	r15, 0x06E6
    2c54:	00 91 e7 06 	lds	r16, 0x06E7
    2c58:	10 91 e8 06 	lds	r17, 0x06E8
    2c5c:	8e 19       	sub	r24, r14
    2c5e:	9f 09       	sbc	r25, r15
    2c60:	a0 0b       	sbc	r26, r16
    2c62:	b1 0b       	sbc	r27, r17
    2c64:	82 0f       	add	r24, r18
    2c66:	93 1f       	adc	r25, r19
    2c68:	a4 1f       	adc	r26, r20
    2c6a:	b5 1f       	adc	r27, r21
    2c6c:	8c 83       	std	Y+4, r24	; 0x04
    2c6e:	9d 83       	std	Y+5, r25	; 0x05
    2c70:	ae 83       	std	Y+6, r26	; 0x06
    2c72:	bf 83       	std	Y+7, r27	; 0x07
  last_transmit = transmit;
    2c74:	20 93 e5 06 	sts	0x06E5, r18
    2c78:	30 93 e6 06 	sts	0x06E6, r19
    2c7c:	40 93 e7 06 	sts	0x06E7, r20
    2c80:	50 93 e8 06 	sts	0x06E8, r21
}
    2c84:	df 91       	pop	r29
    2c86:	cf 91       	pop	r28
    2c88:	1f 91       	pop	r17
    2c8a:	0f 91       	pop	r16
    2c8c:	ff 90       	pop	r15
    2c8e:	ef 90       	pop	r14
    2c90:	08 95       	ret

00002c92 <compower_clear>:
/*---------------------------------------------------------------------------*/
void
compower_clear(struct compower_activity *e)
{
    2c92:	fc 01       	movw	r30, r24
  e->listen = e->transmit = 0;
    2c94:	14 82       	std	Z+4, r1	; 0x04
    2c96:	15 82       	std	Z+5, r1	; 0x05
    2c98:	16 82       	std	Z+6, r1	; 0x06
    2c9a:	17 82       	std	Z+7, r1	; 0x07
    2c9c:	10 82       	st	Z, r1
    2c9e:	11 82       	std	Z+1, r1	; 0x01
    2ca0:	12 82       	std	Z+2, r1	; 0x02
    2ca2:	13 82       	std	Z+3, r1	; 0x03
}
    2ca4:	08 95       	ret

00002ca6 <compower_attrconv>:
/*---------------------------------------------------------------------------*/
void
compower_attrconv(struct compower_activity *e)
{
    2ca6:	fc 01       	movw	r30, r24
  packetbuf_set_attr(PACKETBUF_ATTR_LISTEN_TIME,
    2ca8:	20 81       	ld	r18, Z
    2caa:	31 81       	ldd	r19, Z+1	; 0x01
    2cac:	80 91 81 0e 	lds	r24, 0x0E81
    2cb0:	90 91 82 0e 	lds	r25, 0x0E82
    2cb4:	28 0f       	add	r18, r24
    2cb6:	39 1f       	adc	r19, r25

static inline int
packetbuf_set_attr(uint8_t type, const packetbuf_attr_t val)
{
/*   packetbuf_attrs[type].type = type; */
  packetbuf_attrs[type].val = val;
    2cb8:	30 93 82 0e 	sts	0x0E82, r19
    2cbc:	20 93 81 0e 	sts	0x0E81, r18
                     packetbuf_attr(PACKETBUF_ATTR_LISTEN_TIME) + e->listen);
  packetbuf_set_attr(PACKETBUF_ATTR_TRANSMIT_TIME,
    2cc0:	84 81       	ldd	r24, Z+4	; 0x04
    2cc2:	95 81       	ldd	r25, Z+5	; 0x05
    2cc4:	20 91 83 0e 	lds	r18, 0x0E83
    2cc8:	30 91 84 0e 	lds	r19, 0x0E84
    2ccc:	82 0f       	add	r24, r18
    2cce:	93 1f       	adc	r25, r19
    2cd0:	90 93 84 0e 	sts	0x0E84, r25
    2cd4:	80 93 83 0e 	sts	0x0E83, r24
                     packetbuf_attr(PACKETBUF_ATTR_TRANSMIT_TIME) + e->transmit);
}
    2cd8:	08 95       	ret

00002cda <compower_accumulate_attrs>:
/*---------------------------------------------------------------------------*/
void
compower_accumulate_attrs(struct compower_activity *e)
{
    2cda:	fc 01       	movw	r30, r24
  e->listen += packetbuf_attr(PACKETBUF_ATTR_LISTEN_TIME);
    2cdc:	80 91 81 0e 	lds	r24, 0x0E81
    2ce0:	90 91 82 0e 	lds	r25, 0x0E82
    2ce4:	a0 e0       	ldi	r26, 0x00	; 0
    2ce6:	b0 e0       	ldi	r27, 0x00	; 0
    2ce8:	20 81       	ld	r18, Z
    2cea:	31 81       	ldd	r19, Z+1	; 0x01
    2cec:	42 81       	ldd	r20, Z+2	; 0x02
    2cee:	53 81       	ldd	r21, Z+3	; 0x03
    2cf0:	28 0f       	add	r18, r24
    2cf2:	39 1f       	adc	r19, r25
    2cf4:	4a 1f       	adc	r20, r26
    2cf6:	5b 1f       	adc	r21, r27
    2cf8:	20 83       	st	Z, r18
    2cfa:	31 83       	std	Z+1, r19	; 0x01
    2cfc:	42 83       	std	Z+2, r20	; 0x02
    2cfe:	53 83       	std	Z+3, r21	; 0x03
  e->transmit += packetbuf_attr(PACKETBUF_ATTR_TRANSMIT_TIME);
    2d00:	60 91 83 0e 	lds	r22, 0x0E83
    2d04:	70 91 84 0e 	lds	r23, 0x0E84
    2d08:	80 e0       	ldi	r24, 0x00	; 0
    2d0a:	90 e0       	ldi	r25, 0x00	; 0
    2d0c:	24 81       	ldd	r18, Z+4	; 0x04
    2d0e:	35 81       	ldd	r19, Z+5	; 0x05
    2d10:	46 81       	ldd	r20, Z+6	; 0x06
    2d12:	57 81       	ldd	r21, Z+7	; 0x07
    2d14:	26 0f       	add	r18, r22
    2d16:	37 1f       	adc	r19, r23
    2d18:	48 1f       	adc	r20, r24
    2d1a:	59 1f       	adc	r21, r25
    2d1c:	24 83       	std	Z+4, r18	; 0x04
    2d1e:	35 83       	std	Z+5, r19	; 0x05
    2d20:	46 83       	std	Z+6, r20	; 0x06
    2d22:	57 83       	std	Z+7, r21	; 0x07
}
    2d24:	08 95       	ret

00002d26 <memb_init>:
#include "lib/memb.h"

/*---------------------------------------------------------------------------*/
void
memb_init(struct memb *m)
{
    2d26:	cf 93       	push	r28
    2d28:	df 93       	push	r29
    2d2a:	ec 01       	movw	r28, r24
  memset(m->count, 0, m->num);
    2d2c:	4a 81       	ldd	r20, Y+2	; 0x02
    2d2e:	5b 81       	ldd	r21, Y+3	; 0x03
    2d30:	8c 81       	ldd	r24, Y+4	; 0x04
    2d32:	9d 81       	ldd	r25, Y+5	; 0x05
    2d34:	60 e0       	ldi	r22, 0x00	; 0
    2d36:	70 e0       	ldi	r23, 0x00	; 0
    2d38:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <memset>
  memset(m->mem, 0, m->size * m->num);
    2d3c:	4a 81       	ldd	r20, Y+2	; 0x02
    2d3e:	5b 81       	ldd	r21, Y+3	; 0x03
    2d40:	88 81       	ld	r24, Y
    2d42:	99 81       	ldd	r25, Y+1	; 0x01
    2d44:	48 9f       	mul	r20, r24
    2d46:	90 01       	movw	r18, r0
    2d48:	49 9f       	mul	r20, r25
    2d4a:	30 0d       	add	r19, r0
    2d4c:	58 9f       	mul	r21, r24
    2d4e:	30 0d       	add	r19, r0
    2d50:	11 24       	eor	r1, r1
    2d52:	8e 81       	ldd	r24, Y+6	; 0x06
    2d54:	9f 81       	ldd	r25, Y+7	; 0x07
    2d56:	60 e0       	ldi	r22, 0x00	; 0
    2d58:	70 e0       	ldi	r23, 0x00	; 0
    2d5a:	a9 01       	movw	r20, r18
    2d5c:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <memset>
}
    2d60:	df 91       	pop	r29
    2d62:	cf 91       	pop	r28
    2d64:	08 95       	ret

00002d66 <memb_alloc>:
/*---------------------------------------------------------------------------*/
void *
memb_alloc(struct memb *m)
{
    2d66:	fc 01       	movw	r30, r24
  int i;

  for(i = 0; i < m->num; ++i) {
    2d68:	82 81       	ldd	r24, Z+2	; 0x02
    2d6a:	93 81       	ldd	r25, Z+3	; 0x03
    2d6c:	20 e0       	ldi	r18, 0x00	; 0
    2d6e:	30 e0       	ldi	r19, 0x00	; 0
    2d70:	19 c0       	rjmp	.+50     	; 0x2da4 <memb_alloc+0x3e>
    if(m->count[i] == 0) {
    2d72:	a4 81       	ldd	r26, Z+4	; 0x04
    2d74:	b5 81       	ldd	r27, Z+5	; 0x05
    2d76:	a2 0f       	add	r26, r18
    2d78:	b3 1f       	adc	r27, r19
    2d7a:	4c 91       	ld	r20, X
    2d7c:	44 23       	and	r20, r20
    2d7e:	81 f4       	brne	.+32     	; 0x2da0 <memb_alloc+0x3a>
      /* If this block was unused, we increase the reference count to
	 indicate that it now is used and return a pointer to the
	 memory block. */
      ++(m->count[i]);
    2d80:	81 e0       	ldi	r24, 0x01	; 1
    2d82:	8c 93       	st	X, r24
      return (void *)((char *)m->mem + (i * m->size));
    2d84:	40 81       	ld	r20, Z
    2d86:	51 81       	ldd	r21, Z+1	; 0x01
    2d88:	24 9f       	mul	r18, r20
    2d8a:	c0 01       	movw	r24, r0
    2d8c:	25 9f       	mul	r18, r21
    2d8e:	90 0d       	add	r25, r0
    2d90:	34 9f       	mul	r19, r20
    2d92:	90 0d       	add	r25, r0
    2d94:	11 24       	eor	r1, r1
    2d96:	26 81       	ldd	r18, Z+6	; 0x06
    2d98:	37 81       	ldd	r19, Z+7	; 0x07
    2d9a:	28 0f       	add	r18, r24
    2d9c:	39 1f       	adc	r19, r25
    2d9e:	07 c0       	rjmp	.+14     	; 0x2dae <memb_alloc+0x48>
void *
memb_alloc(struct memb *m)
{
  int i;

  for(i = 0; i < m->num; ++i) {
    2da0:	2f 5f       	subi	r18, 0xFF	; 255
    2da2:	3f 4f       	sbci	r19, 0xFF	; 255
    2da4:	28 17       	cp	r18, r24
    2da6:	39 07       	cpc	r19, r25
    2da8:	20 f3       	brcs	.-56     	; 0x2d72 <memb_alloc+0xc>
    }
  }

  /* No free block was found, so we return NULL to indicate failure to
     allocate block. */
  return NULL;
    2daa:	20 e0       	ldi	r18, 0x00	; 0
    2dac:	30 e0       	ldi	r19, 0x00	; 0
}
    2dae:	c9 01       	movw	r24, r18
    2db0:	08 95       	ret

00002db2 <memb_free>:
/*---------------------------------------------------------------------------*/
char
memb_free(struct memb *m, void *ptr)
{
    2db2:	fc 01       	movw	r30, r24
  int i;
  char *ptr2;

  /* Walk through the list of blocks and try to find the block to
     which the pointer "ptr" points to. */
  ptr2 = (char *)m->mem;
    2db4:	26 81       	ldd	r18, Z+6	; 0x06
    2db6:	37 81       	ldd	r19, Z+7	; 0x07
  for(i = 0; i < m->num; ++i) {
    2db8:	42 81       	ldd	r20, Z+2	; 0x02
    2dba:	53 81       	ldd	r21, Z+3	; 0x03
    2dbc:	80 e0       	ldi	r24, 0x00	; 0
    2dbe:	90 e0       	ldi	r25, 0x00	; 0
    2dc0:	18 c0       	rjmp	.+48     	; 0x2df2 <memb_free+0x40>
    
    if(ptr2 == (char *)ptr) {
    2dc2:	26 17       	cp	r18, r22
    2dc4:	37 07       	cpc	r19, r23
    2dc6:	81 f4       	brne	.+32     	; 0x2de8 <memb_free+0x36>
      /* We've found to block to which "ptr" points so we decrease the
	 reference count and return the new value of it. */
      if(m->count[i] > 0) {
    2dc8:	a4 81       	ldd	r26, Z+4	; 0x04
    2dca:	b5 81       	ldd	r27, Z+5	; 0x05
    2dcc:	a8 0f       	add	r26, r24
    2dce:	b9 1f       	adc	r27, r25
    2dd0:	2c 91       	ld	r18, X
    2dd2:	12 16       	cp	r1, r18
    2dd4:	14 f4       	brge	.+4      	; 0x2dda <memb_free+0x28>
	/* Make sure that we don't deallocate free memory. */
	--(m->count[i]);
    2dd6:	21 50       	subi	r18, 0x01	; 1
    2dd8:	2c 93       	st	X, r18
      }
      return m->count[i];
    2dda:	04 80       	ldd	r0, Z+4	; 0x04
    2ddc:	f5 81       	ldd	r31, Z+5	; 0x05
    2dde:	e0 2d       	mov	r30, r0
    2de0:	e8 0f       	add	r30, r24
    2de2:	f9 1f       	adc	r31, r25
    2de4:	80 81       	ld	r24, Z
    2de6:	08 95       	ret
    }
    ptr2 += m->size;
    2de8:	a0 81       	ld	r26, Z
    2dea:	b1 81       	ldd	r27, Z+1	; 0x01
    2dec:	2a 0f       	add	r18, r26
    2dee:	3b 1f       	adc	r19, r27
  char *ptr2;

  /* Walk through the list of blocks and try to find the block to
     which the pointer "ptr" points to. */
  ptr2 = (char *)m->mem;
  for(i = 0; i < m->num; ++i) {
    2df0:	01 96       	adiw	r24, 0x01	; 1
    2df2:	84 17       	cp	r24, r20
    2df4:	95 07       	cpc	r25, r21
    2df6:	28 f3       	brcs	.-54     	; 0x2dc2 <memb_free+0x10>
      }
      return m->count[i];
    }
    ptr2 += m->size;
  }
  return -1;
    2df8:	8f ef       	ldi	r24, 0xFF	; 255
}
    2dfa:	08 95       	ret

00002dfc <memb_inmemb>:
/*---------------------------------------------------------------------------*/
int
memb_inmemb(struct memb *m, void *ptr)
{
    2dfc:	fc 01       	movw	r30, r24
  return (char *)ptr >= (char *)m->mem &&
    2dfe:	cb 01       	movw	r24, r22
    2e00:	26 81       	ldd	r18, Z+6	; 0x06
    2e02:	37 81       	ldd	r19, Z+7	; 0x07
    2e04:	62 17       	cp	r22, r18
    2e06:	73 07       	cpc	r23, r19
    2e08:	90 f0       	brcs	.+36     	; 0x2e2e <memb_inmemb+0x32>
    (char *)ptr < (char *)m->mem + (m->num * m->size);
    2e0a:	a0 81       	ld	r26, Z
    2e0c:	b1 81       	ldd	r27, Z+1	; 0x01
    2e0e:	62 81       	ldd	r22, Z+2	; 0x02
    2e10:	73 81       	ldd	r23, Z+3	; 0x03
    2e12:	a6 9f       	mul	r26, r22
    2e14:	a0 01       	movw	r20, r0
    2e16:	a7 9f       	mul	r26, r23
    2e18:	50 0d       	add	r21, r0
    2e1a:	b6 9f       	mul	r27, r22
    2e1c:	50 0d       	add	r21, r0
    2e1e:	11 24       	eor	r1, r1
    2e20:	42 0f       	add	r20, r18
    2e22:	53 1f       	adc	r21, r19
  }
  return -1;
}
/*---------------------------------------------------------------------------*/
int
memb_inmemb(struct memb *m, void *ptr)
    2e24:	21 e0       	ldi	r18, 0x01	; 1
    2e26:	30 e0       	ldi	r19, 0x00	; 0
    2e28:	84 17       	cp	r24, r20
    2e2a:	95 07       	cpc	r25, r21
    2e2c:	10 f0       	brcs	.+4      	; 0x2e32 <memb_inmemb+0x36>
{
  return (char *)ptr >= (char *)m->mem &&
    2e2e:	20 e0       	ldi	r18, 0x00	; 0
    2e30:	30 e0       	ldi	r19, 0x00	; 0
    (char *)ptr < (char *)m->mem + (m->num * m->size);
}
    2e32:	c9 01       	movw	r24, r18
    2e34:	08 95       	ret

00002e36 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    2e36:	cf 93       	push	r28
    2e38:	df 93       	push	r29
    2e3a:	ec 01       	movw	r28, r24
  t->interval = interval;
    2e3c:	7b 83       	std	Y+3, r23	; 0x03
    2e3e:	6a 83       	std	Y+2, r22	; 0x02
  t->start = clock_time();
    2e40:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <clock_time>
    2e44:	99 83       	std	Y+1, r25	; 0x01
    2e46:	88 83       	st	Y, r24
}
    2e48:	df 91       	pop	r29
    2e4a:	cf 91       	pop	r28
    2e4c:	08 95       	ret

00002e4e <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    2e4e:	fc 01       	movw	r30, r24
  t->start += t->interval;
    2e50:	80 81       	ld	r24, Z
    2e52:	91 81       	ldd	r25, Z+1	; 0x01
    2e54:	22 81       	ldd	r18, Z+2	; 0x02
    2e56:	33 81       	ldd	r19, Z+3	; 0x03
    2e58:	82 0f       	add	r24, r18
    2e5a:	93 1f       	adc	r25, r19
    2e5c:	91 83       	std	Z+1, r25	; 0x01
    2e5e:	80 83       	st	Z, r24
}
    2e60:	08 95       	ret

00002e62 <timer_restart>:
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
    2e62:	cf 93       	push	r28
    2e64:	df 93       	push	r29
    2e66:	ec 01       	movw	r28, r24
  t->start = clock_time();
    2e68:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <clock_time>
    2e6c:	99 83       	std	Y+1, r25	; 0x01
    2e6e:	88 83       	st	Y, r24
}
    2e70:	df 91       	pop	r29
    2e72:	cf 91       	pop	r28
    2e74:	08 95       	ret

00002e76 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    2e76:	cf 93       	push	r28
    2e78:	df 93       	push	r29
    2e7a:	ec 01       	movw	r28, r24
  /* Note: Can not return diff >= t->interval so we add 1 to diff and return
     t->interval < diff - required to avoid an internal error in mspgcc. */
  clock_time_t diff = (clock_time() - t->start) + 1;
    2e7c:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <clock_time>
    2e80:	28 81       	ld	r18, Y
    2e82:	39 81       	ldd	r19, Y+1	; 0x01
    2e84:	82 1b       	sub	r24, r18
    2e86:	93 0b       	sbc	r25, r19
    2e88:	01 96       	adiw	r24, 0x01	; 1
  return t->interval < diff;
    2e8a:	21 e0       	ldi	r18, 0x01	; 1
    2e8c:	30 e0       	ldi	r19, 0x00	; 0
    2e8e:	4a 81       	ldd	r20, Y+2	; 0x02
    2e90:	5b 81       	ldd	r21, Y+3	; 0x03
    2e92:	48 17       	cp	r20, r24
    2e94:	59 07       	cpc	r21, r25
    2e96:	10 f0       	brcs	.+4      	; 0x2e9c <timer_expired+0x26>
    2e98:	20 e0       	ldi	r18, 0x00	; 0
    2e9a:	30 e0       	ldi	r19, 0x00	; 0

}
    2e9c:	c9 01       	movw	r24, r18
    2e9e:	df 91       	pop	r29
    2ea0:	cf 91       	pop	r28
    2ea2:	08 95       	ret

00002ea4 <timer_remaining>:
 * \return The time until the timer expires
 *
 */
clock_time_t
timer_remaining(struct timer *t)
{
    2ea4:	ef 92       	push	r14
    2ea6:	ff 92       	push	r15
    2ea8:	cf 93       	push	r28
    2eaa:	df 93       	push	r29
    2eac:	fc 01       	movw	r30, r24
  return t->start + t->interval - clock_time();
    2eae:	c2 81       	ldd	r28, Z+2	; 0x02
    2eb0:	d3 81       	ldd	r29, Z+3	; 0x03
    2eb2:	80 81       	ld	r24, Z
    2eb4:	91 81       	ldd	r25, Z+1	; 0x01
    2eb6:	c8 0f       	add	r28, r24
    2eb8:	d9 1f       	adc	r29, r25
    2eba:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <clock_time>
    2ebe:	c8 1b       	sub	r28, r24
    2ec0:	d9 0b       	sbc	r29, r25
}
    2ec2:	ce 01       	movw	r24, r28
    2ec4:	df 91       	pop	r29
    2ec6:	cf 91       	pop	r28
    2ec8:	ff 90       	pop	r15
    2eca:	ef 90       	pop	r14
    2ecc:	08 95       	ret

00002ece <list_init>:
 * \param list The list to be initialized.
 */
void
list_init(list_t list)
{
  *list = NULL;
    2ece:	fc 01       	movw	r30, r24
    2ed0:	11 82       	std	Z+1, r1	; 0x01
    2ed2:	10 82       	st	Z, r1
}
    2ed4:	08 95       	ret

00002ed6 <list_head>:
 *
 * \sa list_tail()
 */
void *
list_head(list_t list)
{
    2ed6:	fc 01       	movw	r30, r24
  return *list;
}
    2ed8:	80 81       	ld	r24, Z
    2eda:	91 81       	ldd	r25, Z+1	; 0x01
    2edc:	08 95       	ret

00002ede <list_copy>:
 * \param src The source list.
 */
void
list_copy(list_t dest, list_t src)
{
  *dest = *src;
    2ede:	fb 01       	movw	r30, r22
    2ee0:	20 81       	ld	r18, Z
    2ee2:	31 81       	ldd	r19, Z+1	; 0x01
    2ee4:	fc 01       	movw	r30, r24
    2ee6:	31 83       	std	Z+1, r19	; 0x01
    2ee8:	20 83       	st	Z, r18
}
    2eea:	08 95       	ret

00002eec <list_tail>:
void *
list_tail(list_t list)
{
  struct list *l;
  
  if(*list == NULL) {
    2eec:	fc 01       	movw	r30, r24
    2eee:	20 81       	ld	r18, Z
    2ef0:	31 81       	ldd	r19, Z+1	; 0x01
    2ef2:	21 15       	cp	r18, r1
    2ef4:	31 05       	cpc	r19, r1
    2ef6:	11 f4       	brne	.+4      	; 0x2efc <list_tail+0x10>
    2ef8:	07 c0       	rjmp	.+14     	; 0x2f08 <list_tail+0x1c>
    return NULL;
  }
  
  for(l = *list; l->next != NULL; l = l->next);
    2efa:	9c 01       	movw	r18, r24
    2efc:	f9 01       	movw	r30, r18
    2efe:	80 81       	ld	r24, Z
    2f00:	91 81       	ldd	r25, Z+1	; 0x01
    2f02:	00 97       	sbiw	r24, 0x00	; 0
    2f04:	d1 f7       	brne	.-12     	; 0x2efa <list_tail+0xe>
    2f06:	02 c0       	rjmp	.+4      	; 0x2f0c <list_tail+0x20>
list_tail(list_t list)
{
  struct list *l;
  
  if(*list == NULL) {
    return NULL;
    2f08:	20 e0       	ldi	r18, 0x00	; 0
    2f0a:	30 e0       	ldi	r19, 0x00	; 0
  }
  
  for(l = *list; l->next != NULL; l = l->next);
  
  return l;
}
    2f0c:	c9 01       	movw	r24, r18
    2f0e:	08 95       	ret

00002f10 <list_chop>:
 * \return The removed object
 *
 */
void *
list_chop(list_t list)
{
    2f10:	cf 93       	push	r28
    2f12:	df 93       	push	r29
    2f14:	dc 01       	movw	r26, r24
  struct list *l, *r;
  
  if(*list == NULL) {
    2f16:	2d 91       	ld	r18, X+
    2f18:	3c 91       	ld	r19, X
    2f1a:	11 97       	sbiw	r26, 0x01	; 1
    2f1c:	21 15       	cp	r18, r1
    2f1e:	31 05       	cpc	r19, r1
    2f20:	a9 f0       	breq	.+42     	; 0x2f4c <list_chop+0x3c>
    return NULL;
  }
  if(((struct list *)*list)->next == NULL) {
    2f22:	f9 01       	movw	r30, r18
    2f24:	80 81       	ld	r24, Z
    2f26:	91 81       	ldd	r25, Z+1	; 0x01
    2f28:	00 97       	sbiw	r24, 0x00	; 0
    2f2a:	29 f4       	brne	.+10     	; 0x2f36 <list_chop+0x26>
    l = *list;
    *list = NULL;
    2f2c:	11 96       	adiw	r26, 0x01	; 1
    2f2e:	1c 92       	st	X, r1
    2f30:	1e 92       	st	-X, r1
    return l;
    2f32:	0e c0       	rjmp	.+28     	; 0x2f50 <list_chop+0x40>
  }
  
  for(l = *list; l->next->next != NULL; l = l->next);
    2f34:	f9 01       	movw	r30, r18
    2f36:	20 81       	ld	r18, Z
    2f38:	31 81       	ldd	r19, Z+1	; 0x01
    2f3a:	d9 01       	movw	r26, r18
    2f3c:	8d 91       	ld	r24, X+
    2f3e:	9c 91       	ld	r25, X
    2f40:	11 97       	sbiw	r26, 0x01	; 1
    2f42:	00 97       	sbiw	r24, 0x00	; 0
    2f44:	b9 f7       	brne	.-18     	; 0x2f34 <list_chop+0x24>

  r = l->next;
  l->next = NULL;
    2f46:	11 82       	std	Z+1, r1	; 0x01
    2f48:	10 82       	st	Z, r1
  
  return r;
    2f4a:	02 c0       	rjmp	.+4      	; 0x2f50 <list_chop+0x40>
list_chop(list_t list)
{
  struct list *l, *r;
  
  if(*list == NULL) {
    return NULL;
    2f4c:	20 e0       	ldi	r18, 0x00	; 0
    2f4e:	30 e0       	ldi	r19, 0x00	; 0

  r = l->next;
  l->next = NULL;
  
  return r;
}
    2f50:	c9 01       	movw	r24, r18
    2f52:	df 91       	pop	r29
    2f54:	cf 91       	pop	r28
    2f56:	08 95       	ret

00002f58 <list_pop>:
 * \return Pointer to the removed element of list.
 */
/*---------------------------------------------------------------------------*/
void *
list_pop(list_t list)
{
    2f58:	dc 01       	movw	r26, r24
  struct list *l;
  l = *list;
    2f5a:	ed 91       	ld	r30, X+
    2f5c:	fc 91       	ld	r31, X
    2f5e:	11 97       	sbiw	r26, 0x01	; 1
  if(*list != NULL) {
    2f60:	30 97       	sbiw	r30, 0x00	; 0
    2f62:	29 f0       	breq	.+10     	; 0x2f6e <list_pop+0x16>
    *list = ((struct list *)*list)->next;
    2f64:	80 81       	ld	r24, Z
    2f66:	91 81       	ldd	r25, Z+1	; 0x01
    2f68:	11 96       	adiw	r26, 0x01	; 1
    2f6a:	9c 93       	st	X, r25
    2f6c:	8e 93       	st	-X, r24
  }

  return l;
}
    2f6e:	cf 01       	movw	r24, r30
    2f70:	08 95       	ret

00002f72 <list_remove>:
 *
 */
/*---------------------------------------------------------------------------*/
void
list_remove(list_t list, void *item)
{
    2f72:	cf 93       	push	r28
    2f74:	df 93       	push	r29
    2f76:	fc 01       	movw	r30, r24
  struct list *l, *r;
  
  if(*list == NULL) {
    2f78:	a0 81       	ld	r26, Z
    2f7a:	b1 81       	ldd	r27, Z+1	; 0x01
    2f7c:	10 97       	sbiw	r26, 0x00	; 0
    2f7e:	d9 f0       	breq	.+54     	; 0x2fb6 <list_remove+0x44>
    return;
  }
  
  r = NULL;
    2f80:	c0 e0       	ldi	r28, 0x00	; 0
    2f82:	d0 e0       	ldi	r29, 0x00	; 0
  for(l = *list; l != NULL; l = l->next) {
    2f84:	16 c0       	rjmp	.+44     	; 0x2fb2 <list_remove+0x40>
    if(l == item) {
    2f86:	a6 17       	cp	r26, r22
    2f88:	b7 07       	cpc	r27, r23
    2f8a:	71 f4       	brne	.+28     	; 0x2fa8 <list_remove+0x36>
    2f8c:	8d 91       	ld	r24, X+
    2f8e:	9c 91       	ld	r25, X
    2f90:	11 97       	sbiw	r26, 0x01	; 1
      if(r == NULL) {
    2f92:	20 97       	sbiw	r28, 0x00	; 0
    2f94:	19 f4       	brne	.+6      	; 0x2f9c <list_remove+0x2a>
	/* First on list */
	*list = l->next;
    2f96:	91 83       	std	Z+1, r25	; 0x01
    2f98:	80 83       	st	Z, r24
    2f9a:	02 c0       	rjmp	.+4      	; 0x2fa0 <list_remove+0x2e>
      } else {
	/* Not first on list */
	r->next = l->next;
    2f9c:	99 83       	std	Y+1, r25	; 0x01
    2f9e:	88 83       	st	Y, r24
      }
      l->next = NULL;
    2fa0:	11 96       	adiw	r26, 0x01	; 1
    2fa2:	1c 92       	st	X, r1
    2fa4:	1e 92       	st	-X, r1
      return;
    2fa6:	07 c0       	rjmp	.+14     	; 0x2fb6 <list_remove+0x44>
  if(*list == NULL) {
    return;
  }
  
  r = NULL;
  for(l = *list; l != NULL; l = l->next) {
    2fa8:	ed 01       	movw	r28, r26
    2faa:	98 81       	ld	r25, Y
    2fac:	89 81       	ldd	r24, Y+1	; 0x01
    2fae:	a9 2f       	mov	r26, r25
    2fb0:	b8 2f       	mov	r27, r24
    2fb2:	10 97       	sbiw	r26, 0x00	; 0
    2fb4:	41 f7       	brne	.-48     	; 0x2f86 <list_remove+0x14>
      l->next = NULL;
      return;
    }
    r = l;
  }
}
    2fb6:	df 91       	pop	r29
    2fb8:	cf 91       	pop	r28
    2fba:	08 95       	ret

00002fbc <list_push>:
/**
 * Add an item to the start of the list.
 */
void
list_push(list_t list, void *item)
{
    2fbc:	0f 93       	push	r16
    2fbe:	1f 93       	push	r17
    2fc0:	cf 93       	push	r28
    2fc2:	df 93       	push	r29
    2fc4:	8c 01       	movw	r16, r24
    2fc6:	eb 01       	movw	r28, r22
  /*  struct list *l;*/

  /* Make sure not to add the same element twice */
  list_remove(list, item);
    2fc8:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>

  ((struct list *)item)->next = *list;
    2fcc:	f8 01       	movw	r30, r16
    2fce:	80 81       	ld	r24, Z
    2fd0:	91 81       	ldd	r25, Z+1	; 0x01
    2fd2:	99 83       	std	Y+1, r25	; 0x01
    2fd4:	88 83       	st	Y, r24
  *list = item;
    2fd6:	d1 83       	std	Z+1, r29	; 0x01
    2fd8:	c0 83       	st	Z, r28
}
    2fda:	df 91       	pop	r29
    2fdc:	cf 91       	pop	r28
    2fde:	1f 91       	pop	r17
    2fe0:	0f 91       	pop	r16
    2fe2:	08 95       	ret

00002fe4 <list_add>:
 * \sa list_push()
 *
 */
void
list_add(list_t list, void *item)
{
    2fe4:	ef 92       	push	r14
    2fe6:	ff 92       	push	r15
    2fe8:	0f 93       	push	r16
    2fea:	1f 93       	push	r17
    2fec:	cf 93       	push	r28
    2fee:	df 93       	push	r29
    2ff0:	ec 01       	movw	r28, r24
    2ff2:	7b 01       	movw	r14, r22
  struct list *l;

  /* Make sure not to add the same element twice */
  list_remove(list, item);
    2ff4:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>

  ((struct list *)item)->next = NULL;
    2ff8:	f7 01       	movw	r30, r14
    2ffa:	11 82       	std	Z+1, r1	; 0x01
    2ffc:	10 82       	st	Z, r1
  
  l = list_tail(list);
    2ffe:	ce 01       	movw	r24, r28
    3000:	0e 94 76 17 	call	0x2eec	; 0x2eec <list_tail>
    3004:	fc 01       	movw	r30, r24

  if(l == NULL) {
    3006:	00 97       	sbiw	r24, 0x00	; 0
    3008:	19 f4       	brne	.+6      	; 0x3010 <list_add+0x2c>
    *list = item;
    300a:	e8 82       	st	Y, r14
    300c:	f9 82       	std	Y+1, r15	; 0x01
    300e:	02 c0       	rjmp	.+4      	; 0x3014 <list_add+0x30>
  } else {
    l->next = item;
    3010:	f1 82       	std	Z+1, r15	; 0x01
    3012:	e0 82       	st	Z, r14
  }
}
    3014:	df 91       	pop	r29
    3016:	cf 91       	pop	r28
    3018:	1f 91       	pop	r17
    301a:	0f 91       	pop	r16
    301c:	ff 90       	pop	r15
    301e:	ef 90       	pop	r14
    3020:	08 95       	ret

00003022 <list_length>:
list_length(list_t list)
{
  struct list *l;
  int n = 0;

  for(l = *list; l != NULL; l = l->next) {
    3022:	dc 01       	movw	r26, r24
    3024:	ed 91       	ld	r30, X+
    3026:	fc 91       	ld	r31, X
    3028:	11 97       	sbiw	r26, 0x01	; 1
/*---------------------------------------------------------------------------*/
int
list_length(list_t list)
{
  struct list *l;
  int n = 0;
    302a:	20 e0       	ldi	r18, 0x00	; 0
    302c:	30 e0       	ldi	r19, 0x00	; 0

  for(l = *list; l != NULL; l = l->next) {
    302e:	05 c0       	rjmp	.+10     	; 0x303a <list_length+0x18>
    ++n;
    3030:	2f 5f       	subi	r18, 0xFF	; 255
    3032:	3f 4f       	sbci	r19, 0xFF	; 255
list_length(list_t list)
{
  struct list *l;
  int n = 0;

  for(l = *list; l != NULL; l = l->next) {
    3034:	01 90       	ld	r0, Z+
    3036:	f0 81       	ld	r31, Z
    3038:	e0 2d       	mov	r30, r0
    303a:	30 97       	sbiw	r30, 0x00	; 0
    303c:	c9 f7       	brne	.-14     	; 0x3030 <list_length+0xe>
    ++n;
  }

  return n;
}
    303e:	c9 01       	movw	r24, r18
    3040:	08 95       	ret

00003042 <list_insert>:
 *             start of the list.
 *
 */
void
list_insert(list_t list, void *previtem, void *newitem)
{
    3042:	fb 01       	movw	r30, r22
  if(previtem == NULL) {
    3044:	30 97       	sbiw	r30, 0x00	; 0
    3046:	21 f4       	brne	.+8      	; 0x3050 <list_insert+0xe>
    list_push(list, newitem);
    3048:	ba 01       	movw	r22, r20
    304a:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <list_push>
    304e:	08 95       	ret
  } else {
  
    ((struct list *)newitem)->next = ((struct list *)previtem)->next;
    3050:	da 01       	movw	r26, r20
    3052:	80 81       	ld	r24, Z
    3054:	91 81       	ldd	r25, Z+1	; 0x01
    3056:	11 96       	adiw	r26, 0x01	; 1
    3058:	9c 93       	st	X, r25
    305a:	8e 93       	st	-X, r24
    ((struct list *)previtem)->next = newitem;
    305c:	51 83       	std	Z+1, r21	; 0x01
    305e:	40 83       	st	Z, r20
    3060:	08 95       	ret

00003062 <list_item_next>:
 *             lists.
 */
void *
list_item_next(void *item)
{
  return item == NULL? NULL: ((struct list *)item)->next;
    3062:	00 97       	sbiw	r24, 0x00	; 0
    3064:	21 f0       	breq	.+8      	; 0x306e <list_item_next+0xc>
    3066:	fc 01       	movw	r30, r24
    3068:	20 81       	ld	r18, Z
    306a:	31 81       	ldd	r19, Z+1	; 0x01
    306c:	02 c0       	rjmp	.+4      	; 0x3072 <list_item_next+0x10>
    306e:	20 e0       	ldi	r18, 0x00	; 0
    3070:	30 e0       	ldi	r19, 0x00	; 0
}
    3072:	c9 01       	movw	r24, r18
    3074:	08 95       	ret

00003076 <process_thread_ctimer_process>:
#endif

/*---------------------------------------------------------------------------*/
PROCESS(ctimer_process, "Ctimer process");
PROCESS_THREAD(ctimer_process, ev, data)
{
    3076:	cf 92       	push	r12
    3078:	df 92       	push	r13
    307a:	ef 92       	push	r14
    307c:	ff 92       	push	r15
    307e:	0f 93       	push	r16
    3080:	1f 93       	push	r17
    3082:	cf 93       	push	r28
    3084:	df 93       	push	r29
    3086:	8c 01       	movw	r16, r24
    3088:	7a 01       	movw	r14, r20
  struct ctimer *c;
  PROCESS_BEGIN();
    308a:	fc 01       	movw	r30, r24
    308c:	80 81       	ld	r24, Z
    308e:	91 81       	ldd	r25, Z+1	; 0x01
    3090:	00 97       	sbiw	r24, 0x00	; 0
    3092:	29 f0       	breq	.+10     	; 0x309e <process_thread_ctimer_process+0x28>
    3094:	8b 34       	cpi	r24, 0x4B	; 75
    3096:	91 05       	cpc	r25, r1
    3098:	09 f0       	breq	.+2      	; 0x309c <process_thread_ctimer_process+0x26>
    309a:	51 c0       	rjmp	.+162    	; 0x313e <process_thread_ctimer_process+0xc8>
    309c:	1e c0       	rjmp	.+60     	; 0x30da <process_thread_ctimer_process+0x64>

  for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    309e:	8e ee       	ldi	r24, 0xEE	; 238
    30a0:	96 e0       	ldi	r25, 0x06	; 6
    30a2:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
    30a6:	c8 2e       	mov	r12, r24
    30a8:	e6 01       	movw	r28, r12
    30aa:	7e 01       	movw	r14, r28
    30ac:	f9 2e       	mov	r15, r25
    30ae:	e7 01       	movw	r28, r14
    30b0:	09 c0       	rjmp	.+18     	; 0x30c4 <process_thread_ctimer_process+0x4e>
    etimer_set(&c->etimer, c->etimer.timer.interval);
    30b2:	6c 81       	ldd	r22, Y+4	; 0x04
    30b4:	7d 81       	ldd	r23, Y+5	; 0x05
    30b6:	ce 01       	movw	r24, r28
    30b8:	02 96       	adiw	r24, 0x02	; 2
    30ba:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <etimer_set>
PROCESS_THREAD(ctimer_process, ev, data)
{
  struct ctimer *c;
  PROCESS_BEGIN();

  for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    30be:	09 90       	ld	r0, Y+
    30c0:	d8 81       	ld	r29, Y
    30c2:	c0 2d       	mov	r28, r0
    30c4:	20 97       	sbiw	r28, 0x00	; 0
    30c6:	a9 f7       	brne	.-22     	; 0x30b2 <process_thread_ctimer_process+0x3c>
    etimer_set(&c->etimer, c->etimer.timer.interval);
  }
  initialized = 1;
    30c8:	81 e0       	ldi	r24, 0x01	; 1
    30ca:	80 93 ed 06 	sts	0x06ED, r24

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    30ce:	8b e4       	ldi	r24, 0x4B	; 75
    30d0:	90 e0       	ldi	r25, 0x00	; 0
    30d2:	f8 01       	movw	r30, r16
    30d4:	91 83       	std	Z+1, r25	; 0x01
    30d6:	80 83       	st	Z, r24
    30d8:	37 c0       	rjmp	.+110    	; 0x3148 <process_thread_ctimer_process+0xd2>
    30da:	68 38       	cpi	r22, 0x88	; 136
    30dc:	a9 f5       	brne	.+106    	; 0x3148 <process_thread_ctimer_process+0xd2>
    for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    30de:	8e ee       	ldi	r24, 0xEE	; 238
    30e0:	96 e0       	ldi	r25, 0x06	; 6
    30e2:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
    30e6:	c8 2e       	mov	r12, r24
    30e8:	e6 01       	movw	r28, r12
    30ea:	6e 01       	movw	r12, r28
    30ec:	d9 2e       	mov	r13, r25
    30ee:	e6 01       	movw	r28, r12
    30f0:	23 c0       	rjmp	.+70     	; 0x3138 <process_thread_ctimer_process+0xc2>
      if(&c->etimer == data) {
    30f2:	ce 01       	movw	r24, r28
    30f4:	02 96       	adiw	r24, 0x02	; 2
    30f6:	e8 16       	cp	r14, r24
    30f8:	f9 06       	cpc	r15, r25
    30fa:	d9 f4       	brne	.+54     	; 0x3132 <process_thread_ctimer_process+0xbc>
	list_remove(ctimer_list, c);
    30fc:	8e ee       	ldi	r24, 0xEE	; 238
    30fe:	96 e0       	ldi	r25, 0x06	; 6
    3100:	be 01       	movw	r22, r28
    3102:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>
	PROCESS_CONTEXT_BEGIN(c->p);
    3106:	e0 90 ad 06 	lds	r14, 0x06AD
    310a:	f0 90 ae 06 	lds	r15, 0x06AE
    310e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3110:	9b 85       	ldd	r25, Y+11	; 0x0b
    3112:	90 93 ae 06 	sts	0x06AE, r25
    3116:	80 93 ad 06 	sts	0x06AD, r24
	if(c->f != NULL) {
    311a:	ec 85       	ldd	r30, Y+12	; 0x0c
    311c:	fd 85       	ldd	r31, Y+13	; 0x0d
    311e:	30 97       	sbiw	r30, 0x00	; 0
    3120:	19 f0       	breq	.+6      	; 0x3128 <process_thread_ctimer_process+0xb2>
	  c->f(c->ptr);
    3122:	8e 85       	ldd	r24, Y+14	; 0x0e
    3124:	9f 85       	ldd	r25, Y+15	; 0x0f
    3126:	09 95       	icall
	}
	PROCESS_CONTEXT_END(c->p);
    3128:	f0 92 ae 06 	sts	0x06AE, r15
    312c:	e0 92 ad 06 	sts	0x06AD, r14
	break;
    3130:	ce cf       	rjmp	.-100    	; 0x30ce <process_thread_ctimer_process+0x58>
  }
  initialized = 1;

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    3132:	09 90       	ld	r0, Y+
    3134:	d8 81       	ld	r29, Y
    3136:	c0 2d       	mov	r28, r0
    3138:	20 97       	sbiw	r28, 0x00	; 0
    313a:	d9 f6       	brne	.-74     	; 0x30f2 <process_thread_ctimer_process+0x7c>
    313c:	c8 cf       	rjmp	.-112    	; 0x30ce <process_thread_ctimer_process+0x58>
	PROCESS_CONTEXT_END(c->p);
	break;
      }
    }
  }
  PROCESS_END();
    313e:	f8 01       	movw	r30, r16
    3140:	11 82       	std	Z+1, r1	; 0x01
    3142:	10 82       	st	Z, r1
    3144:	83 e0       	ldi	r24, 0x03	; 3
    3146:	01 c0       	rjmp	.+2      	; 0x314a <process_thread_ctimer_process+0xd4>
    etimer_set(&c->etimer, c->etimer.timer.interval);
  }
  initialized = 1;

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    3148:	81 e0       	ldi	r24, 0x01	; 1
	break;
      }
    }
  }
  PROCESS_END();
}
    314a:	df 91       	pop	r29
    314c:	cf 91       	pop	r28
    314e:	1f 91       	pop	r17
    3150:	0f 91       	pop	r16
    3152:	ff 90       	pop	r15
    3154:	ef 90       	pop	r14
    3156:	df 90       	pop	r13
    3158:	cf 90       	pop	r12
    315a:	08 95       	ret

0000315c <ctimer_init>:
/*---------------------------------------------------------------------------*/
void
ctimer_init(void)
{
  initialized = 0;
    315c:	10 92 ed 06 	sts	0x06ED, r1
  list_init(ctimer_list);
    3160:	8e ee       	ldi	r24, 0xEE	; 238
    3162:	96 e0       	ldi	r25, 0x06	; 6
    3164:	0e 94 67 17 	call	0x2ece	; 0x2ece <list_init>
  process_start(&ctimer_process, NULL);
    3168:	88 e9       	ldi	r24, 0x98	; 152
    316a:	95 e0       	ldi	r25, 0x05	; 5
    316c:	60 e0       	ldi	r22, 0x00	; 0
    316e:	70 e0       	ldi	r23, 0x00	; 0
    3170:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <process_start>
}
    3174:	08 95       	ret

00003176 <ctimer_set>:
/*---------------------------------------------------------------------------*/
void
ctimer_set(struct ctimer *c, clock_time_t t,
	   void (*f)(void *), void *ptr)
{
    3176:	0f 93       	push	r16
    3178:	1f 93       	push	r17
    317a:	cf 93       	push	r28
    317c:	df 93       	push	r29
    317e:	ec 01       	movw	r28, r24
  PRINTF("ctimer_set %p %u\n", c, (unsigned)t);
  c->p = PROCESS_CURRENT();
    3180:	00 91 ad 06 	lds	r16, 0x06AD
    3184:	10 91 ae 06 	lds	r17, 0x06AE
    3188:	1b 87       	std	Y+11, r17	; 0x0b
    318a:	0a 87       	std	Y+10, r16	; 0x0a
  c->f = f;
    318c:	5d 87       	std	Y+13, r21	; 0x0d
    318e:	4c 87       	std	Y+12, r20	; 0x0c
  c->ptr = ptr;
    3190:	3f 87       	std	Y+15, r19	; 0x0f
    3192:	2e 87       	std	Y+14, r18	; 0x0e
  if(initialized) {
    3194:	80 91 ed 06 	lds	r24, 0x06ED
    3198:	88 23       	and	r24, r24
    319a:	79 f0       	breq	.+30     	; 0x31ba <ctimer_set+0x44>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    319c:	88 e9       	ldi	r24, 0x98	; 152
    319e:	95 e0       	ldi	r25, 0x05	; 5
    31a0:	90 93 ae 06 	sts	0x06AE, r25
    31a4:	80 93 ad 06 	sts	0x06AD, r24
    etimer_set(&c->etimer, t);
    31a8:	ce 01       	movw	r24, r28
    31aa:	02 96       	adiw	r24, 0x02	; 2
    31ac:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <etimer_set>
    PROCESS_CONTEXT_END(&ctimer_process);
    31b0:	10 93 ae 06 	sts	0x06AE, r17
    31b4:	00 93 ad 06 	sts	0x06AD, r16
    31b8:	02 c0       	rjmp	.+4      	; 0x31be <ctimer_set+0x48>
  } else {
    c->etimer.timer.interval = t;
    31ba:	7d 83       	std	Y+5, r23	; 0x05
    31bc:	6c 83       	std	Y+4, r22	; 0x04
  }

  list_remove(ctimer_list, c);
    31be:	8e ee       	ldi	r24, 0xEE	; 238
    31c0:	96 e0       	ldi	r25, 0x06	; 6
    31c2:	be 01       	movw	r22, r28
    31c4:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>
  list_add(ctimer_list, c);
    31c8:	8e ee       	ldi	r24, 0xEE	; 238
    31ca:	96 e0       	ldi	r25, 0x06	; 6
    31cc:	be 01       	movw	r22, r28
    31ce:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <list_add>
}
    31d2:	df 91       	pop	r29
    31d4:	cf 91       	pop	r28
    31d6:	1f 91       	pop	r17
    31d8:	0f 91       	pop	r16
    31da:	08 95       	ret

000031dc <ctimer_reset>:
/*---------------------------------------------------------------------------*/
void
ctimer_reset(struct ctimer *c)
{
    31dc:	0f 93       	push	r16
    31de:	1f 93       	push	r17
    31e0:	cf 93       	push	r28
    31e2:	df 93       	push	r29
    31e4:	ec 01       	movw	r28, r24
  if(initialized) {
    31e6:	80 91 ed 06 	lds	r24, 0x06ED
    31ea:	88 23       	and	r24, r24
    31ec:	91 f0       	breq	.+36     	; 0x3212 <ctimer_reset+0x36>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    31ee:	00 91 ad 06 	lds	r16, 0x06AD
    31f2:	10 91 ae 06 	lds	r17, 0x06AE
    31f6:	88 e9       	ldi	r24, 0x98	; 152
    31f8:	95 e0       	ldi	r25, 0x05	; 5
    31fa:	90 93 ae 06 	sts	0x06AE, r25
    31fe:	80 93 ad 06 	sts	0x06AD, r24
    etimer_reset(&c->etimer);
    3202:	ce 01       	movw	r24, r28
    3204:	02 96       	adiw	r24, 0x02	; 2
    3206:	0e 94 ee 02 	call	0x5dc	; 0x5dc <etimer_reset>
    PROCESS_CONTEXT_END(&ctimer_process);
    320a:	10 93 ae 06 	sts	0x06AE, r17
    320e:	00 93 ad 06 	sts	0x06AD, r16
  }

  list_remove(ctimer_list, c);
    3212:	8e ee       	ldi	r24, 0xEE	; 238
    3214:	96 e0       	ldi	r25, 0x06	; 6
    3216:	be 01       	movw	r22, r28
    3218:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>
  list_add(ctimer_list, c);
    321c:	8e ee       	ldi	r24, 0xEE	; 238
    321e:	96 e0       	ldi	r25, 0x06	; 6
    3220:	be 01       	movw	r22, r28
    3222:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <list_add>
}
    3226:	df 91       	pop	r29
    3228:	cf 91       	pop	r28
    322a:	1f 91       	pop	r17
    322c:	0f 91       	pop	r16
    322e:	08 95       	ret

00003230 <ctimer_restart>:
/*---------------------------------------------------------------------------*/
void
ctimer_restart(struct ctimer *c)
{
    3230:	0f 93       	push	r16
    3232:	1f 93       	push	r17
    3234:	cf 93       	push	r28
    3236:	df 93       	push	r29
    3238:	ec 01       	movw	r28, r24
  if(initialized) {
    323a:	80 91 ed 06 	lds	r24, 0x06ED
    323e:	88 23       	and	r24, r24
    3240:	91 f0       	breq	.+36     	; 0x3266 <ctimer_restart+0x36>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    3242:	00 91 ad 06 	lds	r16, 0x06AD
    3246:	10 91 ae 06 	lds	r17, 0x06AE
    324a:	88 e9       	ldi	r24, 0x98	; 152
    324c:	95 e0       	ldi	r25, 0x05	; 5
    324e:	90 93 ae 06 	sts	0x06AE, r25
    3252:	80 93 ad 06 	sts	0x06AD, r24
    etimer_restart(&c->etimer);
    3256:	ce 01       	movw	r24, r28
    3258:	02 96       	adiw	r24, 0x02	; 2
    325a:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <etimer_restart>
    PROCESS_CONTEXT_END(&ctimer_process);
    325e:	10 93 ae 06 	sts	0x06AE, r17
    3262:	00 93 ad 06 	sts	0x06AD, r16
  }

  list_remove(ctimer_list, c);
    3266:	8e ee       	ldi	r24, 0xEE	; 238
    3268:	96 e0       	ldi	r25, 0x06	; 6
    326a:	be 01       	movw	r22, r28
    326c:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>
  list_add(ctimer_list, c);
    3270:	8e ee       	ldi	r24, 0xEE	; 238
    3272:	96 e0       	ldi	r25, 0x06	; 6
    3274:	be 01       	movw	r22, r28
    3276:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <list_add>
}
    327a:	df 91       	pop	r29
    327c:	cf 91       	pop	r28
    327e:	1f 91       	pop	r17
    3280:	0f 91       	pop	r16
    3282:	08 95       	ret

00003284 <ctimer_stop>:
/*---------------------------------------------------------------------------*/
void
ctimer_stop(struct ctimer *c)
{
    3284:	cf 93       	push	r28
    3286:	df 93       	push	r29
    3288:	ec 01       	movw	r28, r24
  if(initialized) {
    328a:	80 91 ed 06 	lds	r24, 0x06ED
    328e:	88 23       	and	r24, r24
    3290:	29 f0       	breq	.+10     	; 0x329c <ctimer_stop+0x18>
    etimer_stop(&c->etimer);
    3292:	ce 01       	movw	r24, r28
    3294:	02 96       	adiw	r24, 0x02	; 2
    3296:	0e 94 41 03 	call	0x682	; 0x682 <etimer_stop>
    329a:	04 c0       	rjmp	.+8      	; 0x32a4 <ctimer_stop+0x20>
  } else {
    c->etimer.next = NULL;
    329c:	1f 82       	std	Y+7, r1	; 0x07
    329e:	1e 82       	std	Y+6, r1	; 0x06
    c->etimer.p = PROCESS_NONE;
    32a0:	19 86       	std	Y+9, r1	; 0x09
    32a2:	18 86       	std	Y+8, r1	; 0x08
  }
  list_remove(ctimer_list, c);
    32a4:	8e ee       	ldi	r24, 0xEE	; 238
    32a6:	96 e0       	ldi	r25, 0x06	; 6
    32a8:	be 01       	movw	r22, r28
    32aa:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <list_remove>
}
    32ae:	df 91       	pop	r29
    32b0:	cf 91       	pop	r28
    32b2:	08 95       	ret

000032b4 <ctimer_expired>:
/*---------------------------------------------------------------------------*/
int
ctimer_expired(struct ctimer *c)
{
    32b4:	cf 93       	push	r28
    32b6:	df 93       	push	r29
    32b8:	ec 01       	movw	r28, r24
  struct ctimer *t;
  if(initialized) {
    32ba:	80 91 ed 06 	lds	r24, 0x06ED
    32be:	88 23       	and	r24, r24
    32c0:	31 f0       	breq	.+12     	; 0x32ce <ctimer_expired+0x1a>
    return etimer_expired(&c->etimer);
    32c2:	ce 01       	movw	r24, r28
    32c4:	02 96       	adiw	r24, 0x02	; 2
    32c6:	0e 94 0e 03 	call	0x61c	; 0x61c <etimer_expired>
    32ca:	9c 01       	movw	r18, r24
    32cc:	14 c0       	rjmp	.+40     	; 0x32f6 <ctimer_expired+0x42>
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    32ce:	8e ee       	ldi	r24, 0xEE	; 238
    32d0:	96 e0       	ldi	r25, 0x06	; 6
    32d2:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <list_head>
    32d6:	e8 2f       	mov	r30, r24
    32d8:	f9 2f       	mov	r31, r25
    32da:	06 c0       	rjmp	.+12     	; 0x32e8 <ctimer_expired+0x34>
    if(t == c) {
    32dc:	ec 17       	cp	r30, r28
    32de:	fd 07       	cpc	r31, r29
    32e0:	41 f0       	breq	.+16     	; 0x32f2 <ctimer_expired+0x3e>
{
  struct ctimer *t;
  if(initialized) {
    return etimer_expired(&c->etimer);
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    32e2:	01 90       	ld	r0, Z+
    32e4:	f0 81       	ld	r31, Z
    32e6:	e0 2d       	mov	r30, r0
    32e8:	30 97       	sbiw	r30, 0x00	; 0
    32ea:	c1 f7       	brne	.-16     	; 0x32dc <ctimer_expired+0x28>
    if(t == c) {
      return 0;
    }
  }
  return 1;
    32ec:	21 e0       	ldi	r18, 0x01	; 1
    32ee:	30 e0       	ldi	r19, 0x00	; 0
    32f0:	02 c0       	rjmp	.+4      	; 0x32f6 <ctimer_expired+0x42>
  if(initialized) {
    return etimer_expired(&c->etimer);
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    if(t == c) {
      return 0;
    32f2:	20 e0       	ldi	r18, 0x00	; 0
    32f4:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  return 1;
}
    32f6:	c9 01       	movw	r24, r18
    32f8:	df 91       	pop	r29
    32fa:	cf 91       	pop	r28
    32fc:	08 95       	ret

000032fe <energest_type_set>:
    }
  }
}
/*---------------------------------------------------------------------------*/
#else /* ENERGEST_CONF_ON */
void energest_type_set(int type, unsigned long val) {}
    32fe:	08 95       	ret

00003300 <energest_init>:
void energest_init(void) {}
    3300:	08 95       	ret

00003302 <energest_type_time>:
unsigned long energest_type_time(int type) { return 0; }
    3302:	60 e0       	ldi	r22, 0x00	; 0
    3304:	70 e0       	ldi	r23, 0x00	; 0
    3306:	cb 01       	movw	r24, r22
    3308:	08 95       	ret

0000330a <energest_flush>:
void energest_flush(void) {}
    330a:	08 95       	ret

0000330c <random_init>:

/*---------------------------------------------------------------------------*/
void
random_init(unsigned short seed)
{
  srand(seed);
    330c:	0e 94 da 25 	call	0x4bb4	; 0x4bb4 <srand>
}
    3310:	08 95       	ret

00003312 <random_rand>:
random_rand(void)
{
/* In gcc int rand() uses RAND_MAX and long random() uses RANDOM_MAX=0x7FFFFFFF */
/* RAND_MAX varies depending on the architecture */

  return (unsigned short)rand();
    3312:	0e 94 d5 25 	call	0x4baa	; 0x4baa <rand>
}
    3316:	08 95       	ret

00003318 <packetbuf_clear_hdr>:
}
/*---------------------------------------------------------------------------*/
void
packetbuf_clear_hdr(void)
{
  hdrptr = PACKETBUF_HDR_SIZE;
    3318:	80 e3       	ldi	r24, 0x30	; 48
    331a:	80 93 f0 06 	sts	0x06F0, r24
}
    331e:	08 95       	ret

00003320 <packetbuf_copyto_hdr>:
  }
}
/*---------------------------------------------------------------------------*/
int
packetbuf_copyto_hdr(uint8_t *to)
{
    3320:	ef 92       	push	r14
    3322:	ff 92       	push	r15
    3324:	cf 93       	push	r28
    3326:	df 93       	push	r29
      PRINTF("0x%02x, ", packetbuf[i]);
    }
    PRINTF("\n");
  }
#endif /* DEBUG_LEVEL */
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
    3328:	20 91 f0 06 	lds	r18, 0x06F0
    332c:	30 e0       	ldi	r19, 0x00	; 0
    332e:	c0 e3       	ldi	r28, 0x30	; 48
    3330:	d0 e0       	ldi	r29, 0x00	; 0
    3332:	c2 1b       	sub	r28, r18
    3334:	d3 0b       	sbc	r29, r19
    3336:	2b 50       	subi	r18, 0x0B	; 11
    3338:	39 4f       	sbci	r19, 0xF9	; 249
    333a:	b9 01       	movw	r22, r18
    333c:	ae 01       	movw	r20, r28
    333e:	0e 94 e5 25 	call	0x4bca	; 0x4bca <memcpy>
  return PACKETBUF_HDR_SIZE - hdrptr;
}
    3342:	ce 01       	movw	r24, r28
    3344:	df 91       	pop	r29
    3346:	cf 91       	pop	r28
    3348:	ff 90       	pop	r15
    334a:	ef 90       	pop	r14
    334c:	08 95       	ret

0000334e <packetbuf_copyto>:
/*---------------------------------------------------------------------------*/
int
packetbuf_copyto(void *to)
{
    334e:	af 92       	push	r10
    3350:	bf 92       	push	r11
    3352:	cf 92       	push	r12
    3354:	df 92       	push	r13
    3356:	ef 92       	push	r14
    3358:	ff 92       	push	r15
    335a:	0f 93       	push	r16
    335c:	1f 93       	push	r17
    335e:	cf 93       	push	r28
    3360:	df 93       	push	r29
    3362:	7c 01       	movw	r14, r24
      bufferptr += sprintf(bufferptr, "0x%02x, ", packetbufptr[i]);
    }
    PRINTF("packetbuf_write: data: %s\n", buffer);
  }
#endif /* DEBUG_LEVEL */
  if(PACKETBUF_HDR_SIZE - hdrptr + buflen > PACKETBUF_SIZE) {
    3364:	c0 90 f1 06 	lds	r12, 0x06F1
    3368:	d0 90 f2 06 	lds	r13, 0x06F2
    336c:	20 91 f0 06 	lds	r18, 0x06F0
    3370:	30 e0       	ldi	r19, 0x00	; 0
    3372:	86 01       	movw	r16, r12
    3374:	00 5d       	subi	r16, 0xD0	; 208
    3376:	1f 4f       	sbci	r17, 0xFF	; 255
    3378:	02 1b       	sub	r16, r18
    337a:	13 0b       	sbc	r17, r19
    337c:	01 38       	cpi	r16, 0x81	; 129
    337e:	11 05       	cpc	r17, r1
    3380:	e0 f4       	brcc	.+56     	; 0x33ba <packetbuf_copyto+0x6c>
    /* Too large packet */
    return 0;
  }
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
    3382:	c0 e3       	ldi	r28, 0x30	; 48
    3384:	d0 e0       	ldi	r29, 0x00	; 0
    3386:	c2 1b       	sub	r28, r18
    3388:	d3 0b       	sbc	r29, r19
    338a:	2b 50       	subi	r18, 0x0B	; 11
    338c:	39 4f       	sbci	r19, 0xF9	; 249
    338e:	b9 01       	movw	r22, r18
    3390:	ae 01       	movw	r20, r28
    3392:	0e 94 e5 25 	call	0x4bca	; 0x4bca <memcpy>
  memcpy((uint8_t *)to + PACKETBUF_HDR_SIZE - hdrptr, packetbufptr + bufptr,
    3396:	ce 0d       	add	r28, r14
    3398:	df 1d       	adc	r29, r15
    339a:	20 91 f3 06 	lds	r18, 0x06F3
    339e:	30 91 f4 06 	lds	r19, 0x06F4
    33a2:	80 91 a7 07 	lds	r24, 0x07A7
    33a6:	90 91 a8 07 	lds	r25, 0x07A8
    33aa:	28 0f       	add	r18, r24
    33ac:	39 1f       	adc	r19, r25
    33ae:	ce 01       	movw	r24, r28
    33b0:	b9 01       	movw	r22, r18
    33b2:	a6 01       	movw	r20, r12
    33b4:	0e 94 e5 25 	call	0x4bca	; 0x4bca <memcpy>
	 buflen);
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
    33b8:	02 c0       	rjmp	.+4      	; 0x33be <packetbuf_copyto+0x70>
    PRINTF("packetbuf_write: data: %s\n", buffer);
  }
#endif /* DEBUG_LEVEL */
  if(PACKETBUF_HDR_SIZE - hdrptr + buflen > PACKETBUF_SIZE) {
    /* Too large packet */
    return 0;
    33ba:	00 e0       	ldi	r16, 0x00	; 0
    33bc:	10 e0       	ldi	r17, 0x00	; 0
  }
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
  memcpy((uint8_t *)to + PACKETBUF_HDR_SIZE - hdrptr, packetbufptr + bufptr,
	 buflen);
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
}
    33be:	c8 01       	movw	r24, r16
    33c0:	df 91       	pop	r29
    33c2:	cf 91       	pop	r28
    33c4:	1f 91       	pop	r17
    33c6:	0f 91       	pop	r16
    33c8:	ff 90       	pop	r15
    33ca:	ef 90       	pop	r14
    33cc:	df 90       	pop	r13
    33ce:	cf 90       	pop	r12
    33d0:	bf 90       	pop	r11
    33d2:	af 90       	pop	r10
    33d4:	08 95       	ret

000033d6 <packetbuf_hdr_remove>:
}
/*---------------------------------------------------------------------------*/
void
packetbuf_hdr_remove(int size)
{
  hdrptr += size;
    33d6:	90 91 f0 06 	lds	r25, 0x06F0
    33da:	98 0f       	add	r25, r24
    33dc:	90 93 f0 06 	sts	0x06F0, r25
}
    33e0:	08 95       	ret

000033e2 <packetbuf_hdrreduce>:
/*---------------------------------------------------------------------------*/
int
packetbuf_hdrreduce(int size)
{
  if(buflen < size) {
    33e2:	40 91 f1 06 	lds	r20, 0x06F1
    33e6:	50 91 f2 06 	lds	r21, 0x06F2
    33ea:	9c 01       	movw	r18, r24
    33ec:	48 17       	cp	r20, r24
    33ee:	59 07       	cpc	r21, r25
    33f0:	98 f0       	brcs	.+38     	; 0x3418 <packetbuf_hdrreduce+0x36>
    return 0;
  }

  bufptr += size;
    33f2:	80 91 a7 07 	lds	r24, 0x07A7
    33f6:	90 91 a8 07 	lds	r25, 0x07A8
    33fa:	82 0f       	add	r24, r18
    33fc:	93 1f       	adc	r25, r19
    33fe:	90 93 a8 07 	sts	0x07A8, r25
    3402:	80 93 a7 07 	sts	0x07A7, r24
  buflen -= size;
    3406:	42 1b       	sub	r20, r18
    3408:	53 0b       	sbc	r21, r19
    340a:	50 93 f2 06 	sts	0x06F2, r21
    340e:	40 93 f1 06 	sts	0x06F1, r20
  return 1;
    3412:	21 e0       	ldi	r18, 0x01	; 1
    3414:	30 e0       	ldi	r19, 0x00	; 0
    3416:	02 c0       	rjmp	.+4      	; 0x341c <packetbuf_hdrreduce+0x3a>
/*---------------------------------------------------------------------------*/
int
packetbuf_hdrreduce(int size)
{
  if(buflen < size) {
    return 0;
    3418:	20 e0       	ldi	r18, 0x00	; 0
    341a:	30 e0       	ldi	r19, 0x00	; 0
  }

  bufptr += size;
  buflen -= size;
  return 1;
}
    341c:	c9 01       	movw	r24, r18
    341e:	08 95       	ret

00003420 <packetbuf_set_datalen>:
/*---------------------------------------------------------------------------*/
void
packetbuf_set_datalen(uint16_t len)
{
  PRINTF("packetbuf_set_len: len %d\n", len);
  buflen = len;
    3420:	90 93 f2 06 	sts	0x06F2, r25
    3424:	80 93 f1 06 	sts	0x06F1, r24
}
    3428:	08 95       	ret

0000342a <packetbuf_dataptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_dataptr(void)
{
  return (void *)(&packetbuf[bufptr + PACKETBUF_HDR_SIZE]);
    342a:	20 91 a7 07 	lds	r18, 0x07A7
    342e:	30 91 a8 07 	lds	r19, 0x07A8
    3432:	2b 5d       	subi	r18, 0xDB	; 219
    3434:	38 4f       	sbci	r19, 0xF8	; 248
}
    3436:	c9 01       	movw	r24, r18
    3438:	08 95       	ret

0000343a <packetbuf_hdrptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_hdrptr(void)
{
  return (void *)(&packetbuf[hdrptr]);
    343a:	20 91 f0 06 	lds	r18, 0x06F0
    343e:	30 e0       	ldi	r19, 0x00	; 0
    3440:	2b 50       	subi	r18, 0x0B	; 11
    3442:	39 4f       	sbci	r19, 0xF9	; 249
}
    3444:	c9 01       	movw	r24, r18
    3446:	08 95       	ret

00003448 <packetbuf_is_reference>:
}
/*---------------------------------------------------------------------------*/
int
packetbuf_is_reference(void)
{
  return packetbufptr != &packetbuf[PACKETBUF_HDR_SIZE];
    3448:	21 e0       	ldi	r18, 0x01	; 1
    344a:	30 e0       	ldi	r19, 0x00	; 0
    344c:	80 91 f3 06 	lds	r24, 0x06F3
    3450:	90 91 f4 06 	lds	r25, 0x06F4
    3454:	47 e0       	ldi	r20, 0x07	; 7
    3456:	85 32       	cpi	r24, 0x25	; 37
    3458:	94 07       	cpc	r25, r20
    345a:	11 f4       	brne	.+4      	; 0x3460 <packetbuf_is_reference+0x18>
    345c:	20 e0       	ldi	r18, 0x00	; 0
    345e:	30 e0       	ldi	r19, 0x00	; 0
}
    3460:	c9 01       	movw	r24, r18
    3462:	08 95       	ret

00003464 <packetbuf_compact>:
void
packetbuf_compact(void)
{
  int i, len;

  if(packetbuf_is_reference()) {
    3464:	0e 94 24 1a 	call	0x3448	; 0x3448 <packetbuf_is_reference>
    3468:	00 97       	sbiw	r24, 0x00	; 0
    346a:	71 f0       	breq	.+28     	; 0x3488 <packetbuf_compact+0x24>
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
    346c:	25 e2       	ldi	r18, 0x25	; 37
    346e:	37 e0       	ldi	r19, 0x07	; 7
    3470:	60 91 f3 06 	lds	r22, 0x06F3
    3474:	70 91 f4 06 	lds	r23, 0x06F4
    3478:	40 91 f1 06 	lds	r20, 0x06F1
    347c:	50 91 f2 06 	lds	r21, 0x06F2
    3480:	c9 01       	movw	r24, r18
    3482:	0e 94 e5 25 	call	0x4bca	; 0x4bca <memcpy>
    3486:	08 95       	ret
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    3488:	a0 91 a7 07 	lds	r26, 0x07A7
    348c:	b0 91 a8 07 	lds	r27, 0x07A8
    3490:	10 97       	sbiw	r26, 0x00	; 0
    3492:	b9 f0       	breq	.+46     	; 0x34c2 <packetbuf_compact+0x5e>
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    3494:	20 91 f1 06 	lds	r18, 0x06F1
    3498:	30 91 f2 06 	lds	r19, 0x06F2
    349c:	20 5d       	subi	r18, 0xD0	; 208
    349e:	3f 4f       	sbci	r19, 0xFF	; 255
  buflen = l;
  return l;
}
/*---------------------------------------------------------------------------*/
void
packetbuf_compact(void)
    34a0:	ab 5d       	subi	r26, 0xDB	; 219
    34a2:	b8 4f       	sbci	r27, 0xF8	; 248
    34a4:	e5 e2       	ldi	r30, 0x25	; 37
    34a6:	f7 e0       	ldi	r31, 0x07	; 7
  if(packetbuf_is_reference()) {
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    for(i = PACKETBUF_HDR_SIZE; i < len; i++) {
    34a8:	80 e3       	ldi	r24, 0x30	; 48
    34aa:	90 e0       	ldi	r25, 0x00	; 0
    34ac:	03 c0       	rjmp	.+6      	; 0x34b4 <packetbuf_compact+0x50>
      packetbuf[i] = packetbuf[bufptr + i];
    34ae:	4d 91       	ld	r20, X+
    34b0:	41 93       	st	Z+, r20
  if(packetbuf_is_reference()) {
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    for(i = PACKETBUF_HDR_SIZE; i < len; i++) {
    34b2:	01 96       	adiw	r24, 0x01	; 1
    34b4:	82 17       	cp	r24, r18
    34b6:	93 07       	cpc	r25, r19
    34b8:	d4 f3       	brlt	.-12     	; 0x34ae <packetbuf_compact+0x4a>
      packetbuf[i] = packetbuf[bufptr + i];
    }

    bufptr = 0;
    34ba:	10 92 a8 07 	sts	0x07A8, r1
    34be:	10 92 a7 07 	sts	0x07A7, r1
    34c2:	08 95       	ret

000034c4 <packetbuf_reference_ptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_reference_ptr(void)
{
  return packetbufptr;
}
    34c4:	80 91 f3 06 	lds	r24, 0x06F3
    34c8:	90 91 f4 06 	lds	r25, 0x06F4
    34cc:	08 95       	ret

000034ce <packetbuf_datalen>:
/*---------------------------------------------------------------------------*/
uint16_t
packetbuf_datalen(void)
{
  return buflen;
}
    34ce:	80 91 f1 06 	lds	r24, 0x06F1
    34d2:	90 91 f2 06 	lds	r25, 0x06F2
    34d6:	08 95       	ret

000034d8 <packetbuf_hdrlen>:
/*---------------------------------------------------------------------------*/
uint8_t
packetbuf_hdrlen(void)
{
  return PACKETBUF_HDR_SIZE - hdrptr;
    34d8:	90 91 f0 06 	lds	r25, 0x06F0
}
    34dc:	80 e3       	ldi	r24, 0x30	; 48
    34de:	89 1b       	sub	r24, r25
    34e0:	08 95       	ret

000034e2 <packetbuf_totlen>:
}
/*---------------------------------------------------------------------------*/
uint8_t
packetbuf_hdrlen(void)
{
  return PACKETBUF_HDR_SIZE - hdrptr;
    34e2:	80 e3       	ldi	r24, 0x30	; 48
    34e4:	90 91 f0 06 	lds	r25, 0x06F0
    34e8:	89 1b       	sub	r24, r25
}
/*---------------------------------------------------------------------------*/
uint16_t
packetbuf_totlen(void)
{
  return packetbuf_hdrlen() + packetbuf_datalen();
    34ea:	20 91 f1 06 	lds	r18, 0x06F1
    34ee:	30 91 f2 06 	lds	r19, 0x06F2
    34f2:	28 0f       	add	r18, r24
    34f4:	31 1d       	adc	r19, r1
}
    34f6:	c9 01       	movw	r24, r18
    34f8:	08 95       	ret

000034fa <packetbuf_hdralloc>:
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
}
/*---------------------------------------------------------------------------*/
int
packetbuf_hdralloc(int size)
{
    34fa:	1f 93       	push	r17
    34fc:	cf 93       	push	r28
    34fe:	df 93       	push	r29
    3500:	ec 01       	movw	r28, r24
  if(hdrptr >= size && packetbuf_totlen() + size <= PACKETBUF_SIZE) {
    3502:	10 91 f0 06 	lds	r17, 0x06F0
    3506:	81 2f       	mov	r24, r17
    3508:	90 e0       	ldi	r25, 0x00	; 0
    350a:	8c 17       	cp	r24, r28
    350c:	9d 07       	cpc	r25, r29
    350e:	6c f0       	brlt	.+26     	; 0x352a <packetbuf_hdralloc+0x30>
    3510:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <packetbuf_totlen>
    3514:	8c 0f       	add	r24, r28
    3516:	9d 1f       	adc	r25, r29
    3518:	81 38       	cpi	r24, 0x81	; 129
    351a:	91 05       	cpc	r25, r1
    351c:	30 f4       	brcc	.+12     	; 0x352a <packetbuf_hdralloc+0x30>
    hdrptr -= size;
    351e:	1c 1b       	sub	r17, r28
    3520:	10 93 f0 06 	sts	0x06F0, r17
    return 1;
    3524:	21 e0       	ldi	r18, 0x01	; 1
    3526:	30 e0       	ldi	r19, 0x00	; 0
    3528:	02 c0       	rjmp	.+4      	; 0x352e <packetbuf_hdralloc+0x34>
  }
  return 0;
    352a:	20 e0       	ldi	r18, 0x00	; 0
    352c:	30 e0       	ldi	r19, 0x00	; 0
}
    352e:	c9 01       	movw	r24, r18
    3530:	df 91       	pop	r29
    3532:	cf 91       	pop	r28
    3534:	1f 91       	pop	r17
    3536:	08 95       	ret

00003538 <packetbuf_attr_clear>:
  return packetbuf_hdrlen() + packetbuf_datalen();
}
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_clear(void)
{
    3538:	cf 93       	push	r28
    353a:	df 93       	push	r29
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    353c:	e3 e7       	ldi	r30, 0x73	; 115
    353e:	fe e0       	ldi	r31, 0x0E	; 14
    packetbuf_attrs[i].val = 0;
    3540:	11 92       	st	Z+, r1
    3542:	11 92       	st	Z+, r1
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_clear(void)
{
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    3544:	8e e0       	ldi	r24, 0x0E	; 14
    3546:	e3 3a       	cpi	r30, 0xA3	; 163
    3548:	f8 07       	cpc	r31, r24
    354a:	d1 f7       	brne	.-12     	; 0x3540 <packetbuf_attr_clear+0x8>
    354c:	c0 e0       	ldi	r28, 0x00	; 0
    354e:	d0 e0       	ldi	r29, 0x00	; 0
    packetbuf_attrs[i].val = 0;
  }
  for(i = 0; i < PACKETBUF_NUM_ADDRS; ++i) {
    rimeaddr_copy(&packetbuf_addrs[i].addr, &rimeaddr_null);
    3550:	ce 01       	movw	r24, r28
    3552:	88 0f       	add	r24, r24
    3554:	99 1f       	adc	r25, r25
    3556:	85 59       	subi	r24, 0x95	; 149
    3558:	91 4f       	sbci	r25, 0xF1	; 241
    355a:	67 e8       	ldi	r22, 0x87	; 135
    355c:	73 e0       	ldi	r23, 0x03	; 3
    355e:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
{
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    packetbuf_attrs[i].val = 0;
  }
  for(i = 0; i < PACKETBUF_NUM_ADDRS; ++i) {
    3562:	21 96       	adiw	r28, 0x01	; 1
    3564:	c4 30       	cpi	r28, 0x04	; 4
    3566:	d1 05       	cpc	r29, r1
    3568:	99 f7       	brne	.-26     	; 0x3550 <packetbuf_attr_clear+0x18>
    rimeaddr_copy(&packetbuf_addrs[i].addr, &rimeaddr_null);
  }
}
    356a:	df 91       	pop	r29
    356c:	cf 91       	pop	r28
    356e:	08 95       	ret

00003570 <packetbuf_clear>:

/*---------------------------------------------------------------------------*/
void
packetbuf_clear(void)
{
  buflen = bufptr = 0;
    3570:	10 92 a8 07 	sts	0x07A8, r1
    3574:	10 92 a7 07 	sts	0x07A7, r1
    3578:	10 92 f2 06 	sts	0x06F2, r1
    357c:	10 92 f1 06 	sts	0x06F1, r1
  hdrptr = PACKETBUF_HDR_SIZE;
    3580:	80 e3       	ldi	r24, 0x30	; 48
    3582:	80 93 f0 06 	sts	0x06F0, r24

  packetbufptr = &packetbuf[PACKETBUF_HDR_SIZE];
    3586:	85 e2       	ldi	r24, 0x25	; 37
    3588:	97 e0       	ldi	r25, 0x07	; 7
    358a:	90 93 f4 06 	sts	0x06F4, r25
    358e:	80 93 f3 06 	sts	0x06F3, r24
  packetbuf_attr_clear();
    3592:	0e 94 9c 1a 	call	0x3538	; 0x3538 <packetbuf_attr_clear>
}
    3596:	08 95       	ret

00003598 <packetbuf_reference>:
  return (void *)(&packetbuf[hdrptr]);
}
/*---------------------------------------------------------------------------*/
void
packetbuf_reference(void *ptr, uint16_t len)
{
    3598:	0f 93       	push	r16
    359a:	1f 93       	push	r17
    359c:	cf 93       	push	r28
    359e:	df 93       	push	r29
    35a0:	ec 01       	movw	r28, r24
    35a2:	8b 01       	movw	r16, r22
  packetbuf_clear();
    35a4:	0e 94 b8 1a 	call	0x3570	; 0x3570 <packetbuf_clear>
  packetbufptr = ptr;
    35a8:	d0 93 f4 06 	sts	0x06F4, r29
    35ac:	c0 93 f3 06 	sts	0x06F3, r28
  buflen = len;
    35b0:	10 93 f2 06 	sts	0x06F2, r17
    35b4:	00 93 f1 06 	sts	0x06F1, r16
}
    35b8:	df 91       	pop	r29
    35ba:	cf 91       	pop	r28
    35bc:	1f 91       	pop	r17
    35be:	0f 91       	pop	r16
    35c0:	08 95       	ret

000035c2 <packetbuf_copyfrom>:
  hdrptr = PACKETBUF_HDR_SIZE;
}
/*---------------------------------------------------------------------------*/
int
packetbuf_copyfrom(const void *from, uint16_t len)
{
    35c2:	cf 92       	push	r12
    35c4:	df 92       	push	r13
    35c6:	ef 92       	push	r14
    35c8:	ff 92       	push	r15
    35ca:	0f 93       	push	r16
    35cc:	1f 93       	push	r17
    35ce:	df 93       	push	r29
    35d0:	cf 93       	push	r28
    35d2:	00 d0       	rcall	.+0      	; 0x35d4 <packetbuf_copyfrom+0x12>
    35d4:	cd b7       	in	r28, 0x3d	; 61
    35d6:	de b7       	in	r29, 0x3e	; 62
    35d8:	8c 01       	movw	r16, r24
  uint16_t l;

  packetbuf_clear();
    35da:	69 83       	std	Y+1, r22	; 0x01
    35dc:	7a 83       	std	Y+2, r23	; 0x02
    35de:	0e 94 b8 1a 	call	0x3570	; 0x3570 <packetbuf_clear>
  l = len > PACKETBUF_SIZE? PACKETBUF_SIZE: len;
    35e2:	69 81       	ldd	r22, Y+1	; 0x01
    35e4:	7a 81       	ldd	r23, Y+2	; 0x02
    35e6:	c6 2e       	mov	r12, r22
    35e8:	d7 2e       	mov	r13, r23
    35ea:	21 e8       	ldi	r18, 0x81	; 129
    35ec:	c2 16       	cp	r12, r18
    35ee:	d1 04       	cpc	r13, r1
    35f0:	18 f0       	brcs	.+6      	; 0x35f8 <packetbuf_copyfrom+0x36>
    35f2:	30 e8       	ldi	r19, 0x80	; 128
    35f4:	c3 2e       	mov	r12, r19
    35f6:	d1 2c       	mov	r13, r1
  memcpy(packetbufptr, from, l);
    35f8:	80 91 f3 06 	lds	r24, 0x06F3
    35fc:	90 91 f4 06 	lds	r25, 0x06F4
    3600:	b8 01       	movw	r22, r16
    3602:	a6 01       	movw	r20, r12
    3604:	0e 94 e5 25 	call	0x4bca	; 0x4bca <memcpy>
  buflen = l;
    3608:	d0 92 f2 06 	sts	0x06F2, r13
    360c:	c0 92 f1 06 	sts	0x06F1, r12
  return l;
}
    3610:	c6 01       	movw	r24, r12
    3612:	0f 90       	pop	r0
    3614:	0f 90       	pop	r0
    3616:	cf 91       	pop	r28
    3618:	df 91       	pop	r29
    361a:	1f 91       	pop	r17
    361c:	0f 91       	pop	r16
    361e:	ff 90       	pop	r15
    3620:	ef 90       	pop	r14
    3622:	df 90       	pop	r13
    3624:	cf 90       	pop	r12
    3626:	08 95       	ret

00003628 <packetbuf_attr_copyto>:
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_copyto(struct packetbuf_attr *attrs,
		    struct packetbuf_addr *addrs)
{
  memcpy(attrs, packetbuf_attrs, sizeof(packetbuf_attrs));
    3628:	28 2f       	mov	r18, r24
    362a:	39 2f       	mov	r19, r25
    362c:	d9 01       	movw	r26, r18
    362e:	e3 e7       	ldi	r30, 0x73	; 115
    3630:	fe e0       	ldi	r31, 0x0E	; 14
    3632:	80 e3       	ldi	r24, 0x30	; 48
    3634:	01 90       	ld	r0, Z+
    3636:	0d 92       	st	X+, r0
    3638:	81 50       	subi	r24, 0x01	; 1
    363a:	e1 f7       	brne	.-8      	; 0x3634 <packetbuf_attr_copyto+0xc>
  memcpy(addrs, packetbuf_addrs, sizeof(packetbuf_addrs));
    363c:	86 2f       	mov	r24, r22
    363e:	97 2f       	mov	r25, r23
    3640:	dc 01       	movw	r26, r24
    3642:	eb e6       	ldi	r30, 0x6B	; 107
    3644:	fe e0       	ldi	r31, 0x0E	; 14
    3646:	88 e0       	ldi	r24, 0x08	; 8
    3648:	01 90       	ld	r0, Z+
    364a:	0d 92       	st	X+, r0
    364c:	81 50       	subi	r24, 0x01	; 1
    364e:	e1 f7       	brne	.-8      	; 0x3648 <packetbuf_attr_copyto+0x20>
}
    3650:	08 95       	ret

00003652 <packetbuf_attr_copyfrom>:
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_copyfrom(struct packetbuf_attr *attrs,
		      struct packetbuf_addr *addrs)
{
  memcpy(packetbuf_attrs, attrs, sizeof(packetbuf_attrs));
    3652:	e3 e7       	ldi	r30, 0x73	; 115
    3654:	fe e0       	ldi	r31, 0x0E	; 14
    3656:	28 2f       	mov	r18, r24
    3658:	39 2f       	mov	r19, r25
    365a:	d9 01       	movw	r26, r18
    365c:	80 e3       	ldi	r24, 0x30	; 48
    365e:	0d 90       	ld	r0, X+
    3660:	01 92       	st	Z+, r0
    3662:	81 50       	subi	r24, 0x01	; 1
    3664:	e1 f7       	brne	.-8      	; 0x365e <packetbuf_attr_copyfrom+0xc>
  memcpy(packetbuf_addrs, addrs, sizeof(packetbuf_addrs));
    3666:	ab e6       	ldi	r26, 0x6B	; 107
    3668:	be e0       	ldi	r27, 0x0E	; 14
    366a:	86 2f       	mov	r24, r22
    366c:	97 2f       	mov	r25, r23
    366e:	fc 01       	movw	r30, r24
    3670:	88 e0       	ldi	r24, 0x08	; 8
    3672:	01 90       	ld	r0, Z+
    3674:	0d 92       	st	X+, r0
    3676:	81 50       	subi	r24, 0x01	; 1
    3678:	e1 f7       	brne	.-8      	; 0x3672 <packetbuf_attr_copyfrom+0x20>
}
    367a:	08 95       	ret

0000367c <queuebuf_init>:
  for(i=0; i<NQBUF_FILES; i++) {
    qbuf_files[i].renewable = 1;
    qbuf_renew_file(i);
  }
#endif
  memb_init(&buframmem);
    367c:	89 eb       	ldi	r24, 0xB9	; 185
    367e:	95 e0       	ldi	r25, 0x05	; 5
    3680:	0e 94 93 16 	call	0x2d26	; 0x2d26 <memb_init>
  memb_init(&bufmem);
    3684:	89 ea       	ldi	r24, 0xA9	; 169
    3686:	95 e0       	ldi	r25, 0x05	; 5
    3688:	0e 94 93 16 	call	0x2d26	; 0x2d26 <memb_init>
  memb_init(&refbufmem);
    368c:	81 eb       	ldi	r24, 0xB1	; 177
    368e:	95 e0       	ldi	r25, 0x05	; 5
    3690:	0e 94 93 16 	call	0x2d26	; 0x2d26 <memb_init>
#if QUEUEBUF_STATS
  queuebuf_max_len = QUEUEBUF_NUM;
#endif /* QUEUEBUF_STATS */
}
    3694:	08 95       	ret

00003696 <queuebuf_new_from_packetbuf>:
queuebuf_new_from_packetbuf_debug(const char *file, int line)
#else /* QUEUEBUF_DEBUG */
struct queuebuf *
queuebuf_new_from_packetbuf(void)
#endif /* QUEUEBUF_DEBUG */
{
    3696:	ef 92       	push	r14
    3698:	ff 92       	push	r15
    369a:	0f 93       	push	r16
    369c:	1f 93       	push	r17
    369e:	cf 93       	push	r28
    36a0:	df 93       	push	r29
  struct queuebuf *buf;
  struct queuebuf_ref *rbuf;

  if(packetbuf_is_reference()) {
    36a2:	0e 94 24 1a 	call	0x3448	; 0x3448 <packetbuf_is_reference>
    36a6:	00 97       	sbiw	r24, 0x00	; 0
    36a8:	c9 f0       	breq	.+50     	; 0x36dc <queuebuf_new_from_packetbuf+0x46>
    rbuf = memb_alloc(&refbufmem);
    36aa:	81 eb       	ldi	r24, 0xB1	; 177
    36ac:	95 e0       	ldi	r25, 0x05	; 5
    36ae:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <memb_alloc>
    36b2:	e8 2e       	mov	r14, r24
    36b4:	e7 01       	movw	r28, r14
    36b6:	7e 01       	movw	r14, r28
    36b8:	f9 2e       	mov	r15, r25
    36ba:	e7 01       	movw	r28, r14
    if(rbuf != NULL) {
    36bc:	20 97       	sbiw	r28, 0x00	; 0
    36be:	91 f1       	breq	.+100    	; 0x3724 <queuebuf_new_from_packetbuf+0x8e>
#if QUEUEBUF_STATS
      ++queuebuf_ref_len;
#endif /* QUEUEBUF_STATS */
      rbuf->len = packetbuf_datalen();
    36c0:	0e 94 67 1a 	call	0x34ce	; 0x34ce <packetbuf_datalen>
    36c4:	99 83       	std	Y+1, r25	; 0x01
    36c6:	88 83       	st	Y, r24
      rbuf->ref = packetbuf_reference_ptr();
    36c8:	0e 94 62 1a 	call	0x34c4	; 0x34c4 <packetbuf_reference_ptr>
    36cc:	9b 83       	std	Y+3, r25	; 0x03
    36ce:	8a 83       	std	Y+2, r24	; 0x02
      rbuf->hdrlen = packetbuf_copyto_hdr(rbuf->hdr);
    36d0:	c7 01       	movw	r24, r14
    36d2:	04 96       	adiw	r24, 0x04	; 4
    36d4:	0e 94 90 19 	call	0x3320	; 0x3320 <packetbuf_copyto_hdr>
    36d8:	8c ab       	std	Y+52, r24	; 0x34
    } else {
      PRINTF("queuebuf_new_from_packetbuf: could not allocate a reference queuebuf\n");
    }
    return (struct queuebuf *)rbuf;
    36da:	24 c0       	rjmp	.+72     	; 0x3724 <queuebuf_new_from_packetbuf+0x8e>
  } else {
    struct queuebuf_data *buframptr;
    buf = memb_alloc(&bufmem);
    36dc:	89 ea       	ldi	r24, 0xA9	; 169
    36de:	95 e0       	ldi	r25, 0x05	; 5
    36e0:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <memb_alloc>
    36e4:	ec 01       	movw	r28, r24
    36e6:	7e 01       	movw	r14, r28
    36e8:	f9 2e       	mov	r15, r25
    36ea:	e7 01       	movw	r28, r14
    if(buf != NULL) {
    36ec:	20 97       	sbiw	r28, 0x00	; 0
    36ee:	d1 f0       	breq	.+52     	; 0x3724 <queuebuf_new_from_packetbuf+0x8e>
      list_add(queuebuf_list, buf);
      buf->file = file;
      buf->line = line;
      buf->time = clock_time();
#endif /* QUEUEBUF_DEBUG */
      buf->ram_ptr = memb_alloc(&buframmem);
    36f0:	89 eb       	ldi	r24, 0xB9	; 185
    36f2:	95 e0       	ldi	r25, 0x05	; 5
    36f4:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <memb_alloc>
    36f8:	8c 01       	movw	r16, r24
    36fa:	99 83       	std	Y+1, r25	; 0x01
    36fc:	88 83       	st	Y, r24
        buf->swap_id = -1;
        tmpdata_qbuf = buf;
        buframptr = &tmpdata;
      }
#else
      if(buf->ram_ptr == NULL) {
    36fe:	00 97       	sbiw	r24, 0x00	; 0
    3700:	79 f0       	breq	.+30     	; 0x3720 <queuebuf_new_from_packetbuf+0x8a>
        return NULL;
      }
      buframptr = buf->ram_ptr;
#endif

      buframptr->len = packetbuf_copyto(buframptr->data);
    3702:	02 96       	adiw	r24, 0x02	; 2
    3704:	0e 94 a7 19 	call	0x334e	; 0x334e <packetbuf_copyto>
    3708:	f8 01       	movw	r30, r16
    370a:	91 83       	std	Z+1, r25	; 0x01
    370c:	80 83       	st	Z, r24
      packetbuf_attr_copyto(buframptr->attrs, buframptr->addrs);
    370e:	b8 01       	movw	r22, r16
    3710:	6e 54       	subi	r22, 0x4E	; 78
    3712:	7f 4f       	sbci	r23, 0xFF	; 255
    3714:	c8 01       	movw	r24, r16
    3716:	8e 57       	subi	r24, 0x7E	; 126
    3718:	9f 4f       	sbci	r25, 0xFF	; 255
    371a:	0e 94 14 1b 	call	0x3628	; 0x3628 <packetbuf_attr_copyto>
    371e:	02 c0       	rjmp	.+4      	; 0x3724 <queuebuf_new_from_packetbuf+0x8e>
        buframptr = &tmpdata;
      }
#else
      if(buf->ram_ptr == NULL) {
        PRINTF("queuebuf_new_from_packetbuf: could not queuebuf data\n");
        return NULL;
    3720:	c0 e0       	ldi	r28, 0x00	; 0
    3722:	d0 e0       	ldi	r29, 0x00	; 0
    } else {
      PRINTF("queuebuf_new_from_packetbuf: could not allocate a queuebuf\n");
    }
    return buf;
  }
}
    3724:	ce 01       	movw	r24, r28
    3726:	df 91       	pop	r29
    3728:	cf 91       	pop	r28
    372a:	1f 91       	pop	r17
    372c:	0f 91       	pop	r16
    372e:	ff 90       	pop	r15
    3730:	ef 90       	pop	r14
    3732:	08 95       	ret

00003734 <queuebuf_update_attr_from_packetbuf>:
#else /* WITH_SWAP */
/*---------------------------------------------------------------------------*/
static struct queuebuf_data *
queuebuf_load_to_ram(struct queuebuf *b)
{
  return b->ram_ptr;
    3734:	fc 01       	movw	r30, r24
    3736:	80 81       	ld	r24, Z
    3738:	91 81       	ldd	r25, Z+1	; 0x01
/*---------------------------------------------------------------------------*/
void
queuebuf_update_attr_from_packetbuf(struct queuebuf *buf)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(buf);
  packetbuf_attr_copyto(buframptr->attrs, buframptr->addrs);
    373a:	bc 01       	movw	r22, r24
    373c:	6e 54       	subi	r22, 0x4E	; 78
    373e:	7f 4f       	sbci	r23, 0xFF	; 255
    3740:	8e 57       	subi	r24, 0x7E	; 126
    3742:	9f 4f       	sbci	r25, 0xFF	; 255
    3744:	0e 94 14 1b 	call	0x3628	; 0x3628 <packetbuf_attr_copyto>
#if WITH_SWAP
  if(buf->location == IN_CFS) {
    queuebuf_flush_tmpdata();
  }
#endif
}
    3748:	08 95       	ret

0000374a <queuebuf_free>:
/*---------------------------------------------------------------------------*/
void
queuebuf_free(struct queuebuf *buf)
{
    374a:	cf 93       	push	r28
    374c:	df 93       	push	r29
    374e:	ec 01       	movw	r28, r24
  if(memb_inmemb(&bufmem, buf)) {
    3750:	89 ea       	ldi	r24, 0xA9	; 169
    3752:	95 e0       	ldi	r25, 0x05	; 5
    3754:	be 01       	movw	r22, r28
    3756:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <memb_inmemb>
    375a:	00 97       	sbiw	r24, 0x00	; 0
    375c:	49 f0       	breq	.+18     	; 0x3770 <queuebuf_free+0x26>
      memb_free(&buframmem, buf->ram_ptr);
    } else {
      queuebuf_remove_from_file(buf->swap_id);
    }
#else
    memb_free(&buframmem, buf->ram_ptr);
    375e:	68 81       	ld	r22, Y
    3760:	79 81       	ldd	r23, Y+1	; 0x01
    3762:	89 eb       	ldi	r24, 0xB9	; 185
    3764:	95 e0       	ldi	r25, 0x05	; 5
    3766:	0e 94 d9 16 	call	0x2db2	; 0x2db2 <memb_free>
#endif
    memb_free(&bufmem, buf);
    376a:	89 ea       	ldi	r24, 0xA9	; 169
    376c:	95 e0       	ldi	r25, 0x05	; 5
    376e:	09 c0       	rjmp	.+18     	; 0x3782 <queuebuf_free+0x38>
    printf("#A q=%d\n", queuebuf_len);
#endif /* QUEUEBUF_STATS */
#if QUEUEBUF_DEBUG
    list_remove(queuebuf_list, buf);
#endif /* QUEUEBUF_DEBUG */
  } else if(memb_inmemb(&refbufmem, buf)) {
    3770:	81 eb       	ldi	r24, 0xB1	; 177
    3772:	95 e0       	ldi	r25, 0x05	; 5
    3774:	be 01       	movw	r22, r28
    3776:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <memb_inmemb>
    377a:	00 97       	sbiw	r24, 0x00	; 0
    377c:	29 f0       	breq	.+10     	; 0x3788 <queuebuf_free+0x3e>
    memb_free(&refbufmem, buf);
    377e:	81 eb       	ldi	r24, 0xB1	; 177
    3780:	95 e0       	ldi	r25, 0x05	; 5
    3782:	be 01       	movw	r22, r28
    3784:	0e 94 d9 16 	call	0x2db2	; 0x2db2 <memb_free>
#if QUEUEBUF_STATS
    --queuebuf_ref_len;
#endif /* QUEUEBUF_STATS */
  }
}
    3788:	df 91       	pop	r29
    378a:	cf 91       	pop	r28
    378c:	08 95       	ret

0000378e <queuebuf_to_packetbuf>:
/*---------------------------------------------------------------------------*/
void
queuebuf_to_packetbuf(struct queuebuf *b)
{
    378e:	ef 92       	push	r14
    3790:	ff 92       	push	r15
    3792:	cf 93       	push	r28
    3794:	df 93       	push	r29
    3796:	ec 01       	movw	r28, r24
  struct queuebuf_ref *r;
  if(memb_inmemb(&bufmem, b)) {
    3798:	89 ea       	ldi	r24, 0xA9	; 169
    379a:	95 e0       	ldi	r25, 0x05	; 5
    379c:	be 01       	movw	r22, r28
    379e:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <memb_inmemb>
    37a2:	00 97       	sbiw	r24, 0x00	; 0
    37a4:	91 f0       	breq	.+36     	; 0x37ca <queuebuf_to_packetbuf+0x3c>
#else /* WITH_SWAP */
/*---------------------------------------------------------------------------*/
static struct queuebuf_data *
queuebuf_load_to_ram(struct queuebuf *b)
{
  return b->ram_ptr;
    37a6:	09 90       	ld	r0, Y+
    37a8:	d8 81       	ld	r29, Y
    37aa:	c0 2d       	mov	r28, r0
queuebuf_to_packetbuf(struct queuebuf *b)
{
  struct queuebuf_ref *r;
  if(memb_inmemb(&bufmem, b)) {
    struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
    packetbuf_copyfrom(buframptr->data, buframptr->len);
    37ac:	68 81       	ld	r22, Y
    37ae:	79 81       	ldd	r23, Y+1	; 0x01
    37b0:	ce 01       	movw	r24, r28
    37b2:	02 96       	adiw	r24, 0x02	; 2
    37b4:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <packetbuf_copyfrom>
    packetbuf_attr_copyfrom(buframptr->attrs, buframptr->addrs);
    37b8:	be 01       	movw	r22, r28
    37ba:	6e 54       	subi	r22, 0x4E	; 78
    37bc:	7f 4f       	sbci	r23, 0xFF	; 255
    37be:	ce 01       	movw	r24, r28
    37c0:	8e 57       	subi	r24, 0x7E	; 126
    37c2:	9f 4f       	sbci	r25, 0xFF	; 255
    37c4:	0e 94 29 1b 	call	0x3652	; 0x3652 <packetbuf_attr_copyfrom>
    37c8:	1b c0       	rjmp	.+54     	; 0x3800 <queuebuf_to_packetbuf+0x72>
  } else if(memb_inmemb(&refbufmem, b)) {
    37ca:	81 eb       	ldi	r24, 0xB1	; 177
    37cc:	95 e0       	ldi	r25, 0x05	; 5
    37ce:	be 01       	movw	r22, r28
    37d0:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <memb_inmemb>
    37d4:	00 97       	sbiw	r24, 0x00	; 0
    37d6:	a1 f0       	breq	.+40     	; 0x3800 <queuebuf_to_packetbuf+0x72>
    r = (struct queuebuf_ref *)b;
    packetbuf_clear();
    37d8:	0e 94 b8 1a 	call	0x3570	; 0x3570 <packetbuf_clear>
    packetbuf_copyfrom(r->ref, r->len);
    37dc:	68 81       	ld	r22, Y
    37de:	79 81       	ldd	r23, Y+1	; 0x01
    37e0:	8a 81       	ldd	r24, Y+2	; 0x02
    37e2:	9b 81       	ldd	r25, Y+3	; 0x03
    37e4:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <packetbuf_copyfrom>
    packetbuf_hdralloc(r->hdrlen);
    37e8:	8c a9       	ldd	r24, Y+52	; 0x34
    37ea:	90 e0       	ldi	r25, 0x00	; 0
    37ec:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <packetbuf_hdralloc>
    memcpy(packetbuf_hdrptr(), r->hdr, r->hdrlen);
    37f0:	0e 94 1d 1a 	call	0x343a	; 0x343a <packetbuf_hdrptr>
    37f4:	4c a9       	ldd	r20, Y+52	; 0x34
    37f6:	24 96       	adiw	r28, 0x04	; 4
    37f8:	be 01       	movw	r22, r28
    37fa:	50 e0       	ldi	r21, 0x00	; 0
    37fc:	0e 94 e5 25 	call	0x4bca	; 0x4bca <memcpy>
  }
}
    3800:	df 91       	pop	r29
    3802:	cf 91       	pop	r28
    3804:	ff 90       	pop	r15
    3806:	ef 90       	pop	r14
    3808:	08 95       	ret

0000380a <queuebuf_dataptr>:
/*---------------------------------------------------------------------------*/
void *
queuebuf_dataptr(struct queuebuf *b)
{
    380a:	cf 93       	push	r28
    380c:	df 93       	push	r29
    380e:	ec 01       	movw	r28, r24
  struct queuebuf_ref *r;

  if(memb_inmemb(&bufmem, b)) {
    3810:	89 ea       	ldi	r24, 0xA9	; 169
    3812:	95 e0       	ldi	r25, 0x05	; 5
    3814:	be 01       	movw	r22, r28
    3816:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <memb_inmemb>
    381a:	00 97       	sbiw	r24, 0x00	; 0
    381c:	29 f0       	breq	.+10     	; 0x3828 <queuebuf_dataptr+0x1e>
    struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
    return buframptr->data;
    381e:	28 81       	ld	r18, Y
    3820:	39 81       	ldd	r19, Y+1	; 0x01
    3822:	2e 5f       	subi	r18, 0xFE	; 254
    3824:	3f 4f       	sbci	r19, 0xFF	; 255
    3826:	0c c0       	rjmp	.+24     	; 0x3840 <queuebuf_dataptr+0x36>
  } else if(memb_inmemb(&refbufmem, b)) {
    3828:	81 eb       	ldi	r24, 0xB1	; 177
    382a:	95 e0       	ldi	r25, 0x05	; 5
    382c:	be 01       	movw	r22, r28
    382e:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <memb_inmemb>
    3832:	00 97       	sbiw	r24, 0x00	; 0
    3834:	19 f0       	breq	.+6      	; 0x383c <queuebuf_dataptr+0x32>
    r = (struct queuebuf_ref *)b;
    return r->ref;
    3836:	2a 81       	ldd	r18, Y+2	; 0x02
    3838:	3b 81       	ldd	r19, Y+3	; 0x03
    383a:	02 c0       	rjmp	.+4      	; 0x3840 <queuebuf_dataptr+0x36>
  }
  return NULL;
    383c:	20 e0       	ldi	r18, 0x00	; 0
    383e:	30 e0       	ldi	r19, 0x00	; 0
}
    3840:	c9 01       	movw	r24, r18
    3842:	df 91       	pop	r29
    3844:	cf 91       	pop	r28
    3846:	08 95       	ret

00003848 <queuebuf_datalen>:
/*---------------------------------------------------------------------------*/
int
queuebuf_datalen(struct queuebuf *b)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return buframptr->len;
    3848:	dc 01       	movw	r26, r24
    384a:	ed 91       	ld	r30, X+
    384c:	fc 91       	ld	r31, X
    384e:	11 97       	sbiw	r26, 0x01	; 1
}
    3850:	80 81       	ld	r24, Z
    3852:	91 81       	ldd	r25, Z+1	; 0x01
    3854:	08 95       	ret

00003856 <queuebuf_addr>:
/*---------------------------------------------------------------------------*/
rimeaddr_t *
queuebuf_addr(struct queuebuf *b, uint8_t type)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return &buframptr->addrs[type - PACKETBUF_ADDR_FIRST].addr;
    3856:	70 e0       	ldi	r23, 0x00	; 0
    3858:	6f 5b       	subi	r22, 0xBF	; 191
    385a:	7f 4f       	sbci	r23, 0xFF	; 255
    385c:	66 0f       	add	r22, r22
    385e:	77 1f       	adc	r23, r23
    3860:	fc 01       	movw	r30, r24
    3862:	20 81       	ld	r18, Z
    3864:	31 81       	ldd	r19, Z+1	; 0x01
    3866:	26 0f       	add	r18, r22
    3868:	37 1f       	adc	r19, r23
}
    386a:	c9 01       	movw	r24, r18
    386c:	08 95       	ret

0000386e <queuebuf_attr>:
/*---------------------------------------------------------------------------*/
packetbuf_attr_t
queuebuf_attr(struct queuebuf *b, uint8_t type)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return buframptr->attrs[type].val;
    386e:	dc 01       	movw	r26, r24
    3870:	ed 91       	ld	r30, X+
    3872:	fc 91       	ld	r31, X
    3874:	11 97       	sbiw	r26, 0x01	; 1
    3876:	70 e0       	ldi	r23, 0x00	; 0
    3878:	6f 5b       	subi	r22, 0xBF	; 191
    387a:	7f 4f       	sbci	r23, 0xFF	; 255
    387c:	66 0f       	add	r22, r22
    387e:	77 1f       	adc	r23, r23
    3880:	e6 0f       	add	r30, r22
    3882:	f7 1f       	adc	r31, r23
}
    3884:	80 81       	ld	r24, Z
    3886:	91 81       	ldd	r25, Z+1	; 0x01
    3888:	08 95       	ret

0000388a <queuebuf_debug_print>:
      q = list_item_next(q)) {
    printf("%s,%d,%lu ", q->file, q->line, q->time);
  }
  printf("\n");
#endif /* QUEUEBUF_DEBUG */
}
    388a:	08 95       	ret

0000388c <__vector_18>:
#endif

#if NUMPORTS > 0
int (* input_handler_0)(unsigned char);
ISR(D_USART0_RX_vect)
{
    388c:	1f 92       	push	r1
    388e:	0f 92       	push	r0
    3890:	0f b6       	in	r0, 0x3f	; 63
    3892:	0f 92       	push	r0
    3894:	0b b6       	in	r0, 0x3b	; 59
    3896:	0f 92       	push	r0
    3898:	11 24       	eor	r1, r1
    389a:	2f 93       	push	r18
    389c:	3f 93       	push	r19
    389e:	4f 93       	push	r20
    38a0:	5f 93       	push	r21
    38a2:	6f 93       	push	r22
    38a4:	7f 93       	push	r23
    38a6:	8f 93       	push	r24
    38a8:	9f 93       	push	r25
    38aa:	af 93       	push	r26
    38ac:	bf 93       	push	r27
    38ae:	ef 93       	push	r30
    38b0:	ff 93       	push	r31
  unsigned char c;
  c = D_UDR0;
    38b2:	8c b1       	in	r24, 0x0c	; 12
  if (input_handler_0 != NULL) input_handler_0(c);
    38b4:	e0 91 a5 0e 	lds	r30, 0x0EA5
    38b8:	f0 91 a6 0e 	lds	r31, 0x0EA6
    38bc:	30 97       	sbiw	r30, 0x00	; 0
    38be:	09 f0       	breq	.+2      	; 0x38c2 <__vector_18+0x36>
    38c0:	09 95       	icall
}
    38c2:	ff 91       	pop	r31
    38c4:	ef 91       	pop	r30
    38c6:	bf 91       	pop	r27
    38c8:	af 91       	pop	r26
    38ca:	9f 91       	pop	r25
    38cc:	8f 91       	pop	r24
    38ce:	7f 91       	pop	r23
    38d0:	6f 91       	pop	r22
    38d2:	5f 91       	pop	r21
    38d4:	4f 91       	pop	r20
    38d6:	3f 91       	pop	r19
    38d8:	2f 91       	pop	r18
    38da:	0f 90       	pop	r0
    38dc:	0b be       	out	0x3b, r0	; 59
    38de:	0f 90       	pop	r0
    38e0:	0f be       	out	0x3f, r0	; 63
    38e2:	0f 90       	pop	r0
    38e4:	1f 90       	pop	r1
    38e6:	18 95       	reti

000038e8 <__vector_30>:
#endif

#if NUMPORTS > 1
int (* input_handler_1)(unsigned char);
ISR(D_USART1_RX_vect)
{
    38e8:	1f 92       	push	r1
    38ea:	0f 92       	push	r0
    38ec:	0f b6       	in	r0, 0x3f	; 63
    38ee:	0f 92       	push	r0
    38f0:	0b b6       	in	r0, 0x3b	; 59
    38f2:	0f 92       	push	r0
    38f4:	11 24       	eor	r1, r1
    38f6:	2f 93       	push	r18
    38f8:	3f 93       	push	r19
    38fa:	4f 93       	push	r20
    38fc:	5f 93       	push	r21
    38fe:	6f 93       	push	r22
    3900:	7f 93       	push	r23
    3902:	8f 93       	push	r24
    3904:	9f 93       	push	r25
    3906:	af 93       	push	r26
    3908:	bf 93       	push	r27
    390a:	ef 93       	push	r30
    390c:	ff 93       	push	r31
  unsigned char c;
  c = D_UDR1;
    390e:	80 91 9c 00 	lds	r24, 0x009C
  if (input_handler_1 != NULL) input_handler_1(c);
    3912:	e0 91 a3 0e 	lds	r30, 0x0EA3
    3916:	f0 91 a4 0e 	lds	r31, 0x0EA4
    391a:	30 97       	sbiw	r30, 0x00	; 0
    391c:	09 f0       	breq	.+2      	; 0x3920 <__vector_30+0x38>
    391e:	09 95       	icall
}
    3920:	ff 91       	pop	r31
    3922:	ef 91       	pop	r30
    3924:	bf 91       	pop	r27
    3926:	af 91       	pop	r26
    3928:	9f 91       	pop	r25
    392a:	8f 91       	pop	r24
    392c:	7f 91       	pop	r23
    392e:	6f 91       	pop	r22
    3930:	5f 91       	pop	r21
    3932:	4f 91       	pop	r20
    3934:	3f 91       	pop	r19
    3936:	2f 91       	pop	r18
    3938:	0f 90       	pop	r0
    393a:	0b be       	out	0x3b, r0	; 59
    393c:	0f 90       	pop	r0
    393e:	0f be       	out	0x3f, r0	; 63
    3940:	0f 90       	pop	r0
    3942:	1f 90       	pop	r1
    3944:	18 95       	reti

00003946 <rs232_init>:
/*---------------------------------------------------------------------------*/
void
rs232_init (uint8_t port, uint8_t bd, uint8_t ffmt)
{
#if NUMPORTS > 0
 if (port == 0) {
    3946:	88 23       	and	r24, r24
    3948:	61 f4       	brne	.+24     	; 0x3962 <rs232_init+0x1c>
   D_UBRR0H = (uint8_t)(bd>>8);
    394a:	10 92 90 00 	sts	0x0090, r1
   D_UBRR0L = (uint8_t)bd;
    394e:	69 b9       	out	0x09, r22	; 9
#if RS232_TX_INTERRUPTS
   txwait_0 = 0;
   D_UCSR0B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#else
   D_UCSR0B =  USART_INTERRUPT_RX_COMPLETE | \
    3950:	88 e9       	ldi	r24, 0x98	; 152
    3952:	8a b9       	out	0x0a, r24	; 10
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#endif
   D_UCSR0C = USART_UCSRC_SEL | ffmt;
    3954:	40 93 95 00 	sts	0x0095, r20
   input_handler_0 = NULL;
    3958:	10 92 a6 0e 	sts	0x0EA6, r1
    395c:	10 92 a5 0e 	sts	0x0EA5, r1
    3960:	08 95       	ret

#if NUMPORTS > 1
 } else if (port == 1) {
    3962:	81 30       	cpi	r24, 0x01	; 1
    3964:	69 f4       	brne	.+26     	; 0x3980 <rs232_init+0x3a>
   D_UBRR1H = (uint8_t)(bd>>8);
    3966:	10 92 98 00 	sts	0x0098, r1
   D_UBRR1L = (uint8_t)bd;
    396a:	60 93 99 00 	sts	0x0099, r22
#if RS232_TX_INTERRUPTS
   txwait_1 = 0;
   D_UCSR1B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#else
   D_UCSR1B =  USART_INTERRUPT_RX_COMPLETE | \
    396e:	88 e9       	ldi	r24, 0x98	; 152
    3970:	80 93 9a 00 	sts	0x009A, r24
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#endif
   D_UCSR1C = USART_UCSRC_SEL | ffmt;
    3974:	40 93 9d 00 	sts	0x009D, r20
   input_handler_1 = NULL;
    3978:	10 92 a4 0e 	sts	0x0EA4, r1
    397c:	10 92 a3 0e 	sts	0x0EA3, r1
    3980:	08 95       	ret

00003982 <rs232_send>:
  }
#endif
#else /* RS232_TX_INTERRUPTS */
  /* Block until tx ready and output character */
#if NUMPORTS > 0
  if (port == 0 ) {
    3982:	88 23       	and	r24, r24
    3984:	21 f4       	brne	.+8      	; 0x398e <rs232_send+0xc>
    while (!(D_UCSR0A & D_UDRE0M));
    3986:	5d 9b       	sbis	0x0b, 5	; 11
    3988:	fe cf       	rjmp	.-4      	; 0x3986 <rs232_send+0x4>
    D_UDR0 = c;
    398a:	6c b9       	out	0x0c, r22	; 12
    398c:	08 95       	ret
#if NUMPORTS > 1
  } else if (port == 1) {
    398e:	81 30       	cpi	r24, 0x01	; 1
    3990:	31 f4       	brne	.+12     	; 0x399e <rs232_send+0x1c>
    while (!(D_UCSR1A & D_UDRE1M));
    3992:	80 91 9b 00 	lds	r24, 0x009B
    3996:	85 ff       	sbrs	r24, 5
    3998:	fc cf       	rjmp	.-8      	; 0x3992 <rs232_send+0x10>
    D_UDR1 = c;
    399a:	60 93 9c 00 	sts	0x009C, r22
    399e:	08 95       	ret

000039a0 <rs232_stdout_putchar>:
static FILE rs232_stdout = FDEV_SETUP_STREAM(rs232_stdout_putchar,
					     NULL,
					     _FDEV_SETUP_WRITE);

int rs232_stdout_putchar(char c, FILE *stream)
{
    39a0:	1f 93       	push	r17
    39a2:	18 2f       	mov	r17, r24
#if ADD_CARRIAGE_RETURN_AFTER_NEWLINE
  if(c=='\n') rs232_send(stdout_rs232_port, '\r');
    39a4:	8a 30       	cpi	r24, 0x0A	; 10
    39a6:	31 f4       	brne	.+12     	; 0x39b4 <rs232_stdout_putchar+0x14>
    39a8:	80 91 05 0e 	lds	r24, 0x0E05
    39ac:	6d e0       	ldi	r22, 0x0D	; 13
    39ae:	0e 94 c1 1c 	call	0x3982	; 0x3982 <rs232_send>
    39b2:	02 c0       	rjmp	.+4      	; 0x39b8 <rs232_stdout_putchar+0x18>
  if(c!='\r') rs232_send (stdout_rs232_port, c);
    39b4:	8d 30       	cpi	r24, 0x0D	; 13
    39b6:	29 f0       	breq	.+10     	; 0x39c2 <rs232_stdout_putchar+0x22>
    39b8:	80 91 05 0e 	lds	r24, 0x0E05
    39bc:	61 2f       	mov	r22, r17
    39be:	0e 94 c1 1c 	call	0x3982	; 0x3982 <rs232_send>
#else
  rs232_send (stdout_rs232_port, c);
#endif
  return 0;
}
    39c2:	80 e0       	ldi	r24, 0x00	; 0
    39c4:	90 e0       	ldi	r25, 0x00	; 0
    39c6:	1f 91       	pop	r17
    39c8:	08 95       	ret

000039ca <rs232_set_input>:
/*---------------------------------------------------------------------------*/
void
rs232_set_input(uint8_t port, int (*f)(unsigned char))
{
#if NUMPORTS > 0
  if (port == 0) {
    39ca:	88 23       	and	r24, r24
    39cc:	29 f4       	brne	.+10     	; 0x39d8 <rs232_set_input+0xe>
    input_handler_0 = f;
    39ce:	70 93 a6 0e 	sts	0x0EA6, r23
    39d2:	60 93 a5 0e 	sts	0x0EA5, r22
    39d6:	08 95       	ret
#if NUMPORTS > 1
  } else if (port == 1) {
    39d8:	81 30       	cpi	r24, 0x01	; 1
    39da:	21 f4       	brne	.+8      	; 0x39e4 <rs232_set_input+0x1a>
    input_handler_1 = f;
    39dc:	70 93 a4 0e 	sts	0x0EA4, r23
    39e0:	60 93 a3 0e 	sts	0x0EA3, r22
    39e4:	08 95       	ret

000039e6 <rs232_print>:
}

/*---------------------------------------------------------------------------*/
void
rs232_print(uint8_t port, char *buf)
{
    39e6:	ef 92       	push	r14
    39e8:	ff 92       	push	r15
    39ea:	1f 93       	push	r17
    39ec:	cf 93       	push	r28
    39ee:	df 93       	push	r29
    39f0:	18 2f       	mov	r17, r24
    39f2:	e6 2e       	mov	r14, r22
    39f4:	e7 01       	movw	r28, r14
    39f6:	7e 01       	movw	r14, r28
    39f8:	f7 2e       	mov	r15, r23
    39fa:	e7 01       	movw	r28, r14
  while(*buf) {
    39fc:	0c c0       	rjmp	.+24     	; 0x3a16 <rs232_print+0x30>
#if ADD_CARRIAGE_RETURN_AFTER_NEWLINE
    if(*buf=='\n') rs232_send(port, '\r');
    39fe:	8a 30       	cpi	r24, 0x0A	; 10
    3a00:	21 f4       	brne	.+8      	; 0x3a0a <rs232_print+0x24>
    3a02:	81 2f       	mov	r24, r17
    3a04:	6d e0       	ldi	r22, 0x0D	; 13
    3a06:	0e 94 c1 1c 	call	0x3982	; 0x3982 <rs232_send>
	if(*buf=='\r') buf++; else rs232_send(port, *buf++);
    3a0a:	69 91       	ld	r22, Y+
    3a0c:	6d 30       	cpi	r22, 0x0D	; 13
    3a0e:	19 f0       	breq	.+6      	; 0x3a16 <rs232_print+0x30>
    3a10:	81 2f       	mov	r24, r17
    3a12:	0e 94 c1 1c 	call	0x3982	; 0x3982 <rs232_send>

/*---------------------------------------------------------------------------*/
void
rs232_print(uint8_t port, char *buf)
{
  while(*buf) {
    3a16:	88 81       	ld	r24, Y
    3a18:	88 23       	and	r24, r24
    3a1a:	89 f7       	brne	.-30     	; 0x39fe <rs232_print+0x18>
	if(*buf=='\r') buf++; else rs232_send(port, *buf++);
#else
    rs232_send(port, *buf++);
#endif
  }
}
    3a1c:	df 91       	pop	r29
    3a1e:	cf 91       	pop	r28
    3a20:	1f 91       	pop	r17
    3a22:	ff 90       	pop	r15
    3a24:	ef 90       	pop	r14
    3a26:	08 95       	ret

00003a28 <slip_arch_writeb>:
}
#endif
/*---------------------------------------------------------------------------*/
void
slip_arch_writeb(unsigned char c)
{
    3a28:	68 2f       	mov	r22, r24
  rs232_send(SLIP_PORT, c);
    3a2a:	80 e0       	ldi	r24, 0x00	; 0
    3a2c:	0e 94 c1 1c 	call	0x3982	; 0x3982 <rs232_send>
}
    3a30:	08 95       	ret

00003a32 <rs232_redirect_stdout>:
#endif
  return 0;
}
/*---------------------------------------------------------------------------*/
void rs232_redirect_stdout (uint8_t port) {
  stdout_rs232_port = port;
    3a32:	80 93 05 0e 	sts	0x0E05, r24
  stdout = &rs232_stdout;
    3a36:	81 ec       	ldi	r24, 0xC1	; 193
    3a38:	95 e0       	ldi	r25, 0x05	; 5
    3a3a:	90 93 bb 0e 	sts	0x0EBB, r25
    3a3e:	80 93 ba 0e 	sts	0x0EBA, r24
}
    3a42:	08 95       	ret

00003a44 <leds_arch_init>:


/*---------------------------------------------------------------------------*/
void leds_arch_init(void)
{
  LEDS_PxDIR |= (LEDS_CONF_RED | LEDS_CONF_GREEN | LEDS_CONF_YELLOW);
    3a44:	8a b3       	in	r24, 0x1a	; 26
    3a46:	87 60       	ori	r24, 0x07	; 7
    3a48:	8a bb       	out	0x1a, r24	; 26
  LEDS_PxOUT |= (LEDS_CONF_RED | LEDS_CONF_GREEN | LEDS_CONF_YELLOW);
    3a4a:	8b b3       	in	r24, 0x1b	; 27
    3a4c:	87 60       	ori	r24, 0x07	; 7
    3a4e:	8b bb       	out	0x1b, r24	; 27
}
    3a50:	08 95       	ret

00003a52 <leds_arch_get>:
/*---------------------------------------------------------------------------*/
unsigned char leds_arch_get(void)
{
  return ((LEDS_PxOUT & LEDS_CONF_RED) ? 0 : LEDS_RED)
    3a52:	da 9b       	sbis	0x1b, 2	; 27
    3a54:	02 c0       	rjmp	.+4      	; 0x3a5a <leds_arch_get+0x8>
    3a56:	90 e0       	ldi	r25, 0x00	; 0
    3a58:	01 c0       	rjmp	.+2      	; 0x3a5c <leds_arch_get+0xa>
    3a5a:	94 e0       	ldi	r25, 0x04	; 4
    | ((LEDS_PxOUT & LEDS_CONF_GREEN) ? 0 : LEDS_GREEN)
    3a5c:	81 e0       	ldi	r24, 0x01	; 1
    3a5e:	d9 99       	sbic	0x1b, 1	; 27
    3a60:	80 e0       	ldi	r24, 0x00	; 0
  LEDS_PxOUT |= (LEDS_CONF_RED | LEDS_CONF_GREEN | LEDS_CONF_YELLOW);
}
/*---------------------------------------------------------------------------*/
unsigned char leds_arch_get(void)
{
  return ((LEDS_PxOUT & LEDS_CONF_RED) ? 0 : LEDS_RED)
    3a62:	89 2b       	or	r24, r25
    3a64:	d8 9b       	sbis	0x1b, 0	; 27
    3a66:	02 c0       	rjmp	.+4      	; 0x3a6c <leds_arch_get+0x1a>
    3a68:	90 e0       	ldi	r25, 0x00	; 0
    3a6a:	01 c0       	rjmp	.+2      	; 0x3a6e <leds_arch_get+0x1c>
    3a6c:	92 e0       	ldi	r25, 0x02	; 2
    | ((LEDS_PxOUT & LEDS_CONF_GREEN) ? 0 : LEDS_GREEN)
    | ((LEDS_PxOUT & LEDS_CONF_YELLOW) ? 0 : LEDS_YELLOW);
}
    3a6e:	89 2b       	or	r24, r25
    3a70:	08 95       	ret

00003a72 <leds_arch_set>:
/*---------------------------------------------------------------------------*/
void leds_arch_set(unsigned char leds)
{
  LEDS_PxOUT = (LEDS_PxOUT & ~(LEDS_CONF_RED|LEDS_CONF_GREEN|LEDS_CONF_YELLOW))
    3a72:	2b b3       	in	r18, 0x1b	; 27
    3a74:	28 7f       	andi	r18, 0xF8	; 248
    3a76:	82 ff       	sbrs	r24, 2
    3a78:	02 c0       	rjmp	.+4      	; 0x3a7e <leds_arch_set+0xc>
    3a7a:	40 e0       	ldi	r20, 0x00	; 0
    3a7c:	01 c0       	rjmp	.+2      	; 0x3a80 <leds_arch_set+0xe>
    3a7e:	44 e0       	ldi	r20, 0x04	; 4
    3a80:	80 ff       	sbrs	r24, 0
    3a82:	02 c0       	rjmp	.+4      	; 0x3a88 <leds_arch_set+0x16>
    3a84:	30 e0       	ldi	r19, 0x00	; 0
    3a86:	01 c0       	rjmp	.+2      	; 0x3a8a <leds_arch_set+0x18>
    3a88:	32 e0       	ldi	r19, 0x02	; 2
    | ((leds & LEDS_RED) ? 0 : LEDS_CONF_RED)
    | ((leds & LEDS_GREEN) ? 0 : LEDS_CONF_GREEN)
    | ((leds & LEDS_YELLOW) ? 0 : LEDS_CONF_YELLOW);
    3a8a:	51 e0       	ldi	r21, 0x01	; 1
    3a8c:	81 fd       	sbrc	r24, 1
    3a8e:	50 e0       	ldi	r21, 0x00	; 0
    | ((LEDS_PxOUT & LEDS_CONF_YELLOW) ? 0 : LEDS_YELLOW);
}
/*---------------------------------------------------------------------------*/
void leds_arch_set(unsigned char leds)
{
  LEDS_PxOUT = (LEDS_PxOUT & ~(LEDS_CONF_RED|LEDS_CONF_GREEN|LEDS_CONF_YELLOW))
    3a90:	25 2b       	or	r18, r21
    3a92:	24 2b       	or	r18, r20
    3a94:	23 2b       	or	r18, r19
    3a96:	2b bb       	out	0x1b, r18	; 27
    | ((leds & LEDS_RED) ? 0 : LEDS_CONF_RED)
    | ((leds & LEDS_GREEN) ? 0 : LEDS_CONF_GREEN)
    | ((leds & LEDS_YELLOW) ? 0 : LEDS_CONF_YELLOW);
}
    3a98:	08 95       	ret

00003a9a <strobe>:
}
/*---------------------------------------------------------------------------*/
static void
strobe(enum cc2420_register regname)
{
  CC2420_STROBE(regname);
    3a9a:	c0 98       	cbi	0x18, 0	; 24
    3a9c:	8f b9       	out	0x0f, r24	; 15
    3a9e:	77 9b       	sbis	0x0e, 7	; 14
    3aa0:	fe cf       	rjmp	.-4      	; 0x3a9e <strobe+0x4>
    3aa2:	c0 9a       	sbi	0x18, 0	; 24
}
    3aa4:	08 95       	ret

00003aa6 <status>:
/*---------------------------------------------------------------------------*/
static unsigned int
status(void)
{
  uint8_t status;
  CC2420_GET_STATUS(status);
    3aa6:	c0 98       	cbi	0x18, 0	; 24
    3aa8:	1f b8       	out	0x0f, r1	; 15
    3aaa:	77 9b       	sbis	0x0e, 7	; 14
    3aac:	fe cf       	rjmp	.-4      	; 0x3aaa <status+0x4>
    3aae:	8f b1       	in	r24, 0x0f	; 15
    3ab0:	c0 9a       	sbi	0x18, 0	; 24
  return status;
}
    3ab2:	90 e0       	ldi	r25, 0x00	; 0
    3ab4:	08 95       	ret

00003ab6 <on>:
/*---------------------------------------------------------------------------*/
static uint8_t locked, lock_on, lock_off;

static void
on(void)
{
    3ab6:	cf 93       	push	r28
    3ab8:	df 93       	push	r29
  CC2420_ENABLE_FIFOP_INT();
    3aba:	89 b7       	in	r24, 0x39	; 57
    3abc:	80 64       	ori	r24, 0x40	; 64
    3abe:	89 bf       	out	0x39, r24	; 57
  strobe(CC2420_SRXON);
    3ac0:	83 e0       	ldi	r24, 0x03	; 3
    3ac2:	90 e0       	ldi	r25, 0x00	; 0
    3ac4:	0e 94 4d 1d 	call	0x3a9a	; 0x3a9a <strobe>

  BUSYWAIT_UNTIL(status() & (BV(CC2420_XOSC16M_STABLE)), RTIMER_SECOND / 100);
    3ac8:	c0 91 88 00 	lds	r28, 0x0088
    3acc:	d0 91 89 00 	lds	r29, 0x0089
    3ad0:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    3ad4:	86 fd       	sbrc	r24, 6
    3ad6:	0a c0       	rjmp	.+20     	; 0x3aec <on+0x36>
    3ad8:	80 91 88 00 	lds	r24, 0x0088
    3adc:	90 91 89 00 	lds	r25, 0x0089
    3ae0:	88 54       	subi	r24, 0x48	; 72
    3ae2:	90 40       	sbci	r25, 0x00	; 0
    3ae4:	8c 1b       	sub	r24, r28
    3ae6:	9d 0b       	sbc	r25, r29
    3ae8:	97 fd       	sbrc	r25, 7
    3aea:	f2 cf       	rjmp	.-28     	; 0x3ad0 <on+0x1a>

  ENERGEST_ON(ENERGEST_TYPE_LISTEN);
  receive_on = 1;
    3aec:	81 e0       	ldi	r24, 0x01	; 1
    3aee:	80 93 07 0e 	sts	0x0E07, r24
}
    3af2:	df 91       	pop	r29
    3af4:	cf 91       	pop	r28
    3af6:	08 95       	ret

00003af8 <getreg>:
/*---------------------------------------------------------------------------*/
static unsigned
getreg(enum cc2420_register regname)
{
  unsigned reg;
  CC2420_READ_REG(regname, reg);
    3af8:	c0 98       	cbi	0x18, 0	; 24
    3afa:	80 64       	ori	r24, 0x40	; 64
    3afc:	8f b9       	out	0x0f, r24	; 15
    3afe:	77 9b       	sbis	0x0e, 7	; 14
    3b00:	fe cf       	rjmp	.-4      	; 0x3afe <getreg+0x6>
    3b02:	8f b1       	in	r24, 0x0f	; 15
    3b04:	1f b8       	out	0x0f, r1	; 15
    3b06:	77 9b       	sbis	0x0e, 7	; 14
    3b08:	fe cf       	rjmp	.-4      	; 0x3b06 <getreg+0xe>
    3b0a:	2f b1       	in	r18, 0x0f	; 15
    3b0c:	92 2f       	mov	r25, r18
    3b0e:	80 e0       	ldi	r24, 0x00	; 0
    3b10:	1f b8       	out	0x0f, r1	; 15
    3b12:	77 9b       	sbis	0x0e, 7	; 14
    3b14:	fe cf       	rjmp	.-4      	; 0x3b12 <getreg+0x1a>
    3b16:	2f b1       	in	r18, 0x0f	; 15
    3b18:	c0 9a       	sbi	0x18, 0	; 24
    3b1a:	30 e0       	ldi	r19, 0x00	; 0
    3b1c:	28 2b       	or	r18, r24
    3b1e:	39 2b       	or	r19, r25
  return reg;
}
    3b20:	c9 01       	movw	r24, r18
    3b22:	08 95       	ret

00003b24 <setreg>:
/*---------------------------------------------------------------------------*/
static void
setreg(enum cc2420_register regname, unsigned value)
{
  CC2420_WRITE_REG(regname, value);
    3b24:	c0 98       	cbi	0x18, 0	; 24
    3b26:	8f b9       	out	0x0f, r24	; 15
    3b28:	77 9b       	sbis	0x0e, 7	; 14
    3b2a:	fe cf       	rjmp	.-4      	; 0x3b28 <setreg+0x4>
    3b2c:	7f b9       	out	0x0f, r23	; 15
    3b2e:	77 9b       	sbis	0x0e, 7	; 14
    3b30:	fe cf       	rjmp	.-4      	; 0x3b2e <setreg+0xa>
    3b32:	6f b9       	out	0x0f, r22	; 15
    3b34:	77 9b       	sbis	0x0e, 7	; 14
    3b36:	fe cf       	rjmp	.-4      	; 0x3b34 <setreg+0x10>
    3b38:	1f b8       	out	0x0f, r1	; 15
    3b3a:	77 9b       	sbis	0x0e, 7	; 14
    3b3c:	fe cf       	rjmp	.-4      	; 0x3b3a <setreg+0x16>
    3b3e:	c0 9a       	sbi	0x18, 0	; 24
}
    3b40:	08 95       	ret

00003b42 <set_txpower>:
/*---------------------------------------------------------------------------*/
static void
set_txpower(uint8_t power)
{
    3b42:	1f 93       	push	r17
    3b44:	18 2f       	mov	r17, r24
  uint16_t reg;

  reg = getreg(CC2420_TXCTRL);
    3b46:	85 e1       	ldi	r24, 0x15	; 21
    3b48:	90 e0       	ldi	r25, 0x00	; 0
    3b4a:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <getreg>
  reg = (reg & 0xffe0) | (power & 0x1f);
    3b4e:	bc 01       	movw	r22, r24
    3b50:	60 7e       	andi	r22, 0xE0	; 224
    3b52:	81 2f       	mov	r24, r17
    3b54:	90 e0       	ldi	r25, 0x00	; 0
    3b56:	8f 71       	andi	r24, 0x1F	; 31
    3b58:	90 70       	andi	r25, 0x00	; 0
    3b5a:	68 2b       	or	r22, r24
    3b5c:	79 2b       	or	r23, r25
  setreg(CC2420_TXCTRL, reg);
    3b5e:	85 e1       	ldi	r24, 0x15	; 21
    3b60:	90 e0       	ldi	r25, 0x00	; 0
    3b62:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <setreg>
}
    3b66:	1f 91       	pop	r17
    3b68:	08 95       	ret

00003b6a <cc2420_receiving_packet>:
}
/*---------------------------------------------------------------------------*/
int
cc2420_receiving_packet(void)
{
  return CC2420_SFD_IS_1;
    3b6a:	21 e0       	ldi	r18, 0x01	; 1
    3b6c:	30 e0       	ldi	r19, 0x00	; 0
    3b6e:	84 99       	sbic	0x10, 4	; 16
    3b70:	02 c0       	rjmp	.+4      	; 0x3b76 <cc2420_receiving_packet+0xc>
    3b72:	20 e0       	ldi	r18, 0x00	; 0
    3b74:	30 e0       	ldi	r19, 0x00	; 0
}
    3b76:	c9 01       	movw	r24, r18
    3b78:	08 95       	ret

00003b7a <pending_packet>:
/*---------------------------------------------------------------------------*/
static int
pending_packet(void)
{
  return CC2420_FIFOP_IS_1;
    3b7a:	21 e0       	ldi	r18, 0x01	; 1
    3b7c:	30 e0       	ldi	r19, 0x00	; 0
    3b7e:	0e 99       	sbic	0x01, 6	; 1
    3b80:	02 c0       	rjmp	.+4      	; 0x3b86 <pending_packet+0xc>
    3b82:	20 e0       	ldi	r18, 0x00	; 0
    3b84:	30 e0       	ldi	r19, 0x00	; 0
}
    3b86:	c9 01       	movw	r24, r18
    3b88:	08 95       	ret

00003b8a <flushrx>:
static void
flushrx(void)
{
  uint8_t dummy;

  CC2420_READ_FIFO_BYTE(dummy);
    3b8a:	c0 98       	cbi	0x18, 0	; 24
    3b8c:	8f e7       	ldi	r24, 0x7F	; 127
    3b8e:	8f b9       	out	0x0f, r24	; 15
    3b90:	77 9b       	sbis	0x0e, 7	; 14
    3b92:	fe cf       	rjmp	.-4      	; 0x3b90 <flushrx+0x6>
    3b94:	8f b1       	in	r24, 0x0f	; 15
    3b96:	1f b8       	out	0x0f, r1	; 15
    3b98:	77 9b       	sbis	0x0e, 7	; 14
    3b9a:	fe cf       	rjmp	.-4      	; 0x3b98 <flushrx+0xe>
    3b9c:	8f b1       	in	r24, 0x0f	; 15
    3b9e:	81 e0       	ldi	r24, 0x01	; 1
    3ba0:	90 e0       	ldi	r25, 0x00	; 0
    3ba2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clock_delay>
    3ba6:	c0 9a       	sbi	0x18, 0	; 24
  CC2420_STROBE(CC2420_SFLUSHRX);
    3ba8:	c0 98       	cbi	0x18, 0	; 24
    3baa:	88 e0       	ldi	r24, 0x08	; 8
    3bac:	8f b9       	out	0x0f, r24	; 15
    3bae:	77 9b       	sbis	0x0e, 7	; 14
    3bb0:	fe cf       	rjmp	.-4      	; 0x3bae <flushrx+0x24>
    3bb2:	c0 9a       	sbi	0x18, 0	; 24
  CC2420_STROBE(CC2420_SFLUSHRX);
    3bb4:	c0 98       	cbi	0x18, 0	; 24
    3bb6:	88 e0       	ldi	r24, 0x08	; 8
    3bb8:	8f b9       	out	0x0f, r24	; 15
    3bba:	77 9b       	sbis	0x0e, 7	; 14
    3bbc:	fe cf       	rjmp	.-4      	; 0x3bba <flushrx+0x30>
    3bbe:	c0 9a       	sbi	0x18, 0	; 24
}
    3bc0:	08 95       	ret

00003bc2 <off>:
  ENERGEST_ON(ENERGEST_TYPE_LISTEN);
  receive_on = 1;
}
static void
off(void)
{
    3bc2:	cf 93       	push	r28
    3bc4:	df 93       	push	r29
  /*  PRINTF("off\n");*/
  receive_on = 0;
    3bc6:	10 92 07 0e 	sts	0x0E07, r1

  /* Wait for transmission to end before turning radio off. */
  BUSYWAIT_UNTIL(!(status() & BV(CC2420_TX_ACTIVE)), RTIMER_SECOND / 10);
    3bca:	c0 91 88 00 	lds	r28, 0x0088
    3bce:	d0 91 89 00 	lds	r29, 0x0089
    3bd2:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    3bd6:	83 ff       	sbrs	r24, 3
    3bd8:	0a c0       	rjmp	.+20     	; 0x3bee <off+0x2c>
    3bda:	80 91 88 00 	lds	r24, 0x0088
    3bde:	90 91 89 00 	lds	r25, 0x0089
    3be2:	80 5d       	subi	r24, 0xD0	; 208
    3be4:	92 40       	sbci	r25, 0x02	; 2
    3be6:	8c 1b       	sub	r24, r28
    3be8:	9d 0b       	sbc	r25, r29
    3bea:	97 fd       	sbrc	r25, 7
    3bec:	f2 cf       	rjmp	.-28     	; 0x3bd2 <off+0x10>

  ENERGEST_OFF(ENERGEST_TYPE_LISTEN);
  strobe(CC2420_SRFOFF);
    3bee:	86 e0       	ldi	r24, 0x06	; 6
    3bf0:	90 e0       	ldi	r25, 0x00	; 0
    3bf2:	0e 94 4d 1d 	call	0x3a9a	; 0x3a9a <strobe>
  CC2420_DISABLE_FIFOP_INT();
    3bf6:	89 b7       	in	r24, 0x39	; 57
    3bf8:	8f 7b       	andi	r24, 0xBF	; 191
    3bfa:	89 bf       	out	0x39, r24	; 57

  if(!CC2420_FIFOP_IS_1) {
    3bfc:	0e 99       	sbic	0x01, 6	; 1
    3bfe:	02 c0       	rjmp	.+4      	; 0x3c04 <off+0x42>
    flushrx();
    3c00:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <flushrx>
  }
}
    3c04:	df 91       	pop	r29
    3c06:	cf 91       	pop	r28
    3c08:	08 95       	ret

00003c0a <RELEASE_LOCK>:
/*---------------------------------------------------------------------------*/
#define GET_LOCK() locked++
static void RELEASE_LOCK(void) {
  if(locked == 1) {
    3c0a:	80 91 06 0e 	lds	r24, 0x0E06
    3c0e:	81 30       	cpi	r24, 0x01	; 1
    3c10:	81 f4       	brne	.+32     	; 0x3c32 <RELEASE_LOCK+0x28>
    if(lock_on) {
    3c12:	80 91 08 0e 	lds	r24, 0x0E08
    3c16:	88 23       	and	r24, r24
    3c18:	21 f0       	breq	.+8      	; 0x3c22 <RELEASE_LOCK+0x18>
      on();
    3c1a:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <on>
      lock_on = 0;
    3c1e:	10 92 08 0e 	sts	0x0E08, r1
    }
    if(lock_off) {
    3c22:	80 91 09 0e 	lds	r24, 0x0E09
    3c26:	88 23       	and	r24, r24
    3c28:	21 f0       	breq	.+8      	; 0x3c32 <RELEASE_LOCK+0x28>
      off();
    3c2a:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <off>
      lock_off = 0;
    3c2e:	10 92 09 0e 	sts	0x0E09, r1
    }
  }
  locked--;
    3c32:	80 91 06 0e 	lds	r24, 0x0E06
    3c36:	81 50       	subi	r24, 0x01	; 1
    3c38:	80 93 06 0e 	sts	0x0E06, r24
}
    3c3c:	08 95       	ret

00003c3e <cc2420_prepare>:
  return RADIO_TX_COLLISION;
}
/*---------------------------------------------------------------------------*/
static int
cc2420_prepare(const void *payload, unsigned short payload_len)
{
    3c3e:	0f 93       	push	r16
    3c40:	1f 93       	push	r17
    3c42:	cf 93       	push	r28
    3c44:	df 93       	push	r29
    3c46:	ec 01       	movw	r28, r24
    3c48:	8b 01       	movw	r16, r22
  uint8_t total_len;
#if CC2420_CONF_CHECKSUM
  uint16_t checksum;
#endif /* CC2420_CONF_CHECKSUM */
  GET_LOCK();
    3c4a:	80 91 06 0e 	lds	r24, 0x0E06
    3c4e:	8f 5f       	subi	r24, 0xFF	; 255
    3c50:	80 93 06 0e 	sts	0x0E06, r24

  PRINTF("cc2420: sending %d bytes\n", payload_len);

  RIMESTATS_ADD(lltx);
    3c54:	80 91 5a 0e 	lds	r24, 0x0E5A
    3c58:	90 91 5b 0e 	lds	r25, 0x0E5B
    3c5c:	a0 91 5c 0e 	lds	r26, 0x0E5C
    3c60:	b0 91 5d 0e 	lds	r27, 0x0E5D
    3c64:	01 96       	adiw	r24, 0x01	; 1
    3c66:	a1 1d       	adc	r26, r1
    3c68:	b1 1d       	adc	r27, r1
    3c6a:	80 93 5a 0e 	sts	0x0E5A, r24
    3c6e:	90 93 5b 0e 	sts	0x0E5B, r25
    3c72:	a0 93 5c 0e 	sts	0x0E5C, r26
    3c76:	b0 93 5d 0e 	sts	0x0E5D, r27

  /* Wait for any previous transmission to finish. */
  /*  while(status() & BV(CC2420_TX_ACTIVE));*/

  /* Write packet to TX FIFO. */
  strobe(CC2420_SFLUSHTX);
    3c7a:	89 e0       	ldi	r24, 0x09	; 9
    3c7c:	90 e0       	ldi	r25, 0x00	; 0
    3c7e:	0e 94 4d 1d 	call	0x3a9a	; 0x3a9a <strobe>

#if CC2420_CONF_CHECKSUM
  checksum = crc16_data(payload, payload_len, 0);
#endif /* CC2420_CONF_CHECKSUM */
  total_len = payload_len + AUX_LEN;
    3c82:	80 2f       	mov	r24, r16
    3c84:	8e 5f       	subi	r24, 0xFE	; 254
  CC2420_WRITE_FIFO_BUF(&total_len, 1);
    3c86:	c0 98       	cbi	0x18, 0	; 24
    3c88:	9e e3       	ldi	r25, 0x3E	; 62
    3c8a:	9f b9       	out	0x0f, r25	; 15
    3c8c:	77 9b       	sbis	0x0e, 7	; 14
    3c8e:	fe cf       	rjmp	.-4      	; 0x3c8c <cc2420_prepare+0x4e>
    3c90:	8f b9       	out	0x0f, r24	; 15
    3c92:	77 9b       	sbis	0x0e, 7	; 14
    3c94:	fe cf       	rjmp	.-4      	; 0x3c92 <cc2420_prepare+0x54>
    3c96:	c0 9a       	sbi	0x18, 0	; 24
  CC2420_WRITE_FIFO_BUF(payload, payload_len);
    3c98:	c0 98       	cbi	0x18, 0	; 24
    3c9a:	8e e3       	ldi	r24, 0x3E	; 62
    3c9c:	8f b9       	out	0x0f, r24	; 15
    3c9e:	77 9b       	sbis	0x0e, 7	; 14
    3ca0:	fe cf       	rjmp	.-4      	; 0x3c9e <cc2420_prepare+0x60>
    3ca2:	20 e0       	ldi	r18, 0x00	; 0
    3ca4:	08 c0       	rjmp	.+16     	; 0x3cb6 <cc2420_prepare+0x78>
    3ca6:	8c 0f       	add	r24, r28
    3ca8:	9d 1f       	adc	r25, r29
    3caa:	fc 01       	movw	r30, r24
    3cac:	80 81       	ld	r24, Z
    3cae:	8f b9       	out	0x0f, r24	; 15
    3cb0:	77 9b       	sbis	0x0e, 7	; 14
    3cb2:	fe cf       	rjmp	.-4      	; 0x3cb0 <cc2420_prepare+0x72>
    3cb4:	2f 5f       	subi	r18, 0xFF	; 255
    3cb6:	82 2f       	mov	r24, r18
    3cb8:	90 e0       	ldi	r25, 0x00	; 0
    3cba:	80 17       	cp	r24, r16
    3cbc:	91 07       	cpc	r25, r17
    3cbe:	98 f3       	brcs	.-26     	; 0x3ca6 <cc2420_prepare+0x68>
    3cc0:	c0 9a       	sbi	0x18, 0	; 24
#if CC2420_CONF_CHECKSUM
  CC2420_WRITE_FIFO_BUF(&checksum, CHECKSUM_LEN);
#endif /* CC2420_CONF_CHECKSUM */

  RELEASE_LOCK();
    3cc2:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
  return 0;
}
    3cc6:	80 e0       	ldi	r24, 0x00	; 0
    3cc8:	90 e0       	ldi	r25, 0x00	; 0
    3cca:	df 91       	pop	r29
    3ccc:	cf 91       	pop	r28
    3cce:	1f 91       	pop	r17
    3cd0:	0f 91       	pop	r16
    3cd2:	08 95       	ret

00003cd4 <cc2420_on>:
}
/*---------------------------------------------------------------------------*/
int
cc2420_on(void)
{
  if(receive_on) {
    3cd4:	80 91 07 0e 	lds	r24, 0x0E07
    3cd8:	88 23       	and	r24, r24
    3cda:	79 f4       	brne	.+30     	; 0x3cfa <cc2420_on+0x26>
    return 1;
  }
  if(locked) {
    3cdc:	80 91 06 0e 	lds	r24, 0x0E06
    3ce0:	88 23       	and	r24, r24
    3ce2:	21 f0       	breq	.+8      	; 0x3cec <cc2420_on+0x18>
    lock_on = 1;
    3ce4:	81 e0       	ldi	r24, 0x01	; 1
    3ce6:	80 93 08 0e 	sts	0x0E08, r24
    return 1;
    3cea:	07 c0       	rjmp	.+14     	; 0x3cfa <cc2420_on+0x26>
  }

  GET_LOCK();
    3cec:	81 e0       	ldi	r24, 0x01	; 1
    3cee:	80 93 06 0e 	sts	0x0E06, r24
  on();
    3cf2:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <on>
  RELEASE_LOCK();
    3cf6:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
  return 1;
}
    3cfa:	81 e0       	ldi	r24, 0x01	; 1
    3cfc:	90 e0       	ldi	r25, 0x00	; 0
    3cfe:	08 95       	ret

00003d00 <cc2420_off>:
  return cc2420_transmit(payload_len);
}
/*---------------------------------------------------------------------------*/
int
cc2420_off(void)
{
    3d00:	1f 93       	push	r17
  /* Don't do anything if we are already turned off. */
  if(receive_on == 0) {
    3d02:	80 91 07 0e 	lds	r24, 0x0E07
    3d06:	88 23       	and	r24, r24
    3d08:	b1 f0       	breq	.+44     	; 0x3d36 <cc2420_off+0x36>
    return 1;
  }

  /* If we are called when the driver is locked, we indicate that the
     radio should be turned off when the lock is unlocked. */
  if(locked) {
    3d0a:	80 91 06 0e 	lds	r24, 0x0E06
    3d0e:	88 23       	and	r24, r24
    3d10:	21 f0       	breq	.+8      	; 0x3d1a <cc2420_off+0x1a>
    /*    printf("Off when locked (%d)\n", locked);*/
    lock_off = 1;
    3d12:	81 e0       	ldi	r24, 0x01	; 1
    3d14:	80 93 09 0e 	sts	0x0E09, r24
    return 1;
    3d18:	0e c0       	rjmp	.+28     	; 0x3d36 <cc2420_off+0x36>
  }

  GET_LOCK();
    3d1a:	11 e0       	ldi	r17, 0x01	; 1
    3d1c:	10 93 06 0e 	sts	0x0E06, r17
  /* If we are currently receiving a packet (indicated by SFD == 1),
     we don't actually switch the radio off now, but signal that the
     driver should switch off the radio once the packet has been
     received and processed, by setting the 'lock_off' variable. */
  if(status() & BV(CC2420_TX_ACTIVE)) {
    3d20:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    3d24:	83 ff       	sbrs	r24, 3
    3d26:	03 c0       	rjmp	.+6      	; 0x3d2e <cc2420_off+0x2e>
    lock_off = 1;
    3d28:	10 93 09 0e 	sts	0x0E09, r17
    3d2c:	02 c0       	rjmp	.+4      	; 0x3d32 <cc2420_off+0x32>
  } else {
    off();
    3d2e:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <off>
  }
  RELEASE_LOCK();
    3d32:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
  return 1;
}
    3d36:	81 e0       	ldi	r24, 0x01	; 1
    3d38:	90 e0       	ldi	r25, 0x00	; 0
    3d3a:	1f 91       	pop	r17
    3d3c:	08 95       	ret

00003d3e <cc2420_cca>:
  return valid;
}
/*---------------------------------------------------------------------------*/
static int
cc2420_cca(void)
{
    3d3e:	ef 92       	push	r14
    3d40:	ff 92       	push	r15
    3d42:	0f 93       	push	r16
    3d44:	1f 93       	push	r17
    3d46:	cf 93       	push	r28
    3d48:	df 93       	push	r29

  /* If the radio is locked by an underlying thread (because we are
     being invoked through an interrupt), we preted that the coast is
     clear (i.e., no packet is currently being transmitted by a
     neighbor). */
  if(locked) {
    3d4a:	80 91 06 0e 	lds	r24, 0x0E06
    3d4e:	88 23       	and	r24, r24
    3d50:	d1 f5       	brne	.+116    	; 0x3dc6 <cc2420_cca+0x88>
    return 1;
  }

  GET_LOCK();
    3d52:	81 e0       	ldi	r24, 0x01	; 1
    3d54:	80 93 06 0e 	sts	0x0E06, r24
  if(!receive_on) {
    3d58:	80 91 07 0e 	lds	r24, 0x0E07
    3d5c:	88 23       	and	r24, r24
    3d5e:	29 f4       	brne	.+10     	; 0x3d6a <cc2420_cca+0x2c>
    radio_was_off = 1;
    cc2420_on();
    3d60:	0e 94 6a 1e 	call	0x3cd4	; 0x3cd4 <cc2420_on>
    return 1;
  }

  GET_LOCK();
  if(!receive_on) {
    radio_was_off = 1;
    3d64:	01 e0       	ldi	r16, 0x01	; 1
    3d66:	10 e0       	ldi	r17, 0x00	; 0
    3d68:	02 c0       	rjmp	.+4      	; 0x3d6e <cc2420_cca+0x30>
/*---------------------------------------------------------------------------*/
static int
cc2420_cca(void)
{
  int cca;
  int radio_was_off = 0;
    3d6a:	00 e0       	ldi	r16, 0x00	; 0
    3d6c:	10 e0       	ldi	r17, 0x00	; 0
    radio_was_off = 1;
    cc2420_on();
  }

  /* Make sure that the radio really got turned on. */
  if(!receive_on) {
    3d6e:	80 91 07 0e 	lds	r24, 0x0E07
    3d72:	88 23       	and	r24, r24
    3d74:	41 f4       	brne	.+16     	; 0x3d86 <cc2420_cca+0x48>
    RELEASE_LOCK();
    3d76:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
    if(radio_was_off) {
    3d7a:	01 15       	cp	r16, r1
    3d7c:	11 05       	cpc	r17, r1
    3d7e:	19 f1       	breq	.+70     	; 0x3dc6 <cc2420_cca+0x88>
      cc2420_off();
    3d80:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <cc2420_off>
    3d84:	20 c0       	rjmp	.+64     	; 0x3dc6 <cc2420_cca+0x88>
    }
    return 1;
  }

  BUSYWAIT_UNTIL(status() & BV(CC2420_RSSI_VALID), RTIMER_SECOND / 100);
    3d86:	c0 91 88 00 	lds	r28, 0x0088
    3d8a:	d0 91 89 00 	lds	r29, 0x0089
    3d8e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    3d92:	81 fd       	sbrc	r24, 1
    3d94:	0a c0       	rjmp	.+20     	; 0x3daa <cc2420_cca+0x6c>
    3d96:	80 91 88 00 	lds	r24, 0x0088
    3d9a:	90 91 89 00 	lds	r25, 0x0089
    3d9e:	88 54       	subi	r24, 0x48	; 72
    3da0:	90 40       	sbci	r25, 0x00	; 0
    3da2:	8c 1b       	sub	r24, r28
    3da4:	9d 0b       	sbc	r25, r29
    3da6:	97 fd       	sbrc	r25, 7
    3da8:	f2 cf       	rjmp	.-28     	; 0x3d8e <cc2420_cca+0x50>

  cca = CC2420_CCA_IS_1;
    3daa:	c1 e0       	ldi	r28, 0x01	; 1
    3dac:	d0 e0       	ldi	r29, 0x00	; 0
    3dae:	86 99       	sbic	0x10, 6	; 16
    3db0:	02 c0       	rjmp	.+4      	; 0x3db6 <cc2420_cca+0x78>
    3db2:	c0 e0       	ldi	r28, 0x00	; 0
    3db4:	d0 e0       	ldi	r29, 0x00	; 0

  if(radio_was_off) {
    3db6:	01 15       	cp	r16, r1
    3db8:	11 05       	cpc	r17, r1
    3dba:	11 f0       	breq	.+4      	; 0x3dc0 <cc2420_cca+0x82>
    cc2420_off();
    3dbc:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <cc2420_off>
  }
  RELEASE_LOCK();
    3dc0:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
  return cca;
    3dc4:	02 c0       	rjmp	.+4      	; 0x3dca <cc2420_cca+0x8c>
  if(!receive_on) {
    RELEASE_LOCK();
    if(radio_was_off) {
      cc2420_off();
    }
    return 1;
    3dc6:	c1 e0       	ldi	r28, 0x01	; 1
    3dc8:	d0 e0       	ldi	r29, 0x00	; 0
  if(radio_was_off) {
    cc2420_off();
  }
  RELEASE_LOCK();
  return cca;
}
    3dca:	ce 01       	movw	r24, r28
    3dcc:	df 91       	pop	r29
    3dce:	cf 91       	pop	r28
    3dd0:	1f 91       	pop	r17
    3dd2:	0f 91       	pop	r16
    3dd4:	ff 90       	pop	r15
    3dd6:	ef 90       	pop	r14
    3dd8:	08 95       	ret

00003dda <getrxdata>:
/*---------------------------------------------------------------------------*/

static void
getrxdata(void *buf, int len)
{
  CC2420_READ_FIFO_BUF(buf, len);
    3dda:	c0 98       	cbi	0x18, 0	; 24
    3ddc:	2f e7       	ldi	r18, 0x7F	; 127
    3dde:	2f b9       	out	0x0f, r18	; 15
    3de0:	77 9b       	sbis	0x0e, 7	; 14
    3de2:	fe cf       	rjmp	.-4      	; 0x3de0 <getrxdata+0x6>
    3de4:	2f b1       	in	r18, 0x0f	; 15
    3de6:	40 e0       	ldi	r20, 0x00	; 0
    3de8:	09 c0       	rjmp	.+18     	; 0x3dfc <getrxdata+0x22>
    3dea:	1f b8       	out	0x0f, r1	; 15
    3dec:	77 9b       	sbis	0x0e, 7	; 14
    3dee:	fe cf       	rjmp	.-4      	; 0x3dec <getrxdata+0x12>
    3df0:	2f b1       	in	r18, 0x0f	; 15
    3df2:	fc 01       	movw	r30, r24
    3df4:	e4 0f       	add	r30, r20
    3df6:	f1 1d       	adc	r31, r1
    3df8:	20 83       	st	Z, r18
    3dfa:	4f 5f       	subi	r20, 0xFF	; 255
    3dfc:	24 2f       	mov	r18, r20
    3dfe:	30 e0       	ldi	r19, 0x00	; 0
    3e00:	26 17       	cp	r18, r22
    3e02:	37 07       	cpc	r19, r23
    3e04:	94 f3       	brlt	.-28     	; 0x3dea <getrxdata+0x10>
    3e06:	81 e0       	ldi	r24, 0x01	; 1
    3e08:	90 e0       	ldi	r25, 0x00	; 0
    3e0a:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clock_delay>
    3e0e:	c0 9a       	sbi	0x18, 0	; 24
}
    3e10:	08 95       	ret

00003e12 <cc2420_read>:
  PROCESS_END();
}
/*---------------------------------------------------------------------------*/
static int
cc2420_read(void *buf, unsigned short bufsize)
{
    3e12:	df 92       	push	r13
    3e14:	ef 92       	push	r14
    3e16:	ff 92       	push	r15
    3e18:	0f 93       	push	r16
    3e1a:	1f 93       	push	r17
    3e1c:	df 93       	push	r29
    3e1e:	cf 93       	push	r28
    3e20:	00 d0       	rcall	.+0      	; 0x3e22 <cc2420_read+0x10>
    3e22:	cd b7       	in	r28, 0x3d	; 61
    3e24:	de b7       	in	r29, 0x3e	; 62
    3e26:	8c 01       	movw	r16, r24
    3e28:	7b 01       	movw	r14, r22
  uint8_t len;
#if CC2420_CONF_CHECKSUM
  uint16_t checksum;
#endif /* CC2420_CONF_CHECKSUM */

  if(!CC2420_FIFOP_IS_1) {
    3e2a:	0e 9b       	sbis	0x01, 6	; 1
    3e2c:	c7 c0       	rjmp	.+398    	; 0x3fbc <cc2420_read+0x1aa>
  }
  /*  if(!pending) {
    return 0;
    }*/
  
  pending = 0;
    3e2e:	10 92 0a 0e 	sts	0x0E0A, r1
  
  GET_LOCK();
    3e32:	80 91 06 0e 	lds	r24, 0x0E06
    3e36:	8f 5f       	subi	r24, 0xFF	; 255
    3e38:	80 93 06 0e 	sts	0x0E06, r24

  cc2420_packets_read++;
    3e3c:	80 91 a8 0e 	lds	r24, 0x0EA8
    3e40:	90 91 a9 0e 	lds	r25, 0x0EA9
    3e44:	01 96       	adiw	r24, 0x01	; 1
    3e46:	90 93 a9 0e 	sts	0x0EA9, r25
    3e4a:	80 93 a8 0e 	sts	0x0EA8, r24
  CC2420_READ_FIFO_BUF(buf, len);
}
static void
getrxbyte(uint8_t *byte)
{
  CC2420_READ_FIFO_BYTE(*byte);
    3e4e:	c0 98       	cbi	0x18, 0	; 24
    3e50:	8f e7       	ldi	r24, 0x7F	; 127
    3e52:	8f b9       	out	0x0f, r24	; 15
    3e54:	77 9b       	sbis	0x0e, 7	; 14
    3e56:	fe cf       	rjmp	.-4      	; 0x3e54 <cc2420_read+0x42>
    3e58:	8f b1       	in	r24, 0x0f	; 15
    3e5a:	1f b8       	out	0x0f, r1	; 15
    3e5c:	77 9b       	sbis	0x0e, 7	; 14
    3e5e:	fe cf       	rjmp	.-4      	; 0x3e5c <cc2420_read+0x4a>
    3e60:	df b0       	in	r13, 0x0f	; 15
    3e62:	81 e0       	ldi	r24, 0x01	; 1
    3e64:	90 e0       	ldi	r25, 0x00	; 0
    3e66:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clock_delay>
    3e6a:	c0 9a       	sbi	0x18, 0	; 24

  cc2420_packets_read++;

  getrxbyte(&len);

  if(len > CC2420_MAX_PACKET_LEN) {
    3e6c:	d7 fe       	sbrs	r13, 7
    3e6e:	16 c0       	rjmp	.+44     	; 0x3e9c <cc2420_read+0x8a>
    /* Oops, we must be out of sync. */
    flushrx();
    3e70:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <flushrx>
    RIMESTATS_ADD(badsynch);
    3e74:	80 91 4a 0e 	lds	r24, 0x0E4A
    3e78:	90 91 4b 0e 	lds	r25, 0x0E4B
    3e7c:	a0 91 4c 0e 	lds	r26, 0x0E4C
    3e80:	b0 91 4d 0e 	lds	r27, 0x0E4D
    3e84:	01 96       	adiw	r24, 0x01	; 1
    3e86:	a1 1d       	adc	r26, r1
    3e88:	b1 1d       	adc	r27, r1
    3e8a:	80 93 4a 0e 	sts	0x0E4A, r24
    3e8e:	90 93 4b 0e 	sts	0x0E4B, r25
    3e92:	a0 93 4c 0e 	sts	0x0E4C, r26
    3e96:	b0 93 4d 0e 	sts	0x0E4D, r27
    3e9a:	35 c0       	rjmp	.+106    	; 0x3f06 <cc2420_read+0xf4>
    RELEASE_LOCK();
    return 0;
  }

  if(len <= AUX_LEN) {
    3e9c:	8d 2d       	mov	r24, r13
    3e9e:	83 30       	cpi	r24, 0x03	; 3
    3ea0:	b0 f4       	brcc	.+44     	; 0x3ece <cc2420_read+0xbc>
    flushrx();
    3ea2:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <flushrx>
    RIMESTATS_ADD(tooshort);
    3ea6:	80 91 46 0e 	lds	r24, 0x0E46
    3eaa:	90 91 47 0e 	lds	r25, 0x0E47
    3eae:	a0 91 48 0e 	lds	r26, 0x0E48
    3eb2:	b0 91 49 0e 	lds	r27, 0x0E49
    3eb6:	01 96       	adiw	r24, 0x01	; 1
    3eb8:	a1 1d       	adc	r26, r1
    3eba:	b1 1d       	adc	r27, r1
    3ebc:	80 93 46 0e 	sts	0x0E46, r24
    3ec0:	90 93 47 0e 	sts	0x0E47, r25
    3ec4:	a0 93 48 0e 	sts	0x0E48, r26
    3ec8:	b0 93 49 0e 	sts	0x0E49, r27
    3ecc:	1c c0       	rjmp	.+56     	; 0x3f06 <cc2420_read+0xf4>
    RELEASE_LOCK();
    return 0;
  }

  if(len - AUX_LEN > bufsize) {
    3ece:	6d 2d       	mov	r22, r13
    3ed0:	70 e0       	ldi	r23, 0x00	; 0
    3ed2:	62 50       	subi	r22, 0x02	; 2
    3ed4:	70 40       	sbci	r23, 0x00	; 0
    3ed6:	e6 16       	cp	r14, r22
    3ed8:	f7 06       	cpc	r15, r23
    3eda:	c0 f4       	brcc	.+48     	; 0x3f0c <cc2420_read+0xfa>
    flushrx();
    3edc:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <flushrx>
    RIMESTATS_ADD(toolong);
    3ee0:	80 91 42 0e 	lds	r24, 0x0E42
    3ee4:	90 91 43 0e 	lds	r25, 0x0E43
    3ee8:	a0 91 44 0e 	lds	r26, 0x0E44
    3eec:	b0 91 45 0e 	lds	r27, 0x0E45
    3ef0:	01 96       	adiw	r24, 0x01	; 1
    3ef2:	a1 1d       	adc	r26, r1
    3ef4:	b1 1d       	adc	r27, r1
    3ef6:	80 93 42 0e 	sts	0x0E42, r24
    3efa:	90 93 43 0e 	sts	0x0E43, r25
    3efe:	a0 93 44 0e 	sts	0x0E44, r26
    3f02:	b0 93 45 0e 	sts	0x0E45, r27
    RELEASE_LOCK();
    3f06:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
    3f0a:	58 c0       	rjmp	.+176    	; 0x3fbc <cc2420_read+0x1aa>
    return 0;
  }

  getrxdata(buf, len - AUX_LEN);
    3f0c:	c8 01       	movw	r24, r16
    3f0e:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <getrxdata>
#if CC2420_CONF_CHECKSUM
  getrxdata(&checksum, CHECKSUM_LEN);
#endif /* CC2420_CONF_CHECKSUM */
  getrxdata(footer, FOOTER_LEN);
    3f12:	ce 01       	movw	r24, r28
    3f14:	01 96       	adiw	r24, 0x01	; 1
    3f16:	62 e0       	ldi	r22, 0x02	; 2
    3f18:	70 e0       	ldi	r23, 0x00	; 0
    3f1a:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <getrxdata>
  }

  if(footer[1] & FOOTER1_CRC_OK &&
     checksum == crc16_data(buf, len - AUX_LEN, 0)) {
#else
  if(footer[1] & FOOTER1_CRC_OK) {
    3f1e:	2a 81       	ldd	r18, Y+2	; 0x02
    3f20:	27 ff       	sbrs	r18, 7
    3f22:	25 c0       	rjmp	.+74     	; 0x3f6e <cc2420_read+0x15c>
#endif /* CC2420_CONF_CHECKSUM */
    cc2420_last_rssi = footer[0];
    3f24:	89 81       	ldd	r24, Y+1	; 0x01
    3f26:	80 93 a7 0e 	sts	0x0EA7, r24
    cc2420_last_correlation = footer[1] & FOOTER1_CORRELATION;
    3f2a:	2f 77       	andi	r18, 0x7F	; 127
    3f2c:	20 93 b2 0e 	sts	0x0EB2, r18


    packetbuf_set_attr(PACKETBUF_ATTR_RSSI, cc2420_last_rssi);
    3f30:	99 27       	eor	r25, r25
    3f32:	87 fd       	sbrc	r24, 7
    3f34:	90 95       	com	r25
    3f36:	90 93 7c 0e 	sts	0x0E7C, r25
    3f3a:	80 93 7b 0e 	sts	0x0E7B, r24
    packetbuf_set_attr(PACKETBUF_ATTR_LINK_QUALITY, cc2420_last_correlation);
    3f3e:	20 93 79 0e 	sts	0x0E79, r18
    3f42:	10 92 7a 0e 	sts	0x0E7A, r1

    RIMESTATS_ADD(llrx);
    3f46:	80 91 5e 0e 	lds	r24, 0x0E5E
    3f4a:	90 91 5f 0e 	lds	r25, 0x0E5F
    3f4e:	a0 91 60 0e 	lds	r26, 0x0E60
    3f52:	b0 91 61 0e 	lds	r27, 0x0E61
    3f56:	01 96       	adiw	r24, 0x01	; 1
    3f58:	a1 1d       	adc	r26, r1
    3f5a:	b1 1d       	adc	r27, r1
    3f5c:	80 93 5e 0e 	sts	0x0E5E, r24
    3f60:	90 93 5f 0e 	sts	0x0E5F, r25
    3f64:	a0 93 60 0e 	sts	0x0E60, r26
    3f68:	b0 93 61 0e 	sts	0x0E61, r27
    3f6c:	15 c0       	rjmp	.+42     	; 0x3f98 <cc2420_read+0x186>

  } else {
    RIMESTATS_ADD(badcrc);
    3f6e:	80 91 4e 0e 	lds	r24, 0x0E4E
    3f72:	90 91 4f 0e 	lds	r25, 0x0E4F
    3f76:	a0 91 50 0e 	lds	r26, 0x0E50
    3f7a:	b0 91 51 0e 	lds	r27, 0x0E51
    3f7e:	01 96       	adiw	r24, 0x01	; 1
    3f80:	a1 1d       	adc	r26, r1
    3f82:	b1 1d       	adc	r27, r1
    3f84:	80 93 4e 0e 	sts	0x0E4E, r24
    3f88:	90 93 4f 0e 	sts	0x0E4F, r25
    3f8c:	a0 93 50 0e 	sts	0x0E50, r26
    3f90:	b0 93 51 0e 	sts	0x0E51, r27
    len = AUX_LEN;
    3f94:	82 e0       	ldi	r24, 0x02	; 2
    3f96:	d8 2e       	mov	r13, r24
  }

  if(CC2420_FIFOP_IS_1) {
    3f98:	0e 9b       	sbis	0x01, 6	; 1
    3f9a:	09 c0       	rjmp	.+18     	; 0x3fae <cc2420_read+0x19c>
    if(!CC2420_FIFO_IS_1) {
    3f9c:	b7 99       	sbic	0x16, 7	; 22
    3f9e:	03 c0       	rjmp	.+6      	; 0x3fa6 <cc2420_read+0x194>
      /* Clean up in case of FIFO overflow!  This happens for every
       * full length frame and is signaled by FIFOP = 1 and FIFO =
       * 0. */
      flushrx();
    3fa0:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <flushrx>
    3fa4:	04 c0       	rjmp	.+8      	; 0x3fae <cc2420_read+0x19c>
    } else {
      /* Another packet has been received and needs attention. */
      process_poll(&cc2420_process);
    3fa6:	8f ec       	ldi	r24, 0xCF	; 207
    3fa8:	95 e0       	ldi	r25, 0x05	; 5
    3faa:	0e 94 90 15 	call	0x2b20	; 0x2b20 <process_poll>
    }
  }

  RELEASE_LOCK();
    3fae:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>

  if(len < AUX_LEN) {
    return 0;
  }

  return len - AUX_LEN;
    3fb2:	2d 2d       	mov	r18, r13
    3fb4:	30 e0       	ldi	r19, 0x00	; 0
    3fb6:	22 50       	subi	r18, 0x02	; 2
    3fb8:	30 40       	sbci	r19, 0x00	; 0
    3fba:	02 c0       	rjmp	.+4      	; 0x3fc0 <cc2420_read+0x1ae>
#if CC2420_CONF_CHECKSUM
  uint16_t checksum;
#endif /* CC2420_CONF_CHECKSUM */

  if(!CC2420_FIFOP_IS_1) {
    return 0;
    3fbc:	20 e0       	ldi	r18, 0x00	; 0
    3fbe:	30 e0       	ldi	r19, 0x00	; 0
  if(len < AUX_LEN) {
    return 0;
  }

  return len - AUX_LEN;
}
    3fc0:	c9 01       	movw	r24, r18
    3fc2:	0f 90       	pop	r0
    3fc4:	0f 90       	pop	r0
    3fc6:	cf 91       	pop	r28
    3fc8:	df 91       	pop	r29
    3fca:	1f 91       	pop	r17
    3fcc:	0f 91       	pop	r16
    3fce:	ff 90       	pop	r15
    3fd0:	ef 90       	pop	r14
    3fd2:	df 90       	pop	r13
    3fd4:	08 95       	ret

00003fd6 <process_thread_cc2420_process>:
  cc2420_packets_seen++;
  return 1;
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(cc2420_process, ev, data)
{
    3fd6:	cf 93       	push	r28
    3fd8:	df 93       	push	r29
    3fda:	ec 01       	movw	r28, r24
  int len;
  PROCESS_BEGIN();
    3fdc:	88 81       	ld	r24, Y
    3fde:	99 81       	ldd	r25, Y+1	; 0x01
    3fe0:	00 97       	sbiw	r24, 0x00	; 0
    3fe2:	29 f0       	breq	.+10     	; 0x3fee <process_thread_cc2420_process+0x18>
    3fe4:	22 e0       	ldi	r18, 0x02	; 2
    3fe6:	8e 37       	cpi	r24, 0x7E	; 126
    3fe8:	92 07       	cpc	r25, r18
    3fea:	01 f5       	brne	.+64     	; 0x402c <process_thread_cc2420_process+0x56>
    3fec:	05 c0       	rjmp	.+10     	; 0x3ff8 <process_thread_cc2420_process+0x22>

  PRINTF("cc2420_process: started\n");

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);
    3fee:	8e e7       	ldi	r24, 0x7E	; 126
    3ff0:	92 e0       	ldi	r25, 0x02	; 2
    3ff2:	99 83       	std	Y+1, r25	; 0x01
    3ff4:	88 83       	st	Y, r24
    3ff6:	1e c0       	rjmp	.+60     	; 0x4034 <process_thread_cc2420_process+0x5e>
    3ff8:	62 38       	cpi	r22, 0x82	; 130
    3ffa:	e1 f4       	brne	.+56     	; 0x4034 <process_thread_cc2420_process+0x5e>
    TIMETABLE_TIMESTAMP(cc2420_timetable, "poll");
#endif /* CC2420_TIMETABLE_PROFILING */
    
    PRINTF("cc2420_process: calling receiver callback\n");

    packetbuf_clear();
    3ffc:	0e 94 b8 1a 	call	0x3570	; 0x3570 <packetbuf_clear>
    packetbuf_set_attr(PACKETBUF_ATTR_TIMESTAMP, last_packet_timestamp);
    4000:	80 91 0b 0e 	lds	r24, 0x0E0B
    4004:	90 91 0c 0e 	lds	r25, 0x0E0C
    4008:	90 93 7e 0e 	sts	0x0E7E, r25
    400c:	80 93 7d 0e 	sts	0x0E7D, r24
    len = cc2420_read(packetbuf_dataptr(), PACKETBUF_SIZE);
    4010:	0e 94 15 1a 	call	0x342a	; 0x342a <packetbuf_dataptr>
    4014:	60 e8       	ldi	r22, 0x80	; 128
    4016:	70 e0       	ldi	r23, 0x00	; 0
    4018:	0e 94 09 1f 	call	0x3e12	; 0x3e12 <cc2420_read>
    
    packetbuf_set_datalen(len);
    401c:	0e 94 10 1a 	call	0x3420	; 0x3420 <packetbuf_set_datalen>
    
    NETSTACK_RDC.input();
    4020:	e0 91 e7 03 	lds	r30, 0x03E7
    4024:	f0 91 e8 03 	lds	r31, 0x03E8
    4028:	09 95       	icall
    TIMETABLE_TIMESTAMP(cc2420_timetable, "end");
    timetable_aggregate_compute_detailed(&aggregate_time,
                                         &cc2420_timetable);
      timetable_clear(&cc2420_timetable);
#endif /* CC2420_TIMETABLE_PROFILING */
  }
    402a:	e1 cf       	rjmp	.-62     	; 0x3fee <process_thread_cc2420_process+0x18>

  PROCESS_END();
    402c:	19 82       	std	Y+1, r1	; 0x01
    402e:	18 82       	st	Y, r1
    4030:	83 e0       	ldi	r24, 0x03	; 3
    4032:	01 c0       	rjmp	.+2      	; 0x4036 <process_thread_cc2420_process+0x60>
  PROCESS_BEGIN();

  PRINTF("cc2420_process: started\n");

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);
    4034:	81 e0       	ldi	r24, 0x01	; 1
      timetable_clear(&cc2420_timetable);
#endif /* CC2420_TIMETABLE_PROFILING */
  }

  PROCESS_END();
}
    4036:	df 91       	pop	r29
    4038:	cf 91       	pop	r28
    403a:	08 95       	ret

0000403c <cc2420_get_channel>:
/*---------------------------------------------------------------------------*/
int
cc2420_get_channel(void)
{
  return channel;
}
    403c:	80 91 0d 0e 	lds	r24, 0x0E0D
    4040:	90 91 0e 0e 	lds	r25, 0x0E0E
    4044:	08 95       	ret

00004046 <cc2420_set_channel>:
/*---------------------------------------------------------------------------*/
int
cc2420_set_channel(int c)
{
    4046:	0f 93       	push	r16
    4048:	1f 93       	push	r17
    404a:	cf 93       	push	r28
    404c:	df 93       	push	r29
  uint16_t f;

  GET_LOCK();
    404e:	20 91 06 0e 	lds	r18, 0x0E06
    4052:	2f 5f       	subi	r18, 0xFF	; 255
    4054:	20 93 06 0e 	sts	0x0E06, r18
  /*
   * Subtract the base channel (11), multiply by 5, which is the
   * channel spacing. 357 is 2405-2048 and 0x4000 is LOCK_THR = 1.
   */
  channel = c;
    4058:	90 93 0e 0e 	sts	0x0E0E, r25
    405c:	80 93 0d 0e 	sts	0x0E0D, r24

  f = 5 * (c - 11) + 357 + 0x4000;
    4060:	ec 01       	movw	r28, r24
    4062:	cc 0f       	add	r28, r28
    4064:	dd 1f       	adc	r29, r29
    4066:	cc 0f       	add	r28, r28
    4068:	dd 1f       	adc	r29, r29
    406a:	c8 0f       	add	r28, r24
    406c:	d9 1f       	adc	r29, r25
    406e:	c2 5d       	subi	r28, 0xD2	; 210
    4070:	de 4b       	sbci	r29, 0xBE	; 190
  /*
   * Writing RAM requires crystal oscillator to be stable.
   */
  BUSYWAIT_UNTIL((status() & (BV(CC2420_XOSC16M_STABLE))), RTIMER_SECOND / 10);
    4072:	00 91 88 00 	lds	r16, 0x0088
    4076:	10 91 89 00 	lds	r17, 0x0089
    407a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    407e:	86 fd       	sbrc	r24, 6
    4080:	0a c0       	rjmp	.+20     	; 0x4096 <cc2420_set_channel+0x50>
    4082:	80 91 88 00 	lds	r24, 0x0088
    4086:	90 91 89 00 	lds	r25, 0x0089
    408a:	80 5d       	subi	r24, 0xD0	; 208
    408c:	92 40       	sbci	r25, 0x02	; 2
    408e:	80 1b       	sub	r24, r16
    4090:	91 0b       	sbc	r25, r17
    4092:	97 fd       	sbrc	r25, 7
    4094:	f2 cf       	rjmp	.-28     	; 0x407a <cc2420_set_channel+0x34>

  /* Wait for any transmission to end. */
  BUSYWAIT_UNTIL(!(status() & BV(CC2420_TX_ACTIVE)), RTIMER_SECOND / 10);
    4096:	00 91 88 00 	lds	r16, 0x0088
    409a:	10 91 89 00 	lds	r17, 0x0089
    409e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    40a2:	83 ff       	sbrs	r24, 3
    40a4:	0a c0       	rjmp	.+20     	; 0x40ba <cc2420_set_channel+0x74>
    40a6:	80 91 88 00 	lds	r24, 0x0088
    40aa:	90 91 89 00 	lds	r25, 0x0089
    40ae:	80 5d       	subi	r24, 0xD0	; 208
    40b0:	92 40       	sbci	r25, 0x02	; 2
    40b2:	80 1b       	sub	r24, r16
    40b4:	91 0b       	sbc	r25, r17
    40b6:	97 fd       	sbrc	r25, 7
    40b8:	f2 cf       	rjmp	.-28     	; 0x409e <cc2420_set_channel+0x58>

  setreg(CC2420_FSCTRL, f);
    40ba:	88 e1       	ldi	r24, 0x18	; 24
    40bc:	90 e0       	ldi	r25, 0x00	; 0
    40be:	be 01       	movw	r22, r28
    40c0:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <setreg>

  /* If we are in receive mode, we issue an SRXON command to ensure
     that the VCO is calibrated. */
  if(receive_on) {
    40c4:	80 91 07 0e 	lds	r24, 0x0E07
    40c8:	88 23       	and	r24, r24
    40ca:	21 f0       	breq	.+8      	; 0x40d4 <cc2420_set_channel+0x8e>
    strobe(CC2420_SRXON);
    40cc:	83 e0       	ldi	r24, 0x03	; 3
    40ce:	90 e0       	ldi	r25, 0x00	; 0
    40d0:	0e 94 4d 1d 	call	0x3a9a	; 0x3a9a <strobe>
  }

  RELEASE_LOCK();
    40d4:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
  return 1;
}
    40d8:	81 e0       	ldi	r24, 0x01	; 1
    40da:	90 e0       	ldi	r25, 0x00	; 0
    40dc:	df 91       	pop	r29
    40de:	cf 91       	pop	r28
    40e0:	1f 91       	pop	r17
    40e2:	0f 91       	pop	r16
    40e4:	08 95       	ret

000040e6 <cc2420_set_pan_addr>:
/*---------------------------------------------------------------------------*/
void
cc2420_set_pan_addr(unsigned pan,
                    unsigned addr,
                    const uint8_t *ieee_addr)
{
    40e6:	cf 92       	push	r12
    40e8:	df 92       	push	r13
    40ea:	ef 92       	push	r14
    40ec:	ff 92       	push	r15
    40ee:	0f 93       	push	r16
    40f0:	1f 93       	push	r17
    40f2:	df 93       	push	r29
    40f4:	cf 93       	push	r28
    40f6:	cd b7       	in	r28, 0x3d	; 61
    40f8:	de b7       	in	r29, 0x3e	; 62
    40fa:	2c 97       	sbiw	r28, 0x0c	; 12
    40fc:	0f b6       	in	r0, 0x3f	; 63
    40fe:	f8 94       	cli
    4100:	de bf       	out	0x3e, r29	; 62
    4102:	0f be       	out	0x3f, r0	; 63
    4104:	cd bf       	out	0x3d, r28	; 61
    4106:	6c 01       	movw	r12, r24
    4108:	8a 01       	movw	r16, r20
  uint16_t f = 0;
  uint8_t tmp[2];

  GET_LOCK();
    410a:	80 91 06 0e 	lds	r24, 0x0E06
    410e:	8f 5f       	subi	r24, 0xFF	; 255
    4110:	80 93 06 0e 	sts	0x0E06, r24
  
  /*
   * Writing RAM requires crystal oscillator to be stable.
   */
  BUSYWAIT_UNTIL(status() & (BV(CC2420_XOSC16M_STABLE)), RTIMER_SECOND / 10);
    4114:	e0 90 88 00 	lds	r14, 0x0088
    4118:	f0 90 89 00 	lds	r15, 0x0089
    411c:	6b 87       	std	Y+11, r22	; 0x0b
    411e:	7c 87       	std	Y+12, r23	; 0x0c
    4120:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    4124:	6b 85       	ldd	r22, Y+11	; 0x0b
    4126:	7c 85       	ldd	r23, Y+12	; 0x0c
    4128:	86 fd       	sbrc	r24, 6
    412a:	0a c0       	rjmp	.+20     	; 0x4140 <cc2420_set_pan_addr+0x5a>
    412c:	20 91 88 00 	lds	r18, 0x0088
    4130:	30 91 89 00 	lds	r19, 0x0089
    4134:	20 5d       	subi	r18, 0xD0	; 208
    4136:	32 40       	sbci	r19, 0x02	; 2
    4138:	2e 19       	sub	r18, r14
    413a:	3f 09       	sbc	r19, r15
    413c:	37 fd       	sbrc	r19, 7
    413e:	ee cf       	rjmp	.-36     	; 0x411c <cc2420_set_pan_addr+0x36>

  tmp[0] = pan & 0xff;
    4140:	c9 82       	std	Y+1, r12	; 0x01
  tmp[1] = pan >> 8;
    4142:	da 82       	std	Y+2, r13	; 0x02
  CC2420_WRITE_RAM(&tmp, CC2420RAM_PANID, 2);
    4144:	c0 98       	cbi	0x18, 0	; 24
    4146:	88 ee       	ldi	r24, 0xE8	; 232
    4148:	8f b9       	out	0x0f, r24	; 15
    414a:	77 9b       	sbis	0x0e, 7	; 14
    414c:	fe cf       	rjmp	.-4      	; 0x414a <cc2420_set_pan_addr+0x64>
    414e:	80 e8       	ldi	r24, 0x80	; 128
    4150:	8f b9       	out	0x0f, r24	; 15
    4152:	77 9b       	sbis	0x0e, 7	; 14
    4154:	fe cf       	rjmp	.-4      	; 0x4152 <cc2420_set_pan_addr+0x6c>
    4156:	fe 01       	movw	r30, r28
    4158:	31 96       	adiw	r30, 0x01	; 1
  RELEASE_LOCK();
  return 1;
}
/*---------------------------------------------------------------------------*/
void
cc2420_set_pan_addr(unsigned pan,
    415a:	ce 01       	movw	r24, r28
    415c:	03 96       	adiw	r24, 0x03	; 3
    415e:	df 01       	movw	r26, r30
   */
  BUSYWAIT_UNTIL(status() & (BV(CC2420_XOSC16M_STABLE)), RTIMER_SECOND / 10);

  tmp[0] = pan & 0xff;
  tmp[1] = pan >> 8;
  CC2420_WRITE_RAM(&tmp, CC2420RAM_PANID, 2);
    4160:	2d 91       	ld	r18, X+
    4162:	2f b9       	out	0x0f, r18	; 15
    4164:	77 9b       	sbis	0x0e, 7	; 14
    4166:	fe cf       	rjmp	.-4      	; 0x4164 <cc2420_set_pan_addr+0x7e>
    4168:	a8 17       	cp	r26, r24
    416a:	b9 07       	cpc	r27, r25
    416c:	c9 f7       	brne	.-14     	; 0x4160 <cc2420_set_pan_addr+0x7a>
    416e:	c0 9a       	sbi	0x18, 0	; 24

  tmp[0] = addr & 0xff;
    4170:	69 83       	std	Y+1, r22	; 0x01
  tmp[1] = addr >> 8;
    4172:	7a 83       	std	Y+2, r23	; 0x02
  CC2420_WRITE_RAM(&tmp, CC2420RAM_SHORTADDR, 2);
    4174:	c0 98       	cbi	0x18, 0	; 24
    4176:	2a ee       	ldi	r18, 0xEA	; 234
    4178:	2f b9       	out	0x0f, r18	; 15
    417a:	77 9b       	sbis	0x0e, 7	; 14
    417c:	fe cf       	rjmp	.-4      	; 0x417a <cc2420_set_pan_addr+0x94>
    417e:	20 e8       	ldi	r18, 0x80	; 128
    4180:	2f b9       	out	0x0f, r18	; 15
    4182:	77 9b       	sbis	0x0e, 7	; 14
    4184:	fe cf       	rjmp	.-4      	; 0x4182 <cc2420_set_pan_addr+0x9c>
    4186:	21 91       	ld	r18, Z+
    4188:	2f b9       	out	0x0f, r18	; 15
    418a:	77 9b       	sbis	0x0e, 7	; 14
    418c:	fe cf       	rjmp	.-4      	; 0x418a <cc2420_set_pan_addr+0xa4>
    418e:	e8 17       	cp	r30, r24
    4190:	f9 07       	cpc	r31, r25
    4192:	c9 f7       	brne	.-14     	; 0x4186 <cc2420_set_pan_addr+0xa0>
    4194:	c0 9a       	sbi	0x18, 0	; 24
  if(ieee_addr != NULL) {
    4196:	01 15       	cp	r16, r1
    4198:	11 05       	cpc	r17, r1
    419a:	f1 f0       	breq	.+60     	; 0x41d8 <cc2420_set_pan_addr+0xf2>
    419c:	d8 01       	movw	r26, r16
    419e:	ce 01       	movw	r24, r28
    41a0:	03 96       	adiw	r24, 0x03	; 3
    41a2:	fe 01       	movw	r30, r28
    41a4:	3b 96       	adiw	r30, 0x0b	; 11
    uint8_t tmp_addr[8];
    /* LSB first, MSB last for 802.15.4 addresses in CC2420 */
    for (f = 0; f < 8; f++) {
      tmp_addr[7 - f] = ieee_addr[f];
    41a6:	2d 91       	ld	r18, X+
    41a8:	22 93       	st	-Z, r18
  tmp[1] = addr >> 8;
  CC2420_WRITE_RAM(&tmp, CC2420RAM_SHORTADDR, 2);
  if(ieee_addr != NULL) {
    uint8_t tmp_addr[8];
    /* LSB first, MSB last for 802.15.4 addresses in CC2420 */
    for (f = 0; f < 8; f++) {
    41aa:	e8 17       	cp	r30, r24
    41ac:	f9 07       	cpc	r31, r25
    41ae:	d9 f7       	brne	.-10     	; 0x41a6 <cc2420_set_pan_addr+0xc0>
      tmp_addr[7 - f] = ieee_addr[f];
    }
    CC2420_WRITE_RAM(tmp_addr, CC2420RAM_IEEEADDR, 8);
    41b0:	c0 98       	cbi	0x18, 0	; 24
    41b2:	20 ee       	ldi	r18, 0xE0	; 224
    41b4:	2f b9       	out	0x0f, r18	; 15
    41b6:	77 9b       	sbis	0x0e, 7	; 14
    41b8:	fe cf       	rjmp	.-4      	; 0x41b6 <cc2420_set_pan_addr+0xd0>
    41ba:	20 e8       	ldi	r18, 0x80	; 128
    41bc:	2f b9       	out	0x0f, r18	; 15
    41be:	77 9b       	sbis	0x0e, 7	; 14
    41c0:	fe cf       	rjmp	.-4      	; 0x41be <cc2420_set_pan_addr+0xd8>
    41c2:	fe 01       	movw	r30, r28
    41c4:	33 96       	adiw	r30, 0x03	; 3
  RELEASE_LOCK();
  return 1;
}
/*---------------------------------------------------------------------------*/
void
cc2420_set_pan_addr(unsigned pan,
    41c6:	08 96       	adiw	r24, 0x08	; 8
    uint8_t tmp_addr[8];
    /* LSB first, MSB last for 802.15.4 addresses in CC2420 */
    for (f = 0; f < 8; f++) {
      tmp_addr[7 - f] = ieee_addr[f];
    }
    CC2420_WRITE_RAM(tmp_addr, CC2420RAM_IEEEADDR, 8);
    41c8:	21 91       	ld	r18, Z+
    41ca:	2f b9       	out	0x0f, r18	; 15
    41cc:	77 9b       	sbis	0x0e, 7	; 14
    41ce:	fe cf       	rjmp	.-4      	; 0x41cc <cc2420_set_pan_addr+0xe6>
    41d0:	e8 17       	cp	r30, r24
    41d2:	f9 07       	cpc	r31, r25
    41d4:	c9 f7       	brne	.-14     	; 0x41c8 <cc2420_set_pan_addr+0xe2>
    41d6:	c0 9a       	sbi	0x18, 0	; 24
  }
  RELEASE_LOCK();
    41d8:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
}
    41dc:	2c 96       	adiw	r28, 0x0c	; 12
    41de:	0f b6       	in	r0, 0x3f	; 63
    41e0:	f8 94       	cli
    41e2:	de bf       	out	0x3e, r29	; 62
    41e4:	0f be       	out	0x3f, r0	; 63
    41e6:	cd bf       	out	0x3d, r28	; 61
    41e8:	cf 91       	pop	r28
    41ea:	df 91       	pop	r29
    41ec:	1f 91       	pop	r17
    41ee:	0f 91       	pop	r16
    41f0:	ff 90       	pop	r15
    41f2:	ef 90       	pop	r14
    41f4:	df 90       	pop	r13
    41f6:	cf 90       	pop	r12
    41f8:	08 95       	ret

000041fa <cc2420_init>:
#define FIFOP_THR(n) ((n) & 0x7f)
#define RXBPF_LOCUR (1 << 13);
/*---------------------------------------------------------------------------*/
int
cc2420_init(void)
{
    41fa:	1f 93       	push	r17

void   *sbrk(int);

typedef unsigned char spl_t;
static inline void splx(spl_t s) { SREG = s; }
static inline spl_t splhigh(void) { spl_t s = SREG; cli(); return s; }
    41fc:	1f b7       	in	r17, 0x3f	; 63
    41fe:	f8 94       	cli
  uint16_t reg;
  {
    int s = splhigh();
    cc2420_arch_init();		/* Initalize ports and SPI. */
    4200:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <cc2420_arch_init>
    CC2420_DISABLE_FIFOP_INT();
    4204:	89 b7       	in	r24, 0x39	; 57
    4206:	8f 7b       	andi	r24, 0xBF	; 191
    4208:	89 bf       	out	0x39, r24	; 57
    CC2420_FIFOP_INT_INIT();
    420a:	8a b7       	in	r24, 0x3a	; 58
    420c:	80 63       	ori	r24, 0x30	; 48
    420e:	8a bf       	out	0x3a, r24	; 58
    4210:	80 e4       	ldi	r24, 0x40	; 64
    4212:	88 bf       	out	0x38, r24	; 56
void cpu_init(void);

void   *sbrk(int);

typedef unsigned char spl_t;
static inline void splx(spl_t s) { SREG = s; }
    4214:	1f bf       	out	0x3f, r17	; 63
    splx(s);
  }

  /* Turn on voltage regulator and reset. */
  SET_VREG_ACTIVE();
    4216:	dd 9a       	sbi	0x1b, 5	; 27
  clock_delay(250);
    4218:	8a ef       	ldi	r24, 0xFA	; 250
    421a:	90 e0       	ldi	r25, 0x00	; 0
    421c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clock_delay>
  SET_RESET_ACTIVE();
    4220:	de 98       	cbi	0x1b, 6	; 27
  clock_delay(127);
    4222:	8f e7       	ldi	r24, 0x7F	; 127
    4224:	90 e0       	ldi	r25, 0x00	; 0
    4226:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clock_delay>
  SET_RESET_INACTIVE();
    422a:	de 9a       	sbi	0x1b, 6	; 27
  clock_delay(125);
    422c:	8d e7       	ldi	r24, 0x7D	; 125
    422e:	90 e0       	ldi	r25, 0x00	; 0
    4230:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clock_delay>


  /* Turn on the crystal oscillator. */
  strobe(CC2420_SXOSCON);
    4234:	81 e0       	ldi	r24, 0x01	; 1
    4236:	90 e0       	ldi	r25, 0x00	; 0
    4238:	0e 94 4d 1d 	call	0x3a9a	; 0x3a9a <strobe>

  /* Turn on/off automatic packet acknowledgment and address decoding. */
  reg = getreg(CC2420_MDMCTRL0);
    423c:	81 e1       	ldi	r24, 0x11	; 17
    423e:	90 e0       	ldi	r25, 0x00	; 0
    4240:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <getreg>

#if CC2420_CONF_AUTOACK
  reg |= AUTOACK | ADR_DECODE;
    4244:	bc 01       	movw	r22, r24
    4246:	60 61       	ori	r22, 0x10	; 16
    4248:	78 60       	ori	r23, 0x08	; 8
#else
  reg &= ~(AUTOACK | ADR_DECODE);
#endif /* CC2420_CONF_AUTOACK */
  setreg(CC2420_MDMCTRL0, reg);
    424a:	81 e1       	ldi	r24, 0x11	; 17
    424c:	90 e0       	ldi	r25, 0x00	; 0
    424e:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <setreg>
  setreg(CC2420_TXCTRL, reg);*/

  
  /* Change default values as recomended in the data sheet, */
  /* correlation threshold = 20, RX bandpass filter = 1.3uA. */
  setreg(CC2420_MDMCTRL1, CORR_THR(20));
    4252:	82 e1       	ldi	r24, 0x12	; 18
    4254:	90 e0       	ldi	r25, 0x00	; 0
    4256:	60 e0       	ldi	r22, 0x00	; 0
    4258:	75 e0       	ldi	r23, 0x05	; 5
    425a:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <setreg>
  reg = getreg(CC2420_RXCTRL1);
    425e:	87 e1       	ldi	r24, 0x17	; 23
    4260:	90 e0       	ldi	r25, 0x00	; 0
    4262:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <getreg>
  reg |= RXBPF_LOCUR;
    4266:	bc 01       	movw	r22, r24
    4268:	70 62       	ori	r23, 0x20	; 32
  setreg(CC2420_RXCTRL1, reg);
    426a:	87 e1       	ldi	r24, 0x17	; 23
    426c:	90 e0       	ldi	r25, 0x00	; 0
    426e:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <setreg>

  /* Set the FIFOP threshold to maximum. */
  setreg(CC2420_IOCFG0, FIFOP_THR(127));
    4272:	8c e1       	ldi	r24, 0x1C	; 28
    4274:	90 e0       	ldi	r25, 0x00	; 0
    4276:	6f e7       	ldi	r22, 0x7F	; 127
    4278:	70 e0       	ldi	r23, 0x00	; 0
    427a:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <setreg>

  /* Turn off "Security enable" (page 32). */
  reg = getreg(CC2420_SECCTRL0);
    427e:	89 e1       	ldi	r24, 0x19	; 25
    4280:	90 e0       	ldi	r25, 0x00	; 0
    4282:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <getreg>
  reg &= ~RXFIFO_PROTECTION;
    4286:	bc 01       	movw	r22, r24
    4288:	7d 7f       	andi	r23, 0xFD	; 253
  setreg(CC2420_SECCTRL0, reg);
    428a:	89 e1       	ldi	r24, 0x19	; 25
    428c:	90 e0       	ldi	r25, 0x00	; 0
    428e:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <setreg>

  cc2420_set_pan_addr(0xffff, 0x0000, NULL);
    4292:	8f ef       	ldi	r24, 0xFF	; 255
    4294:	9f ef       	ldi	r25, 0xFF	; 255
    4296:	60 e0       	ldi	r22, 0x00	; 0
    4298:	70 e0       	ldi	r23, 0x00	; 0
    429a:	40 e0       	ldi	r20, 0x00	; 0
    429c:	50 e0       	ldi	r21, 0x00	; 0
    429e:	0e 94 73 20 	call	0x40e6	; 0x40e6 <cc2420_set_pan_addr>
  cc2420_set_channel(26);
    42a2:	8a e1       	ldi	r24, 0x1A	; 26
    42a4:	90 e0       	ldi	r25, 0x00	; 0
    42a6:	0e 94 23 20 	call	0x4046	; 0x4046 <cc2420_set_channel>

  flushrx();
    42aa:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <flushrx>

  process_start(&cc2420_process, NULL);
    42ae:	8f ec       	ldi	r24, 0xCF	; 207
    42b0:	95 e0       	ldi	r25, 0x05	; 5
    42b2:	60 e0       	ldi	r22, 0x00	; 0
    42b4:	70 e0       	ldi	r23, 0x00	; 0
    42b6:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <process_start>
  return 1;
}
    42ba:	81 e0       	ldi	r24, 0x01	; 1
    42bc:	90 e0       	ldi	r25, 0x00	; 0
    42be:	1f 91       	pop	r17
    42c0:	08 95       	ret

000042c2 <cc2420_interrupt>:
TIMETABLE_AGGREGATE(aggregate_time, 10);
#endif /* CC2420_TIMETABLE_PROFILING */
int
cc2420_interrupt(void)
{
  CC2420_CLEAR_FIFOP_INT();
    42c2:	80 e4       	ldi	r24, 0x40	; 64
    42c4:	88 bf       	out	0x38, r24	; 56
  process_poll(&cc2420_process);
    42c6:	8f ec       	ldi	r24, 0xCF	; 207
    42c8:	95 e0       	ldi	r25, 0x05	; 5
    42ca:	0e 94 90 15 	call	0x2b20	; 0x2b20 <process_poll>
#if CC2420_TIMETABLE_PROFILING
  timetable_clear(&cc2420_timetable);
  TIMETABLE_TIMESTAMP(cc2420_timetable, "interrupt");
#endif /* CC2420_TIMETABLE_PROFILING */

  last_packet_timestamp = cc2420_sfd_start_time;
    42ce:	80 91 ac 0e 	lds	r24, 0x0EAC
    42d2:	90 91 ad 0e 	lds	r25, 0x0EAD
    42d6:	90 93 0c 0e 	sts	0x0E0C, r25
    42da:	80 93 0b 0e 	sts	0x0E0B, r24
  pending++;
    42de:	80 91 0a 0e 	lds	r24, 0x0E0A
    42e2:	8f 5f       	subi	r24, 0xFF	; 255
    42e4:	80 93 0a 0e 	sts	0x0E0A, r24
  cc2420_packets_seen++;
    42e8:	80 91 aa 0e 	lds	r24, 0x0EAA
    42ec:	90 91 ab 0e 	lds	r25, 0x0EAB
    42f0:	01 96       	adiw	r24, 0x01	; 1
    42f2:	90 93 ab 0e 	sts	0x0EAB, r25
    42f6:	80 93 aa 0e 	sts	0x0EAA, r24
  return 1;
}
    42fa:	81 e0       	ldi	r24, 0x01	; 1
    42fc:	90 e0       	ldi	r25, 0x00	; 0
    42fe:	08 95       	ret

00004300 <cc2420_set_txpower>:
}
/*---------------------------------------------------------------------------*/
void
cc2420_set_txpower(uint8_t power)
{
  GET_LOCK();
    4300:	90 91 06 0e 	lds	r25, 0x0E06
    4304:	9f 5f       	subi	r25, 0xFF	; 255
    4306:	90 93 06 0e 	sts	0x0E06, r25
  set_txpower(power);
    430a:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <set_txpower>
  RELEASE_LOCK();
    430e:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
}
    4312:	08 95       	ret

00004314 <cc2420_get_txpower>:
/*---------------------------------------------------------------------------*/
int
cc2420_get_txpower(void)
{
    4314:	ef 92       	push	r14
    4316:	ff 92       	push	r15
    4318:	cf 93       	push	r28
    431a:	df 93       	push	r29
  int power;
  GET_LOCK();
    431c:	80 91 06 0e 	lds	r24, 0x0E06
    4320:	8f 5f       	subi	r24, 0xFF	; 255
    4322:	80 93 06 0e 	sts	0x0E06, r24
  power = (int)(getreg(CC2420_TXCTRL) & 0x001f);
    4326:	85 e1       	ldi	r24, 0x15	; 21
    4328:	90 e0       	ldi	r25, 0x00	; 0
    432a:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <getreg>
    432e:	ec 01       	movw	r28, r24
  RELEASE_LOCK();
    4330:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
int
cc2420_get_txpower(void)
{
  int power;
  GET_LOCK();
  power = (int)(getreg(CC2420_TXCTRL) & 0x001f);
    4334:	cf 71       	andi	r28, 0x1F	; 31
    4336:	d0 70       	andi	r29, 0x00	; 0
  RELEASE_LOCK();
  return power;
}
    4338:	ce 01       	movw	r24, r28
    433a:	df 91       	pop	r29
    433c:	cf 91       	pop	r28
    433e:	ff 90       	pop	r15
    4340:	ef 90       	pop	r14
    4342:	08 95       	ret

00004344 <cc2420_transmit>:
  return 1;
}
/*---------------------------------------------------------------------------*/
static int
cc2420_transmit(unsigned short payload_len)
{
    4344:	cf 92       	push	r12
    4346:	df 92       	push	r13
    4348:	ef 92       	push	r14
    434a:	ff 92       	push	r15
    434c:	0f 93       	push	r16
    434e:	1f 93       	push	r17
    4350:	df 93       	push	r29
    4352:	cf 93       	push	r28
    4354:	00 d0       	rcall	.+0      	; 0x4356 <cc2420_transmit+0x12>
    4356:	cd b7       	in	r28, 0x3d	; 61
    4358:	de b7       	in	r29, 0x3e	; 62
    435a:	7c 01       	movw	r14, r24
  uint8_t total_len;
#if CC2420_CONF_CHECKSUM
  uint16_t checksum;
#endif /* CC2420_CONF_CHECKSUM */

  GET_LOCK();
    435c:	80 91 06 0e 	lds	r24, 0x0E06
    4360:	8f 5f       	subi	r24, 0xFF	; 255
    4362:	80 93 06 0e 	sts	0x0E06, r24

  txpower = 0;
  if(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) > 0) {
    4366:	80 91 7f 0e 	lds	r24, 0x0E7F
    436a:	90 91 80 0e 	lds	r25, 0x0E80
    436e:	00 97       	sbiw	r24, 0x00	; 0
    4370:	49 f0       	breq	.+18     	; 0x4384 <cc2420_transmit+0x40>
    /* Remember the current transmission power */
    txpower = cc2420_get_txpower();
    4372:	0e 94 8a 21 	call	0x4314	; 0x4314 <cc2420_get_txpower>
    4376:	8c 01       	movw	r16, r24
    /* Set the specified transmission power */
    set_txpower(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) - 1);
    4378:	80 91 7f 0e 	lds	r24, 0x0E7F
    437c:	81 50       	subi	r24, 0x01	; 1
    437e:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <set_txpower>
    4382:	02 c0       	rjmp	.+4      	; 0x4388 <cc2420_transmit+0x44>
  uint16_t checksum;
#endif /* CC2420_CONF_CHECKSUM */

  GET_LOCK();

  txpower = 0;
    4384:	00 e0       	ldi	r16, 0x00	; 0
    4386:	10 e0       	ldi	r17, 0x00	; 0
#else
#define LOOP_20_SYMBOLS CC2420_CONF_SYMBOL_LOOP_COUNT
#endif

#if WITH_SEND_CCA
  strobe(CC2420_SRXON);
    4388:	83 e0       	ldi	r24, 0x03	; 3
    438a:	90 e0       	ldi	r25, 0x00	; 0
    438c:	0e 94 4d 1d 	call	0x3a9a	; 0x3a9a <strobe>
  BUSYWAIT_UNTIL(status() & BV(CC2420_RSSI_VALID), RTIMER_SECOND / 10);
    4390:	c0 90 88 00 	lds	r12, 0x0088
    4394:	d0 90 89 00 	lds	r13, 0x0089
    4398:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    439c:	81 fd       	sbrc	r24, 1
    439e:	0a c0       	rjmp	.+20     	; 0x43b4 <cc2420_transmit+0x70>
    43a0:	80 91 88 00 	lds	r24, 0x0088
    43a4:	90 91 89 00 	lds	r25, 0x0089
    43a8:	80 5d       	subi	r24, 0xD0	; 208
    43aa:	92 40       	sbci	r25, 0x02	; 2
    43ac:	8c 19       	sub	r24, r12
    43ae:	9d 09       	sbc	r25, r13
    43b0:	97 fd       	sbrc	r25, 7
    43b2:	f2 cf       	rjmp	.-28     	; 0x4398 <cc2420_transmit+0x54>
  strobe(CC2420_STXONCCA);
    43b4:	85 e0       	ldi	r24, 0x05	; 5
    43b6:	90 e0       	ldi	r25, 0x00	; 0
    43b8:	0e 94 4d 1d 	call	0x3a9a	; 0x3a9a <strobe>
    43bc:	84 ef       	ldi	r24, 0xF4	; 244
    43be:	91 e0       	ldi	r25, 0x01	; 1
#else /* WITH_SEND_CCA */
  strobe(CC2420_STXON);
#endif /* WITH_SEND_CCA */
  for(i = LOOP_20_SYMBOLS; i > 0; i--) {
    if(CC2420_SFD_IS_1) {
    43c0:	84 9b       	sbis	0x10, 4	; 16
    43c2:	54 c0       	rjmp	.+168    	; 0x446c <cc2420_transmit+0x128>
      {
        rtimer_clock_t sfd_timestamp;
        sfd_timestamp = cc2420_sfd_start_time;
    43c4:	80 91 ac 0e 	lds	r24, 0x0EAC
    43c8:	90 91 ad 0e 	lds	r25, 0x0EAD
    43cc:	9a 83       	std	Y+2, r25	; 0x02
    43ce:	89 83       	std	Y+1, r24	; 0x01
        if(packetbuf_attr(PACKETBUF_ATTR_PACKET_TYPE) ==
    43d0:	80 91 8f 0e 	lds	r24, 0x0E8F
    43d4:	90 91 90 0e 	lds	r25, 0x0E90
    43d8:	84 30       	cpi	r24, 0x04	; 4
    43da:	91 05       	cpc	r25, r1
    43dc:	e9 f4       	brne	.+58     	; 0x4418 <cc2420_transmit+0xd4>
           PACKETBUF_ATTR_PACKET_TYPE_TIMESTAMP) {
          /* Write timestamp to last two bytes of packet in TXFIFO. */
          CC2420_WRITE_RAM(&sfd_timestamp, CC2420RAM_TXFIFO + payload_len - 1, 2);
    43de:	c0 98       	cbi	0x18, 0	; 24
    43e0:	8e 2d       	mov	r24, r14
    43e2:	81 50       	subi	r24, 0x01	; 1
    43e4:	80 68       	ori	r24, 0x80	; 128
    43e6:	8f b9       	out	0x0f, r24	; 15
    43e8:	77 9b       	sbis	0x0e, 7	; 14
    43ea:	fe cf       	rjmp	.-4      	; 0x43e8 <cc2420_transmit+0xa4>
    43ec:	08 94       	sec
    43ee:	e1 08       	sbc	r14, r1
    43f0:	f1 08       	sbc	r15, r1
    43f2:	f6 94       	lsr	r15
    43f4:	e7 94       	ror	r14
    43f6:	80 ec       	ldi	r24, 0xC0	; 192
    43f8:	e8 22       	and	r14, r24
    43fa:	ef b8       	out	0x0f, r14	; 15
    43fc:	77 9b       	sbis	0x0e, 7	; 14
    43fe:	fe cf       	rjmp	.-4      	; 0x43fc <cc2420_transmit+0xb8>
    4400:	fe 01       	movw	r30, r28
    4402:	31 96       	adiw	r30, 0x01	; 1
  process_start(&cc2420_process, NULL);
  return 1;
}
/*---------------------------------------------------------------------------*/
static int
cc2420_transmit(unsigned short payload_len)
    4404:	ce 01       	movw	r24, r28
    4406:	03 96       	adiw	r24, 0x03	; 3
        rtimer_clock_t sfd_timestamp;
        sfd_timestamp = cc2420_sfd_start_time;
        if(packetbuf_attr(PACKETBUF_ATTR_PACKET_TYPE) ==
           PACKETBUF_ATTR_PACKET_TYPE_TIMESTAMP) {
          /* Write timestamp to last two bytes of packet in TXFIFO. */
          CC2420_WRITE_RAM(&sfd_timestamp, CC2420RAM_TXFIFO + payload_len - 1, 2);
    4408:	21 91       	ld	r18, Z+
    440a:	2f b9       	out	0x0f, r18	; 15
    440c:	77 9b       	sbis	0x0e, 7	; 14
    440e:	fe cf       	rjmp	.-4      	; 0x440c <cc2420_transmit+0xc8>
    4410:	e8 17       	cp	r30, r24
    4412:	f9 07       	cpc	r31, r25
    4414:	c9 f7       	brne	.-14     	; 0x4408 <cc2420_transmit+0xc4>
    4416:	c0 9a       	sbi	0x18, 0	; 24
        }
      }

      if(!(status() & BV(CC2420_TX_ACTIVE))) {
    4418:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    441c:	83 ff       	sbrs	r24, 3
    441e:	45 c0       	rjmp	.+138    	; 0x44aa <cc2420_transmit+0x166>
	ENERGEST_OFF(ENERGEST_TYPE_LISTEN);
      }
      ENERGEST_ON(ENERGEST_TYPE_TRANSMIT);
      /* We wait until transmission has ended so that we get an
	 accurate measurement of the transmission time.*/
      BUSYWAIT_UNTIL(!(status() & BV(CC2420_TX_ACTIVE)), RTIMER_SECOND / 10);
    4420:	e0 90 88 00 	lds	r14, 0x0088
    4424:	f0 90 89 00 	lds	r15, 0x0089
    4428:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    442c:	83 ff       	sbrs	r24, 3
    442e:	0a c0       	rjmp	.+20     	; 0x4444 <cc2420_transmit+0x100>
    4430:	80 91 88 00 	lds	r24, 0x0088
    4434:	90 91 89 00 	lds	r25, 0x0089
    4438:	80 5d       	subi	r24, 0xD0	; 208
    443a:	92 40       	sbci	r25, 0x02	; 2
    443c:	8e 19       	sub	r24, r14
    443e:	9f 09       	sbc	r25, r15
    4440:	97 fd       	sbrc	r25, 7
    4442:	f2 cf       	rjmp	.-28     	; 0x4428 <cc2420_transmit+0xe4>

#ifdef ENERGEST_CONF_LEVELDEVICE_LEVELS
      ENERGEST_OFF_LEVEL(ENERGEST_TYPE_TRANSMIT,cc2420_get_txpower());
#endif
      ENERGEST_OFF(ENERGEST_TYPE_TRANSMIT);
      if(receive_on) {
    4444:	80 91 07 0e 	lds	r24, 0x0E07
    4448:	88 23       	and	r24, r24
    444a:	11 f4       	brne	.+4      	; 0x4450 <cc2420_transmit+0x10c>
	ENERGEST_ON(ENERGEST_TYPE_LISTEN);
      } else {
	/* We need to explicitly turn off the radio,
	 * since STXON[CCA] -> TX_ACTIVE -> RX_ACTIVE */
	off();
    444c:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <off>
      }

      if(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) > 0) {
    4450:	80 91 7f 0e 	lds	r24, 0x0E7F
    4454:	90 91 80 0e 	lds	r25, 0x0E80
    4458:	00 97       	sbiw	r24, 0x00	; 0
    445a:	19 f0       	breq	.+6      	; 0x4462 <cc2420_transmit+0x11e>
        /* Restore the transmission power */
        set_txpower(txpower & 0xff);
    445c:	80 2f       	mov	r24, r16
    445e:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <set_txpower>
      }

      RELEASE_LOCK();
    4462:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
      return RADIO_TX_OK;
    4466:	20 e0       	ldi	r18, 0x00	; 0
    4468:	30 e0       	ldi	r19, 0x00	; 0
    446a:	23 c0       	rjmp	.+70     	; 0x44b2 <cc2420_transmit+0x16e>
    446c:	01 97       	sbiw	r24, 0x01	; 1
  BUSYWAIT_UNTIL(status() & BV(CC2420_RSSI_VALID), RTIMER_SECOND / 10);
  strobe(CC2420_STXONCCA);
#else /* WITH_SEND_CCA */
  strobe(CC2420_STXON);
#endif /* WITH_SEND_CCA */
  for(i = LOOP_20_SYMBOLS; i > 0; i--) {
    446e:	09 f0       	breq	.+2      	; 0x4472 <cc2420_transmit+0x12e>
    4470:	a7 cf       	rjmp	.-178    	; 0x43c0 <cc2420_transmit+0x7c>
    }
  }

  /* If we are using WITH_SEND_CCA, we get here if the packet wasn't
     transmitted because of other channel activity. */
  RIMESTATS_ADD(contentiondrop);
    4472:	80 91 52 0e 	lds	r24, 0x0E52
    4476:	90 91 53 0e 	lds	r25, 0x0E53
    447a:	a0 91 54 0e 	lds	r26, 0x0E54
    447e:	b0 91 55 0e 	lds	r27, 0x0E55
    4482:	01 96       	adiw	r24, 0x01	; 1
    4484:	a1 1d       	adc	r26, r1
    4486:	b1 1d       	adc	r27, r1
    4488:	80 93 52 0e 	sts	0x0E52, r24
    448c:	90 93 53 0e 	sts	0x0E53, r25
    4490:	a0 93 54 0e 	sts	0x0E54, r26
    4494:	b0 93 55 0e 	sts	0x0E55, r27
  PRINTF("cc2420: do_send() transmission never started\n");

  if(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) > 0) {
    4498:	80 91 7f 0e 	lds	r24, 0x0E7F
    449c:	90 91 80 0e 	lds	r25, 0x0E80
    44a0:	00 97       	sbiw	r24, 0x00	; 0
    44a2:	19 f0       	breq	.+6      	; 0x44aa <cc2420_transmit+0x166>
    /* Restore the transmission power */
    set_txpower(txpower & 0xff);
    44a4:	80 2f       	mov	r24, r16
    44a6:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <set_txpower>
  }

  RELEASE_LOCK();
    44aa:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
  return RADIO_TX_COLLISION;
    44ae:	22 e0       	ldi	r18, 0x02	; 2
    44b0:	30 e0       	ldi	r19, 0x00	; 0
}
    44b2:	c9 01       	movw	r24, r18
    44b4:	0f 90       	pop	r0
    44b6:	0f 90       	pop	r0
    44b8:	cf 91       	pop	r28
    44ba:	df 91       	pop	r29
    44bc:	1f 91       	pop	r17
    44be:	0f 91       	pop	r16
    44c0:	ff 90       	pop	r15
    44c2:	ef 90       	pop	r14
    44c4:	df 90       	pop	r13
    44c6:	cf 90       	pop	r12
    44c8:	08 95       	ret

000044ca <cc2420_send>:
  return 0;
}
/*---------------------------------------------------------------------------*/
static int
cc2420_send(const void *payload, unsigned short payload_len)
{
    44ca:	cf 93       	push	r28
    44cc:	df 93       	push	r29
    44ce:	eb 01       	movw	r28, r22
  cc2420_prepare(payload, payload_len);
    44d0:	0e 94 1f 1e 	call	0x3c3e	; 0x3c3e <cc2420_prepare>
  return cc2420_transmit(payload_len);
    44d4:	ce 01       	movw	r24, r28
    44d6:	0e 94 a2 21 	call	0x4344	; 0x4344 <cc2420_transmit>
}
    44da:	df 91       	pop	r29
    44dc:	cf 91       	pop	r28
    44de:	08 95       	ret

000044e0 <cc2420_rssi>:
  return power;
}
/*---------------------------------------------------------------------------*/
int
cc2420_rssi(void)
{
    44e0:	ef 92       	push	r14
    44e2:	ff 92       	push	r15
    44e4:	0f 93       	push	r16
    44e6:	1f 93       	push	r17
    44e8:	cf 93       	push	r28
    44ea:	df 93       	push	r29
  int rssi;
  int radio_was_off = 0;

  if(locked) {
    44ec:	80 91 06 0e 	lds	r24, 0x0E06
    44f0:	88 23       	and	r24, r24
    44f2:	81 f5       	brne	.+96     	; 0x4554 <cc2420_rssi+0x74>
    return 0;
  }
  
  GET_LOCK();
    44f4:	81 e0       	ldi	r24, 0x01	; 1
    44f6:	80 93 06 0e 	sts	0x0E06, r24

  if(!receive_on) {
    44fa:	80 91 07 0e 	lds	r24, 0x0E07
    44fe:	88 23       	and	r24, r24
    4500:	29 f4       	brne	.+10     	; 0x450c <cc2420_rssi+0x2c>
    radio_was_off = 1;
    cc2420_on();
    4502:	0e 94 6a 1e 	call	0x3cd4	; 0x3cd4 <cc2420_on>
  }
  
  GET_LOCK();

  if(!receive_on) {
    radio_was_off = 1;
    4506:	01 e0       	ldi	r16, 0x01	; 1
    4508:	10 e0       	ldi	r17, 0x00	; 0
    450a:	02 c0       	rjmp	.+4      	; 0x4510 <cc2420_rssi+0x30>
/*---------------------------------------------------------------------------*/
int
cc2420_rssi(void)
{
  int rssi;
  int radio_was_off = 0;
    450c:	00 e0       	ldi	r16, 0x00	; 0
    450e:	10 e0       	ldi	r17, 0x00	; 0

  if(!receive_on) {
    radio_was_off = 1;
    cc2420_on();
  }
  BUSYWAIT_UNTIL(status() & BV(CC2420_RSSI_VALID), RTIMER_SECOND / 100);
    4510:	c0 91 88 00 	lds	r28, 0x0088
    4514:	d0 91 89 00 	lds	r29, 0x0089
    4518:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    451c:	81 fd       	sbrc	r24, 1
    451e:	0a c0       	rjmp	.+20     	; 0x4534 <cc2420_rssi+0x54>
    4520:	80 91 88 00 	lds	r24, 0x0088
    4524:	90 91 89 00 	lds	r25, 0x0089
    4528:	88 54       	subi	r24, 0x48	; 72
    452a:	90 40       	sbci	r25, 0x00	; 0
    452c:	8c 1b       	sub	r24, r28
    452e:	9d 0b       	sbc	r25, r29
    4530:	97 fd       	sbrc	r25, 7
    4532:	f2 cf       	rjmp	.-28     	; 0x4518 <cc2420_rssi+0x38>

  rssi = (int)((signed char)getreg(CC2420_RSSI));
    4534:	83 e1       	ldi	r24, 0x13	; 19
    4536:	90 e0       	ldi	r25, 0x00	; 0
    4538:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <getreg>
    453c:	c8 2f       	mov	r28, r24
    453e:	dd 27       	eor	r29, r29
    4540:	c7 fd       	sbrc	r28, 7
    4542:	d0 95       	com	r29

  if(radio_was_off) {
    4544:	01 15       	cp	r16, r1
    4546:	11 05       	cpc	r17, r1
    4548:	11 f0       	breq	.+4      	; 0x454e <cc2420_rssi+0x6e>
    cc2420_off();
    454a:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <cc2420_off>
  }
  RELEASE_LOCK();
    454e:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
  return rssi;
    4552:	02 c0       	rjmp	.+4      	; 0x4558 <cc2420_rssi+0x78>
{
  int rssi;
  int radio_was_off = 0;

  if(locked) {
    return 0;
    4554:	c0 e0       	ldi	r28, 0x00	; 0
    4556:	d0 e0       	ldi	r29, 0x00	; 0
  if(radio_was_off) {
    cc2420_off();
  }
  RELEASE_LOCK();
  return rssi;
}
    4558:	ce 01       	movw	r24, r28
    455a:	df 91       	pop	r29
    455c:	cf 91       	pop	r28
    455e:	1f 91       	pop	r17
    4560:	0f 91       	pop	r16
    4562:	ff 90       	pop	r15
    4564:	ef 90       	pop	r14
    4566:	08 95       	ret

00004568 <cc2420_cca_valid>:
}
*/
/*---------------------------------------------------------------------------*/
int
cc2420_cca_valid(void)
{
    4568:	ef 92       	push	r14
    456a:	ff 92       	push	r15
    456c:	cf 93       	push	r28
    456e:	df 93       	push	r29
  int valid;
  if(locked) {
    4570:	80 91 06 0e 	lds	r24, 0x0E06
    4574:	88 23       	and	r24, r24
    4576:	71 f4       	brne	.+28     	; 0x4594 <cc2420_cca_valid+0x2c>
    return 1;
  }
  GET_LOCK();
    4578:	81 e0       	ldi	r24, 0x01	; 1
    457a:	80 93 06 0e 	sts	0x0E06, r24
  valid = !!(status() & BV(CC2420_RSSI_VALID));
    457e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <status>
    4582:	c1 e0       	ldi	r28, 0x01	; 1
    4584:	d0 e0       	ldi	r29, 0x00	; 0
    4586:	81 fd       	sbrc	r24, 1
    4588:	02 c0       	rjmp	.+4      	; 0x458e <cc2420_cca_valid+0x26>
    458a:	c0 e0       	ldi	r28, 0x00	; 0
    458c:	d0 e0       	ldi	r29, 0x00	; 0
  RELEASE_LOCK();
    458e:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
  return valid;
    4592:	02 c0       	rjmp	.+4      	; 0x4598 <cc2420_cca_valid+0x30>
int
cc2420_cca_valid(void)
{
  int valid;
  if(locked) {
    return 1;
    4594:	c1 e0       	ldi	r28, 0x01	; 1
    4596:	d0 e0       	ldi	r29, 0x00	; 0
  }
  GET_LOCK();
  valid = !!(status() & BV(CC2420_RSSI_VALID));
  RELEASE_LOCK();
  return valid;
}
    4598:	ce 01       	movw	r24, r28
    459a:	df 91       	pop	r29
    459c:	cf 91       	pop	r28
    459e:	ff 90       	pop	r15
    45a0:	ef 90       	pop	r14
    45a2:	08 95       	ret

000045a4 <cc2420_set_cca_threshold>:
  return CC2420_FIFOP_IS_1;
}
/*---------------------------------------------------------------------------*/
void
cc2420_set_cca_threshold(int value)
{
    45a4:	78 2f       	mov	r23, r24
  uint16_t shifted = value << 8;
  GET_LOCK();
    45a6:	80 91 06 0e 	lds	r24, 0x0E06
    45aa:	8f 5f       	subi	r24, 0xFF	; 255
    45ac:	80 93 06 0e 	sts	0x0E06, r24
  setreg(CC2420_RSSI, shifted);
    45b0:	83 e1       	ldi	r24, 0x13	; 19
    45b2:	90 e0       	ldi	r25, 0x00	; 0
    45b4:	60 e0       	ldi	r22, 0x00	; 0
    45b6:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <setreg>
  RELEASE_LOCK();
    45ba:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <RELEASE_LOCK>
}
    45be:	08 95       	ret

000045c0 <cc2420_arch_init>:
#include "dev/leds.h"

void
cc2420_arch_init(void)
{
  SFIOR |= BV(PUD);             /* Beware, disable all pull-ups. */
    45c0:	80 b5       	in	r24, 0x20	; 32
    45c2:	84 60       	ori	r24, 0x04	; 4
    45c4:	80 bd       	out	0x20, r24	; 32

  spi_init();
    45c6:	0e 94 68 25 	call	0x4ad0	; 0x4ad0 <spi_init>

  DDRA |= BV(CC2420_RESET_PIN);
    45ca:	d6 9a       	sbi	0x1a, 6	; 26
  DDRA |= BV(CC2420_VREG_PIN);
    45cc:	d5 9a       	sbi	0x1a, 5	; 26
  DDRB &= ~BV(CC2420_FIFO_PIN);
    45ce:	bf 98       	cbi	0x17, 7	; 23
  DDRD &= ~BV(CC2420_CCA_PIN);
    45d0:	8e 98       	cbi	0x11, 6	; 17
  DDRD &= ~BV(CC2420_SFD_PIN);
    45d2:	8c 98       	cbi	0x11, 4	; 17
  DDRE &= ~BV(CC2420_FIFOP_PIN);
    45d4:	16 98       	cbi	0x02, 6	; 2

  PORTA |= BV(CC2420_RESET_PIN);
    45d6:	de 9a       	sbi	0x1b, 6	; 27
  PORTB |= BV(CC2420_CSN_PIN);
    45d8:	c0 9a       	sbi	0x18, 0	; 24

  CC2420_SPI_DISABLE();                /* Unselect radio. */
    45da:	c0 9a       	sbi	0x18, 0	; 24
}
    45dc:	08 95       	ret

000045de <__vector_7>:

ISR(CC2420_IRQ_VECTOR)
{
    45de:	1f 92       	push	r1
    45e0:	0f 92       	push	r0
    45e2:	0f b6       	in	r0, 0x3f	; 63
    45e4:	0f 92       	push	r0
    45e6:	0b b6       	in	r0, 0x3b	; 59
    45e8:	0f 92       	push	r0
    45ea:	11 24       	eor	r1, r1
    45ec:	2f 93       	push	r18
    45ee:	3f 93       	push	r19
    45f0:	4f 93       	push	r20
    45f2:	5f 93       	push	r21
    45f4:	6f 93       	push	r22
    45f6:	7f 93       	push	r23
    45f8:	8f 93       	push	r24
    45fa:	9f 93       	push	r25
    45fc:	af 93       	push	r26
    45fe:	bf 93       	push	r27
    4600:	ef 93       	push	r30
    4602:	ff 93       	push	r31
  /* TODO : wakeup from sleep mode */
  cc2420_interrupt();
    4604:	0e 94 61 21 	call	0x42c2	; 0x42c2 <cc2420_interrupt>

}
    4608:	ff 91       	pop	r31
    460a:	ef 91       	pop	r30
    460c:	bf 91       	pop	r27
    460e:	af 91       	pop	r26
    4610:	9f 91       	pop	r25
    4612:	8f 91       	pop	r24
    4614:	7f 91       	pop	r23
    4616:	6f 91       	pop	r22
    4618:	5f 91       	pop	r21
    461a:	4f 91       	pop	r20
    461c:	3f 91       	pop	r19
    461e:	2f 91       	pop	r18
    4620:	0f 90       	pop	r0
    4622:	0b be       	out	0x3b, r0	; 59
    4624:	0f 90       	pop	r0
    4626:	0f be       	out	0x3f, r0	; 63
    4628:	0f 90       	pop	r0
    462a:	1f 90       	pop	r1
    462c:	18 95       	reti

0000462e <watchdog_init>:
watchdog_init(void)
{
/*  Clear startup bit and disable the wdt, whether or not it will be used.
    Random code may have caused the last reset.
 */
	MCUSR&=~(1<<WDRF);
    462e:	84 b7       	in	r24, 0x34	; 52
    4630:	87 7f       	andi	r24, 0xF7	; 247
    4632:	84 bf       	out	0x34, r24	; 52
    wdt_disable();
    4634:	88 e1       	ldi	r24, 0x18	; 24
    4636:	0f b6       	in	r0, 0x3f	; 63
    4638:	f8 94       	cli
    463a:	81 bd       	out	0x21, r24	; 33
    463c:	11 bc       	out	0x21, r1	; 33
    463e:	0f be       	out	0x3f, r0	; 63
#if WATCHDOG_CONF_BALANCE && WATCHDOG_CONF_TIMEOUT >= 0
	stopped = 1;
#endif
}
    4640:	08 95       	ret

00004642 <watchdog_start>:
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	stopped--;
	if(!stopped)
#endif
		wdt_enable(WATCHDOG_CONF_TIMEOUT);
    4642:	2f e0       	ldi	r18, 0x0F	; 15
    4644:	88 e1       	ldi	r24, 0x18	; 24
    4646:	90 e0       	ldi	r25, 0x00	; 0
    4648:	0f b6       	in	r0, 0x3f	; 63
    464a:	f8 94       	cli
    464c:	a8 95       	wdr
    464e:	81 bd       	out	0x21, r24	; 33
    4650:	0f be       	out	0x3f, r0	; 63
    4652:	21 bd       	out	0x21, r18	; 33
#endif  
}
    4654:	08 95       	ret

00004656 <watchdog_periodic>:
{
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	if(!stopped)
#endif
		wdt_reset();
    4656:	a8 95       	wdr
#endif
}
    4658:	08 95       	ret

0000465a <watchdog_stop>:
{
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	stopped++;
#endif
	wdt_disable();
    465a:	88 e1       	ldi	r24, 0x18	; 24
    465c:	0f b6       	in	r0, 0x3f	; 63
    465e:	f8 94       	cli
    4660:	81 bd       	out	0x21, r24	; 33
    4662:	11 bc       	out	0x21, r1	; 33
    4664:	0f be       	out	0x3f, r0	; 63
#endif
}
    4666:	08 95       	ret

00004668 <watchdog_reboot>:
/*---------------------------------------------------------------------------*/
void
watchdog_reboot(void)
{
	cli();
    4668:	f8 94       	cli
	wdt_enable(WDTO_15MS); //wd on,250ms 
    466a:	28 e0       	ldi	r18, 0x08	; 8
    466c:	88 e1       	ldi	r24, 0x18	; 24
    466e:	90 e0       	ldi	r25, 0x00	; 0
    4670:	0f b6       	in	r0, 0x3f	; 63
    4672:	f8 94       	cli
    4674:	a8 95       	wdr
    4676:	81 bd       	out	0x21, r24	; 33
    4678:	0f be       	out	0x3f, r0	; 63
    467a:	21 bd       	out	0x21, r18	; 33
    467c:	ff cf       	rjmp	.-2      	; 0x467c <watchdog_reboot+0x14>

0000467e <field_len>:
  }
}
/*----------------------------------------------------------------------------*/
static void
field_len(frame802154_t *p, field_length_t *flen)
{
    467e:	ef 92       	push	r14
    4680:	ff 92       	push	r15
    4682:	cf 93       	push	r28
    4684:	df 93       	push	r29
    4686:	fc 01       	movw	r30, r24
    4688:	db 01       	movw	r26, r22
  /* init flen to zeros */
  memset(flen, 0, sizeof(field_length_t));
    468a:	85 e0       	ldi	r24, 0x05	; 5
    468c:	eb 01       	movw	r28, r22
    468e:	19 92       	st	Y+, r1
    4690:	8a 95       	dec	r24
    4692:	e9 f7       	brne	.-6      	; 0x468e <field_len+0x10>

  /* Determine lengths of each field based on fcf and other args */
  if(p->fcf.dest_addr_mode & 3) {
    4694:	85 81       	ldd	r24, Z+5	; 0x05
    4696:	90 e0       	ldi	r25, 0x00	; 0
    4698:	83 70       	andi	r24, 0x03	; 3
    469a:	90 70       	andi	r25, 0x00	; 0
    469c:	00 97       	sbiw	r24, 0x00	; 0
    469e:	11 f0       	breq	.+4      	; 0x46a4 <field_len+0x26>
    flen->dest_pid_len = 2;
    46a0:	82 e0       	ldi	r24, 0x02	; 2
    46a2:	8c 93       	st	X, r24
  }
  if(p->fcf.src_addr_mode & 3) {
    46a4:	87 81       	ldd	r24, Z+7	; 0x07
    46a6:	90 e0       	ldi	r25, 0x00	; 0
    46a8:	83 70       	andi	r24, 0x03	; 3
    46aa:	90 70       	andi	r25, 0x00	; 0
    46ac:	00 97       	sbiw	r24, 0x00	; 0
    46ae:	21 f0       	breq	.+8      	; 0x46b8 <field_len+0x3a>
    flen->src_pid_len = 2;
    46b0:	82 e0       	ldi	r24, 0x02	; 2
    46b2:	12 96       	adiw	r26, 0x02	; 2
    46b4:	8c 93       	st	X, r24
    46b6:	12 97       	sbiw	r26, 0x02	; 2
  }

  /* Set PAN ID compression bit if src pan id matches dest pan id. */
  if(p->fcf.dest_addr_mode & 3 && p->fcf.src_addr_mode & 3 &&
    46b8:	85 81       	ldd	r24, Z+5	; 0x05
    46ba:	90 e0       	ldi	r25, 0x00	; 0
    46bc:	83 70       	andi	r24, 0x03	; 3
    46be:	90 70       	andi	r25, 0x00	; 0
    46c0:	00 97       	sbiw	r24, 0x00	; 0
    46c2:	99 f0       	breq	.+38     	; 0x46ea <field_len+0x6c>
    46c4:	87 81       	ldd	r24, Z+7	; 0x07
    46c6:	90 e0       	ldi	r25, 0x00	; 0
    46c8:	83 70       	andi	r24, 0x03	; 3
    46ca:	90 70       	andi	r25, 0x00	; 0
    46cc:	00 97       	sbiw	r24, 0x00	; 0
    46ce:	69 f0       	breq	.+26     	; 0x46ea <field_len+0x6c>
    46d0:	23 89       	ldd	r18, Z+19	; 0x13
    46d2:	34 89       	ldd	r19, Z+20	; 0x14
    46d4:	81 85       	ldd	r24, Z+9	; 0x09
    46d6:	92 85       	ldd	r25, Z+10	; 0x0a
    46d8:	28 17       	cp	r18, r24
    46da:	39 07       	cpc	r19, r25
    46dc:	31 f4       	brne	.+12     	; 0x46ea <field_len+0x6c>
     p->src_pid == p->dest_pid) {
    p->fcf.panid_compression = 1;
    46de:	81 e0       	ldi	r24, 0x01	; 1
    46e0:	84 83       	std	Z+4, r24	; 0x04

    /* compressed header, only do dest pid */
    flen->src_pid_len = 0;
    46e2:	12 96       	adiw	r26, 0x02	; 2
    46e4:	1c 92       	st	X, r1
    46e6:	12 97       	sbiw	r26, 0x02	; 2
    46e8:	01 c0       	rjmp	.+2      	; 0x46ec <field_len+0x6e>
  } else {
    p->fcf.panid_compression = 0;
    46ea:	14 82       	std	Z+4, r1	; 0x04
  }

  /* determine address lengths */
  flen->dest_addr_len = addr_len(p->fcf.dest_addr_mode & 3);
    46ec:	85 81       	ldd	r24, Z+5	; 0x05
    46ee:	83 70       	andi	r24, 0x03	; 3
    46f0:	82 50       	subi	r24, 0x02	; 2
    46f2:	82 30       	cpi	r24, 0x02	; 2
    46f4:	30 f4       	brcc	.+12     	; 0x4702 <field_len+0x84>
    46f6:	c8 2f       	mov	r28, r24
    46f8:	d0 e0       	ldi	r29, 0x00	; 0
    46fa:	cc 50       	subi	r28, 0x0C	; 12
    46fc:	da 4f       	sbci	r29, 0xFA	; 250
    46fe:	88 81       	ld	r24, Y
    4700:	01 c0       	rjmp	.+2      	; 0x4704 <field_len+0x86>
    4702:	80 e0       	ldi	r24, 0x00	; 0
    4704:	11 96       	adiw	r26, 0x01	; 1
    4706:	8c 93       	st	X, r24
    4708:	11 97       	sbiw	r26, 0x01	; 1
  flen->src_addr_len = addr_len(p->fcf.src_addr_mode & 3);
    470a:	e7 81       	ldd	r30, Z+7	; 0x07
    470c:	e3 70       	andi	r30, 0x03	; 3
    470e:	e2 50       	subi	r30, 0x02	; 2
    4710:	e2 30       	cpi	r30, 0x02	; 2
    4712:	28 f4       	brcc	.+10     	; 0x471e <field_len+0xa0>
    4714:	f0 e0       	ldi	r31, 0x00	; 0
    4716:	ec 50       	subi	r30, 0x0C	; 12
    4718:	fa 4f       	sbci	r31, 0xFA	; 250
    471a:	80 81       	ld	r24, Z
    471c:	01 c0       	rjmp	.+2      	; 0x4720 <field_len+0xa2>
    471e:	80 e0       	ldi	r24, 0x00	; 0
    4720:	13 96       	adiw	r26, 0x03	; 3
    4722:	8c 93       	st	X, r24
    4724:	13 97       	sbiw	r26, 0x03	; 3
    default:
      break;
    }
#endif
  }
}
    4726:	df 91       	pop	r29
    4728:	cf 91       	pop	r28
    472a:	ff 90       	pop	r15
    472c:	ef 90       	pop	r14
    472e:	08 95       	ret

00004730 <frame802154_hdrlen>:
 *
 *   \return The length of the frame header.
*/
uint8_t
frame802154_hdrlen(frame802154_t *p)
{
    4730:	df 93       	push	r29
    4732:	cf 93       	push	r28
    4734:	00 d0       	rcall	.+0      	; 0x4736 <frame802154_hdrlen+0x6>
    4736:	00 d0       	rcall	.+0      	; 0x4738 <frame802154_hdrlen+0x8>
    4738:	0f 92       	push	r0
    473a:	cd b7       	in	r28, 0x3d	; 61
    473c:	de b7       	in	r29, 0x3e	; 62
  field_length_t flen;
  field_len(p, &flen);
    473e:	be 01       	movw	r22, r28
    4740:	6f 5f       	subi	r22, 0xFF	; 255
    4742:	7f 4f       	sbci	r23, 0xFF	; 255
    4744:	0e 94 3f 23 	call	0x467e	; 0x467e <field_len>
  return 3 + flen.dest_pid_len + flen.dest_addr_len +
    4748:	89 81       	ldd	r24, Y+1	; 0x01
    474a:	9a 81       	ldd	r25, Y+2	; 0x02
    474c:	89 0f       	add	r24, r25
    474e:	8d 5f       	subi	r24, 0xFD	; 253
    4750:	9b 81       	ldd	r25, Y+3	; 0x03
    4752:	89 0f       	add	r24, r25
    4754:	9c 81       	ldd	r25, Y+4	; 0x04
    4756:	89 0f       	add	r24, r25
    4758:	9d 81       	ldd	r25, Y+5	; 0x05
    flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len;
}
    475a:	89 0f       	add	r24, r25
    475c:	0f 90       	pop	r0
    475e:	0f 90       	pop	r0
    4760:	0f 90       	pop	r0
    4762:	0f 90       	pop	r0
    4764:	0f 90       	pop	r0
    4766:	cf 91       	pop	r28
    4768:	df 91       	pop	r29
    476a:	08 95       	ret

0000476c <frame802154_create>:
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
{
    476c:	af 92       	push	r10
    476e:	bf 92       	push	r11
    4770:	cf 92       	push	r12
    4772:	df 92       	push	r13
    4774:	ef 92       	push	r14
    4776:	ff 92       	push	r15
    4778:	0f 93       	push	r16
    477a:	1f 93       	push	r17
    477c:	df 93       	push	r29
    477e:	cf 93       	push	r28
    4780:	00 d0       	rcall	.+0      	; 0x4782 <frame802154_create+0x16>
    4782:	00 d0       	rcall	.+0      	; 0x4784 <frame802154_create+0x18>
    4784:	00 d0       	rcall	.+0      	; 0x4786 <frame802154_create+0x1a>
    4786:	cd b7       	in	r28, 0x3d	; 61
    4788:	de b7       	in	r29, 0x3e	; 62
    478a:	8c 01       	movw	r16, r24
    478c:	7b 01       	movw	r14, r22
  int c;
  field_length_t flen;
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);
    478e:	be 01       	movw	r22, r28
    4790:	6f 5f       	subi	r22, 0xFF	; 255
    4792:	7f 4f       	sbci	r23, 0xFF	; 255
    4794:	4e 83       	std	Y+6, r20	; 0x06
    4796:	0e 94 3f 23 	call	0x467e	; 0x467e <field_len>

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    479a:	c9 80       	ldd	r12, Y+1	; 0x01
    479c:	9a 81       	ldd	r25, Y+2	; 0x02
    479e:	a9 2e       	mov	r10, r25
    47a0:	bb 24       	eor	r11, r11
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    47a2:	db 80       	ldd	r13, Y+3	; 0x03
    47a4:	8c 81       	ldd	r24, Y+4	; 0x04
    47a6:	68 2f       	mov	r22, r24
    47a8:	70 e0       	ldi	r23, 0x00	; 0
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    47aa:	95 01       	movw	r18, r10
    47ac:	2c 0d       	add	r18, r12
    47ae:	31 1d       	adc	r19, r1
    47b0:	2d 5f       	subi	r18, 0xFD	; 253
    47b2:	3f 4f       	sbci	r19, 0xFF	; 255
    47b4:	2d 0d       	add	r18, r13
    47b6:	31 1d       	adc	r19, r1
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    47b8:	26 0f       	add	r18, r22
    47ba:	37 1f       	adc	r19, r23
    47bc:	5d 81       	ldd	r21, Y+5	; 0x05
    47be:	25 0f       	add	r18, r21
    47c0:	31 1d       	adc	r19, r1
    47c2:	4e 81       	ldd	r20, Y+6	; 0x06
    47c4:	50 e0       	ldi	r21, 0x00	; 0
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    47c6:	42 17       	cp	r20, r18
    47c8:	53 07       	cpc	r21, r19
    47ca:	0c f4       	brge	.+2      	; 0x47ce <frame802154_create+0x62>
    47cc:	a8 c0       	rjmp	.+336    	; 0x491e <frame802154_create+0x1b2>

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    47ce:	d8 01       	movw	r26, r16
    47d0:	11 96       	adiw	r26, 0x01	; 1
    47d2:	4c 91       	ld	r20, X
    47d4:	11 97       	sbiw	r26, 0x01	; 1
    47d6:	50 e0       	ldi	r21, 0x00	; 0
    47d8:	41 70       	andi	r20, 0x01	; 1
    47da:	50 70       	andi	r21, 0x00	; 0
    47dc:	e3 e0       	ldi	r30, 0x03	; 3
    47de:	44 0f       	add	r20, r20
    47e0:	55 1f       	adc	r21, r21
    47e2:	ea 95       	dec	r30
    47e4:	e1 f7       	brne	.-8      	; 0x47de <frame802154_create+0x72>
    ((p->fcf.frame_pending & 1) << 4) |
    47e6:	12 96       	adiw	r26, 0x02	; 2
    47e8:	2c 91       	ld	r18, X
    47ea:	12 97       	sbiw	r26, 0x02	; 2
    47ec:	30 e0       	ldi	r19, 0x00	; 0
    47ee:	21 70       	andi	r18, 0x01	; 1
    47f0:	30 70       	andi	r19, 0x00	; 0
    47f2:	54 e0       	ldi	r21, 0x04	; 4
    47f4:	22 0f       	add	r18, r18
    47f6:	33 1f       	adc	r19, r19
    47f8:	5a 95       	dec	r21
    47fa:	e1 f7       	brne	.-8      	; 0x47f4 <frame802154_create+0x88>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    47fc:	24 2b       	or	r18, r20
    47fe:	3c 91       	ld	r19, X
    4800:	37 70       	andi	r19, 0x07	; 7
    4802:	23 2b       	or	r18, r19
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    4804:	13 96       	adiw	r26, 0x03	; 3
    4806:	3c 91       	ld	r19, X
    4808:	13 97       	sbiw	r26, 0x03	; 3
    480a:	e3 2f       	mov	r30, r19
    480c:	f0 e0       	ldi	r31, 0x00	; 0
    480e:	e1 70       	andi	r30, 0x01	; 1
    4810:	f0 70       	andi	r31, 0x00	; 0
    4812:	45 e0       	ldi	r20, 0x05	; 5
    4814:	ee 0f       	add	r30, r30
    4816:	ff 1f       	adc	r31, r31
    4818:	4a 95       	dec	r20
    481a:	e1 f7       	brne	.-8      	; 0x4814 <frame802154_create+0xa8>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    481c:	2e 2b       	or	r18, r30
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
    481e:	14 96       	adiw	r26, 0x04	; 4
    4820:	3c 91       	ld	r19, X
    4822:	14 97       	sbiw	r26, 0x04	; 4
    4824:	e3 2f       	mov	r30, r19
    4826:	f0 e0       	ldi	r31, 0x00	; 0
    4828:	e1 70       	andi	r30, 0x01	; 1
    482a:	f0 70       	andi	r31, 0x00	; 0
    482c:	36 e0       	ldi	r19, 0x06	; 6
    482e:	ee 0f       	add	r30, r30
    4830:	ff 1f       	adc	r31, r31
    4832:	3a 95       	dec	r19
    4834:	e1 f7       	brne	.-8      	; 0x482e <frame802154_create+0xc2>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    4836:	2e 2b       	or	r18, r30
    4838:	f7 01       	movw	r30, r14
    483a:	20 83       	st	Z, r18
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    483c:	15 96       	adiw	r26, 0x05	; 5
    483e:	4c 91       	ld	r20, X
    4840:	15 97       	sbiw	r26, 0x05	; 5
    4842:	50 e0       	ldi	r21, 0x00	; 0
    4844:	43 70       	andi	r20, 0x03	; 3
    4846:	50 70       	andi	r21, 0x00	; 0
    4848:	44 0f       	add	r20, r20
    484a:	55 1f       	adc	r21, r21
    484c:	44 0f       	add	r20, r20
    484e:	55 1f       	adc	r21, r21
    ((p->fcf.frame_version & 3) << 4) |
    4850:	16 96       	adiw	r26, 0x06	; 6
    4852:	2c 91       	ld	r18, X
    4854:	16 97       	sbiw	r26, 0x06	; 6
    4856:	30 e0       	ldi	r19, 0x00	; 0
    4858:	23 70       	andi	r18, 0x03	; 3
    485a:	30 70       	andi	r19, 0x00	; 0
    485c:	54 e0       	ldi	r21, 0x04	; 4
    485e:	22 0f       	add	r18, r18
    4860:	33 1f       	adc	r19, r19
    4862:	5a 95       	dec	r21
    4864:	e1 f7       	brne	.-8      	; 0x485e <frame802154_create+0xf2>
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    4866:	24 2b       	or	r18, r20
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);
    4868:	17 96       	adiw	r26, 0x07	; 7
    486a:	3c 91       	ld	r19, X
    486c:	17 97       	sbiw	r26, 0x07	; 7
    486e:	32 95       	swap	r19
    4870:	33 0f       	add	r19, r19
    4872:	33 0f       	add	r19, r19
    4874:	30 7c       	andi	r19, 0xC0	; 192
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    4876:	32 2b       	or	r19, r18
    4878:	31 83       	std	Z+1, r19	; 0x01
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);

  /* sequence number */
  tx_frame_buffer[2] = p->seq;
    487a:	18 96       	adiw	r26, 0x08	; 8
    487c:	2c 91       	ld	r18, X
    487e:	18 97       	sbiw	r26, 0x08	; 8
    4880:	22 83       	std	Z+2, r18	; 0x02
  pos = 3;

  /* Destination PAN ID */
  if(flen.dest_pid_len == 2) {
    4882:	fc 2d       	mov	r31, r12
    4884:	f2 30       	cpi	r31, 0x02	; 2
    4886:	69 f4       	brne	.+26     	; 0x48a2 <frame802154_create+0x136>
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    4888:	19 96       	adiw	r26, 0x09	; 9
    488a:	2c 91       	ld	r18, X
    488c:	d7 01       	movw	r26, r14
    488e:	13 96       	adiw	r26, 0x03	; 3
    4890:	2c 93       	st	X, r18
    4892:	13 97       	sbiw	r26, 0x03	; 3
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
    4894:	f8 01       	movw	r30, r16
    4896:	22 85       	ldd	r18, Z+10	; 0x0a
    4898:	14 96       	adiw	r26, 0x04	; 4
    489a:	2c 93       	st	X, r18
    489c:	14 97       	sbiw	r26, 0x04	; 4
    489e:	45 e0       	ldi	r20, 0x05	; 5
    48a0:	01 c0       	rjmp	.+2      	; 0x48a4 <frame802154_create+0x138>
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);

  /* sequence number */
  tx_frame_buffer[2] = p->seq;
  pos = 3;
    48a2:	43 e0       	ldi	r20, 0x03	; 3
 *
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
    48a4:	e9 2f       	mov	r30, r25
    48a6:	f0 e0       	ldi	r31, 0x00	; 0
    48a8:	3b 96       	adiw	r30, 0x0b	; 11
    48aa:	e0 0f       	add	r30, r16
    48ac:	f1 1f       	adc	r31, r17
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
  }

  /* Destination address */
  for(c = flen.dest_addr_len; c > 0; c--) {
    48ae:	54 2f       	mov	r21, r20
    48b0:	0a c0       	rjmp	.+20     	; 0x48c6 <frame802154_create+0x15a>
    tx_frame_buffer[pos++] = p->dest_addr[c - 1];
    48b2:	97 01       	movw	r18, r14
    48b4:	25 0f       	add	r18, r21
    48b6:	31 1d       	adc	r19, r1
    48b8:	c2 90       	ld	r12, -Z
    48ba:	d9 01       	movw	r26, r18
    48bc:	cc 92       	st	X, r12
    48be:	5f 5f       	subi	r21, 0xFF	; 255
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
  }

  /* Destination address */
  for(c = flen.dest_addr_len; c > 0; c--) {
    48c0:	08 94       	sec
    48c2:	a1 08       	sbc	r10, r1
    48c4:	b1 08       	sbc	r11, r1
    48c6:	a1 14       	cp	r10, r1
    48c8:	b1 04       	cpc	r11, r1
    48ca:	99 f7       	brne	.-26     	; 0x48b2 <frame802154_create+0x146>
    48cc:	94 0f       	add	r25, r20
    tx_frame_buffer[pos++] = p->dest_addr[c - 1];
  }

  /* Source PAN ID */
  if(flen.src_pid_len == 2) {
    48ce:	bd 2d       	mov	r27, r13
    48d0:	b2 30       	cpi	r27, 0x02	; 2
    48d2:	89 f4       	brne	.+34     	; 0x48f6 <frame802154_create+0x18a>
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    48d4:	f7 01       	movw	r30, r14
    48d6:	e9 0f       	add	r30, r25
    48d8:	f1 1d       	adc	r31, r1
    48da:	d8 01       	movw	r26, r16
    48dc:	53 96       	adiw	r26, 0x13	; 19
    48de:	2c 91       	ld	r18, X
    48e0:	53 97       	sbiw	r26, 0x13	; 19
    48e2:	20 83       	st	Z, r18
    48e4:	9f 5f       	subi	r25, 0xFF	; 255
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
    48e6:	f7 01       	movw	r30, r14
    48e8:	e9 0f       	add	r30, r25
    48ea:	f1 1d       	adc	r31, r1
    48ec:	54 96       	adiw	r26, 0x14	; 20
    48ee:	2c 91       	ld	r18, X
    48f0:	54 97       	sbiw	r26, 0x14	; 20
    48f2:	20 83       	st	Z, r18
    48f4:	9f 5f       	subi	r25, 0xFF	; 255
 *
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
    48f6:	e8 2f       	mov	r30, r24
    48f8:	f0 e0       	ldi	r31, 0x00	; 0
    48fa:	75 96       	adiw	r30, 0x15	; 21
    48fc:	e0 0f       	add	r30, r16
    48fe:	f1 1f       	adc	r31, r17
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
  }

  /* Source address */
  for(c = flen.src_addr_len; c > 0; c--) {
    4900:	29 2f       	mov	r18, r25
    4902:	08 c0       	rjmp	.+16     	; 0x4914 <frame802154_create+0x1a8>
    tx_frame_buffer[pos++] = p->src_addr[c - 1];
    4904:	d7 01       	movw	r26, r14
    4906:	a2 0f       	add	r26, r18
    4908:	b1 1d       	adc	r27, r1
    490a:	32 91       	ld	r19, -Z
    490c:	3c 93       	st	X, r19
    490e:	2f 5f       	subi	r18, 0xFF	; 255
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
  }

  /* Source address */
  for(c = flen.src_addr_len; c > 0; c--) {
    4910:	61 50       	subi	r22, 0x01	; 1
    4912:	70 40       	sbci	r23, 0x00	; 0
    4914:	61 15       	cp	r22, r1
    4916:	71 05       	cpc	r23, r1
    4918:	a9 f7       	brne	.-22     	; 0x4904 <frame802154_create+0x198>
    491a:	89 0f       	add	r24, r25
    491c:	01 c0       	rjmp	.+2      	; 0x4920 <frame802154_create+0x1b4>
  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    /* Too little space for headers. */
    return 0;
    491e:	80 e0       	ldi	r24, 0x00	; 0
    /* TODO Aux security header not yet implemented */
/*     pos += flen.aux_sec_len; */
  }

  return pos;
}
    4920:	26 96       	adiw	r28, 0x06	; 6
    4922:	0f b6       	in	r0, 0x3f	; 63
    4924:	f8 94       	cli
    4926:	de bf       	out	0x3e, r29	; 62
    4928:	0f be       	out	0x3f, r0	; 63
    492a:	cd bf       	out	0x3d, r28	; 61
    492c:	cf 91       	pop	r28
    492e:	df 91       	pop	r29
    4930:	1f 91       	pop	r17
    4932:	0f 91       	pop	r16
    4934:	ff 90       	pop	r15
    4936:	ef 90       	pop	r14
    4938:	df 90       	pop	r13
    493a:	cf 90       	pop	r12
    493c:	bf 90       	pop	r11
    493e:	af 90       	pop	r10
    4940:	08 95       	ret

00004942 <frame802154_parse>:
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
{
    4942:	bf 92       	push	r11
    4944:	cf 92       	push	r12
    4946:	df 92       	push	r13
    4948:	ef 92       	push	r14
    494a:	ff 92       	push	r15
    494c:	0f 93       	push	r16
    494e:	1f 93       	push	r17
    4950:	cf 93       	push	r28
    4952:	df 93       	push	r29
    4954:	7c 01       	movw	r14, r24
    4956:	d6 2e       	mov	r13, r22
    4958:	ea 01       	movw	r28, r20
  uint8_t *p;
  frame802154_fcf_t fcf;
  uint8_t c;

  if(len < 3) {
    495a:	63 30       	cpi	r22, 0x03	; 3
    495c:	08 f4       	brcc	.+2      	; 0x4960 <frame802154_parse+0x1e>
    495e:	ad c0       	rjmp	.+346    	; 0x4aba <frame802154_parse+0x178>
  }

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
    4960:	fc 01       	movw	r30, r24
    4962:	80 81       	ld	r24, Z
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;
    4964:	b8 2e       	mov	r11, r24
    4966:	b2 94       	swap	r11
    4968:	b6 94       	lsr	r11
    496a:	b6 94       	lsr	r11
    496c:	b3 e0       	ldi	r27, 0x03	; 3
    496e:	bb 22       	and	r11, r27
    4970:	f1 e0       	ldi	r31, 0x01	; 1
    4972:	bf 22       	and	r11, r31

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
    4974:	f7 01       	movw	r30, r14
    4976:	91 81       	ldd	r25, Z+1	; 0x01
    4978:	29 2f       	mov	r18, r25
    497a:	26 95       	lsr	r18
    497c:	26 95       	lsr	r18
    497e:	23 70       	andi	r18, 0x03	; 3
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    4980:	c9 2e       	mov	r12, r25
    4982:	c2 94       	swap	r12
    4984:	c6 94       	lsr	r12
    4986:	c6 94       	lsr	r12
    4988:	a3 e0       	ldi	r26, 0x03	; 3
    498a:	ca 22       	and	r12, r26
  }

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
    498c:	38 2f       	mov	r19, r24
    498e:	37 70       	andi	r19, 0x07	; 7
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    4990:	38 83       	st	Y, r19

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
    4992:	38 2f       	mov	r19, r24
    4994:	36 95       	lsr	r19
    4996:	36 95       	lsr	r19
    4998:	36 95       	lsr	r19
    499a:	31 70       	andi	r19, 0x01	; 1
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    499c:	39 83       	std	Y+1, r19	; 0x01
  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
    499e:	38 2f       	mov	r19, r24
    49a0:	32 95       	swap	r19
    49a2:	31 70       	andi	r19, 0x01	; 1
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    49a4:	3a 83       	std	Y+2, r19	; 0x02

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
    49a6:	82 95       	swap	r24
    49a8:	86 95       	lsr	r24
    49aa:	81 70       	andi	r24, 0x01	; 1
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    49ac:	8b 83       	std	Y+3, r24	; 0x03
    49ae:	bc 82       	std	Y+4, r11	; 0x04
    49b0:	2d 83       	std	Y+5, r18	; 0x05
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
    49b2:	89 2f       	mov	r24, r25
    49b4:	82 95       	swap	r24
    49b6:	83 70       	andi	r24, 0x03	; 3
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    49b8:	8e 83       	std	Y+6, r24	; 0x06
    49ba:	cf 82       	std	Y+7, r12	; 0x07

  /* copy fcf and seqNum */
  memcpy(&pf->fcf, &fcf, sizeof(frame802154_fcf_t));
  pf->seq = p[2];
    49bc:	82 81       	ldd	r24, Z+2	; 0x02
    49be:	88 87       	std	Y+8, r24	; 0x08
  p += 3;                             /* Skip first three bytes */
    49c0:	87 01       	movw	r16, r14
    49c2:	0d 5f       	subi	r16, 0xFD	; 253
    49c4:	1f 4f       	sbci	r17, 0xFF	; 255

  /* Destination address, if any */
  if(fcf.dest_addr_mode) {
    49c6:	22 23       	and	r18, r18
    49c8:	61 f1       	breq	.+88     	; 0x4a22 <frame802154_parse+0xe0>
    /* Destination PAN */
    pf->dest_pid = p[0] + (p[1] << 8);
    49ca:	f8 01       	movw	r30, r16
    49cc:	91 81       	ldd	r25, Z+1	; 0x01
    49ce:	80 e0       	ldi	r24, 0x00	; 0
    49d0:	f7 01       	movw	r30, r14
    49d2:	33 81       	ldd	r19, Z+3	; 0x03
    49d4:	83 0f       	add	r24, r19
    49d6:	91 1d       	adc	r25, r1
    49d8:	9a 87       	std	Y+10, r25	; 0x0a
    49da:	89 87       	std	Y+9, r24	; 0x09
    p += 2;
    49dc:	87 01       	movw	r16, r14
    49de:	0b 5f       	subi	r16, 0xFB	; 251
    49e0:	1f 4f       	sbci	r17, 0xFF	; 255
/*     l = addr_len(fcf.dest_addr_mode); */
/*     for(c = 0; c < l; c++) { */
/*       pf->dest_addr.u8[c] = p[l - c - 1]; */
/*     } */
/*     p += l; */
    if(fcf.dest_addr_mode == FRAME802154_SHORTADDRMODE) {
    49e2:	22 30       	cpi	r18, 0x02	; 2
    49e4:	81 f4       	brne	.+32     	; 0x4a06 <frame802154_parse+0xc4>
      rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
    49e6:	ca 01       	movw	r24, r20
    49e8:	0b 96       	adiw	r24, 0x0b	; 11
    49ea:	67 e8       	ldi	r22, 0x87	; 135
    49ec:	73 e0       	ldi	r23, 0x03	; 3
    49ee:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
      pf->dest_addr[0] = p[1];
    49f2:	f8 01       	movw	r30, r16
    49f4:	81 81       	ldd	r24, Z+1	; 0x01
    49f6:	8b 87       	std	Y+11, r24	; 0x0b
      pf->dest_addr[1] = p[0];
    49f8:	f7 01       	movw	r30, r14
    49fa:	85 81       	ldd	r24, Z+5	; 0x05
    49fc:	8c 87       	std	Y+12, r24	; 0x0c
      p += 2;
    49fe:	87 01       	movw	r16, r14
    4a00:	09 5f       	subi	r16, 0xF9	; 249
    4a02:	1f 4f       	sbci	r17, 0xFF	; 255
    4a04:	16 c0       	rjmp	.+44     	; 0x4a32 <frame802154_parse+0xf0>
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
    4a06:	23 30       	cpi	r18, 0x03	; 3
    4a08:	a1 f4       	brne	.+40     	; 0x4a32 <frame802154_parse+0xf0>
 *   \param data The input data from the radio chip.
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
    4a0a:	f7 01       	movw	r30, r14
    4a0c:	3d 96       	adiw	r30, 0x0d	; 13
    4a0e:	da 01       	movw	r26, r20
    4a10:	1b 96       	adiw	r26, 0x0b	; 11
      pf->dest_addr[0] = p[1];
      pf->dest_addr[1] = p[0];
      p += 2;
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
        pf->dest_addr[c] = p[7 - c];
    4a12:	82 91       	ld	r24, -Z
    4a14:	8d 93       	st	X+, r24
      rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
      pf->dest_addr[0] = p[1];
      pf->dest_addr[1] = p[0];
      p += 2;
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
    4a16:	e0 17       	cp	r30, r16
    4a18:	f1 07       	cpc	r31, r17
    4a1a:	d9 f7       	brne	.-10     	; 0x4a12 <frame802154_parse+0xd0>
        pf->dest_addr[c] = p[7 - c];
      }
      p += 8;
    4a1c:	08 5f       	subi	r16, 0xF8	; 248
    4a1e:	1f 4f       	sbci	r17, 0xFF	; 255
    4a20:	08 c0       	rjmp	.+16     	; 0x4a32 <frame802154_parse+0xf0>
    }
  } else {
    rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
    4a22:	ca 01       	movw	r24, r20
    4a24:	0b 96       	adiw	r24, 0x0b	; 11
    4a26:	67 e8       	ldi	r22, 0x87	; 135
    4a28:	73 e0       	ldi	r23, 0x03	; 3
    4a2a:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    pf->dest_pid = 0;
    4a2e:	1a 86       	std	Y+10, r1	; 0x0a
    4a30:	19 86       	std	Y+9, r1	; 0x09
  }

  /* Source address, if any */
  if(fcf.src_addr_mode) {
    4a32:	cc 20       	and	r12, r12
    4a34:	89 f1       	breq	.+98     	; 0x4a98 <frame802154_parse+0x156>
    /* Source PAN */
    if(!fcf.panid_compression) {
    4a36:	bb 20       	and	r11, r11
    4a38:	59 f4       	brne	.+22     	; 0x4a50 <frame802154_parse+0x10e>
      pf->src_pid = p[0] + (p[1] << 8);
    4a3a:	f8 01       	movw	r30, r16
    4a3c:	91 81       	ldd	r25, Z+1	; 0x01
    4a3e:	80 e0       	ldi	r24, 0x00	; 0
    4a40:	20 81       	ld	r18, Z
    4a42:	82 0f       	add	r24, r18
    4a44:	91 1d       	adc	r25, r1
    4a46:	9c 8b       	std	Y+20, r25	; 0x14
    4a48:	8b 8b       	std	Y+19, r24	; 0x13
      p += 2;
    4a4a:	0e 5f       	subi	r16, 0xFE	; 254
    4a4c:	1f 4f       	sbci	r17, 0xFF	; 255
    4a4e:	04 c0       	rjmp	.+8      	; 0x4a58 <frame802154_parse+0x116>
    } else {
      pf->src_pid = pf->dest_pid;
    4a50:	89 85       	ldd	r24, Y+9	; 0x09
    4a52:	9a 85       	ldd	r25, Y+10	; 0x0a
    4a54:	9c 8b       	std	Y+20, r25	; 0x14
    4a56:	8b 8b       	std	Y+19, r24	; 0x13
/*     l = addr_len(fcf.src_addr_mode); */
/*     for(c = 0; c < l; c++) { */
/*       pf->src_addr.u8[c] = p[l - c - 1]; */
/*     } */
/*     p += l; */
    if(fcf.src_addr_mode == FRAME802154_SHORTADDRMODE) {
    4a58:	fc 2d       	mov	r31, r12
    4a5a:	f2 30       	cpi	r31, 0x02	; 2
    4a5c:	71 f4       	brne	.+28     	; 0x4a7a <frame802154_parse+0x138>
      rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
    4a5e:	ce 01       	movw	r24, r28
    4a60:	45 96       	adiw	r24, 0x15	; 21
    4a62:	67 e8       	ldi	r22, 0x87	; 135
    4a64:	73 e0       	ldi	r23, 0x03	; 3
    4a66:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
      pf->src_addr[0] = p[1];
    4a6a:	f8 01       	movw	r30, r16
    4a6c:	81 81       	ldd	r24, Z+1	; 0x01
    4a6e:	8d 8b       	std	Y+21, r24	; 0x15
      pf->src_addr[1] = p[0];
    4a70:	80 81       	ld	r24, Z
    4a72:	8e 8b       	std	Y+22, r24	; 0x16
      p += 2;
    4a74:	0e 5f       	subi	r16, 0xFE	; 254
    4a76:	1f 4f       	sbci	r17, 0xFF	; 255
    4a78:	17 c0       	rjmp	.+46     	; 0x4aa8 <frame802154_parse+0x166>
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
    4a7a:	fc 2d       	mov	r31, r12
    4a7c:	f3 30       	cpi	r31, 0x03	; 3
    4a7e:	a1 f4       	brne	.+40     	; 0x4aa8 <frame802154_parse+0x166>
 *   \param data The input data from the radio chip.
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
    4a80:	08 5f       	subi	r16, 0xF8	; 248
    4a82:	1f 4f       	sbci	r17, 0xFF	; 255
    4a84:	d8 01       	movw	r26, r16
    4a86:	fe 01       	movw	r30, r28
    4a88:	75 96       	adiw	r30, 0x15	; 21
    4a8a:	80 e0       	ldi	r24, 0x00	; 0
      pf->src_addr[0] = p[1];
      pf->src_addr[1] = p[0];
      p += 2;
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
        pf->src_addr[c] = p[7 - c];
    4a8c:	9e 91       	ld	r25, -X
    4a8e:	91 93       	st	Z+, r25
      rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
      pf->src_addr[0] = p[1];
      pf->src_addr[1] = p[0];
      p += 2;
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
    4a90:	8f 5f       	subi	r24, 0xFF	; 255
    4a92:	88 30       	cpi	r24, 0x08	; 8
    4a94:	d9 f7       	brne	.-10     	; 0x4a8c <frame802154_parse+0x14a>
    4a96:	08 c0       	rjmp	.+16     	; 0x4aa8 <frame802154_parse+0x166>
        pf->src_addr[c] = p[7 - c];
      }
      p += 8;
    }
  } else {
    rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
    4a98:	ce 01       	movw	r24, r28
    4a9a:	45 96       	adiw	r24, 0x15	; 21
    4a9c:	67 e8       	ldi	r22, 0x87	; 135
    4a9e:	73 e0       	ldi	r23, 0x03	; 3
    4aa0:	0e 94 ba 07 	call	0xf74	; 0xf74 <rimeaddr_copy>
    pf->src_pid = 0;
    4aa4:	1c 8a       	std	Y+20, r1	; 0x14
    4aa6:	1b 8a       	std	Y+19, r1	; 0x13
    /* TODO aux security header, not yet implemented */
/*     return 0; */
  }

  /* header length */
  c = p - data;
    4aa8:	80 2f       	mov	r24, r16
    4aaa:	8e 19       	sub	r24, r14
  /* payload length */
  pf->payload_len = len - c;
    4aac:	9d 2d       	mov	r25, r13
    4aae:	98 1b       	sub	r25, r24
    4ab0:	9f a7       	std	Y+47, r25	; 0x2f
  /* payload */
  pf->payload = p;
    4ab2:	1e a7       	std	Y+46, r17	; 0x2e
    4ab4:	0d a7       	std	Y+45, r16	; 0x2d

  /* return header length if successful */
  return c > len ? 0 : c;
    4ab6:	d8 16       	cp	r13, r24
    4ab8:	08 f4       	brcc	.+2      	; 0x4abc <frame802154_parse+0x17a>
  uint8_t *p;
  frame802154_fcf_t fcf;
  uint8_t c;

  if(len < 3) {
    return 0;
    4aba:	80 e0       	ldi	r24, 0x00	; 0
  /* payload */
  pf->payload = p;

  /* return header length if successful */
  return c > len ? 0 : c;
}
    4abc:	df 91       	pop	r29
    4abe:	cf 91       	pop	r28
    4ac0:	1f 91       	pop	r17
    4ac2:	0f 91       	pop	r16
    4ac4:	ff 90       	pop	r15
    4ac6:	ef 90       	pop	r14
    4ac8:	df 90       	pop	r13
    4aca:	cf 90       	pop	r12
    4acc:	bf 90       	pop	r11
    4ace:	08 95       	ret

00004ad0 <spi_init>:
void
spi_init(void)
{
  /* Initalize ports for communication with SPI units. */
  /* CSN=SS and must be output when master! */
  DDRB  |= BV(MOSI) | BV(SCK) | BV(CSN);
    4ad0:	87 b3       	in	r24, 0x17	; 23
    4ad2:	87 60       	ori	r24, 0x07	; 7
    4ad4:	87 bb       	out	0x17, r24	; 23
  PORTB |= BV(MOSI) | BV(SCK);
    4ad6:	88 b3       	in	r24, 0x18	; 24
    4ad8:	86 60       	ori	r24, 0x06	; 6
    4ada:	88 bb       	out	0x18, r24	; 24

  /* Enables SPI, selects "master", clock rate FCK / 2, and SPI mode 0 */
  SPCR = BV(SPE) | BV(MSTR);
    4adc:	80 e5       	ldi	r24, 0x50	; 80
    4ade:	8d b9       	out	0x0d, r24	; 13
  SPSR = BV(SPI2X);
    4ae0:	81 e0       	ldi	r24, 0x01	; 1
    4ae2:	8e b9       	out	0x0e, r24	; 14
}
    4ae4:	08 95       	ret

00004ae6 <__udivmodhi4>:
    4ae6:	aa 1b       	sub	r26, r26
    4ae8:	bb 1b       	sub	r27, r27
    4aea:	51 e1       	ldi	r21, 0x11	; 17
    4aec:	07 c0       	rjmp	.+14     	; 0x4afc <__udivmodhi4_ep>

00004aee <__udivmodhi4_loop>:
    4aee:	aa 1f       	adc	r26, r26
    4af0:	bb 1f       	adc	r27, r27
    4af2:	a6 17       	cp	r26, r22
    4af4:	b7 07       	cpc	r27, r23
    4af6:	10 f0       	brcs	.+4      	; 0x4afc <__udivmodhi4_ep>
    4af8:	a6 1b       	sub	r26, r22
    4afa:	b7 0b       	sbc	r27, r23

00004afc <__udivmodhi4_ep>:
    4afc:	88 1f       	adc	r24, r24
    4afe:	99 1f       	adc	r25, r25
    4b00:	5a 95       	dec	r21
    4b02:	a9 f7       	brne	.-22     	; 0x4aee <__udivmodhi4_loop>
    4b04:	80 95       	com	r24
    4b06:	90 95       	com	r25
    4b08:	bc 01       	movw	r22, r24
    4b0a:	cd 01       	movw	r24, r26
    4b0c:	08 95       	ret

00004b0e <do_rand>:
    4b0e:	af 92       	push	r10
    4b10:	bf 92       	push	r11
    4b12:	cf 92       	push	r12
    4b14:	df 92       	push	r13
    4b16:	ef 92       	push	r14
    4b18:	ff 92       	push	r15
    4b1a:	0f 93       	push	r16
    4b1c:	1f 93       	push	r17
    4b1e:	cf 93       	push	r28
    4b20:	df 93       	push	r29
    4b22:	ec 01       	movw	r28, r24
    4b24:	68 81       	ld	r22, Y
    4b26:	79 81       	ldd	r23, Y+1	; 0x01
    4b28:	8a 81       	ldd	r24, Y+2	; 0x02
    4b2a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b2c:	61 15       	cp	r22, r1
    4b2e:	71 05       	cpc	r23, r1
    4b30:	81 05       	cpc	r24, r1
    4b32:	91 05       	cpc	r25, r1
    4b34:	21 f4       	brne	.+8      	; 0x4b3e <do_rand+0x30>
    4b36:	64 e2       	ldi	r22, 0x24	; 36
    4b38:	79 ed       	ldi	r23, 0xD9	; 217
    4b3a:	8b e5       	ldi	r24, 0x5B	; 91
    4b3c:	97 e0       	ldi	r25, 0x07	; 7
    4b3e:	2d e1       	ldi	r18, 0x1D	; 29
    4b40:	33 ef       	ldi	r19, 0xF3	; 243
    4b42:	41 e0       	ldi	r20, 0x01	; 1
    4b44:	50 e0       	ldi	r21, 0x00	; 0
    4b46:	0e 94 54 29 	call	0x52a8	; 0x52a8 <__divmodsi4>
    4b4a:	79 01       	movw	r14, r18
    4b4c:	8a 01       	movw	r16, r20
    4b4e:	27 ea       	ldi	r18, 0xA7	; 167
    4b50:	31 e4       	ldi	r19, 0x41	; 65
    4b52:	40 e0       	ldi	r20, 0x00	; 0
    4b54:	50 e0       	ldi	r21, 0x00	; 0
    4b56:	0e 94 35 29 	call	0x526a	; 0x526a <__mulsi3>
    4b5a:	5b 01       	movw	r10, r22
    4b5c:	6c 01       	movw	r12, r24
    4b5e:	c8 01       	movw	r24, r16
    4b60:	b7 01       	movw	r22, r14
    4b62:	2c ee       	ldi	r18, 0xEC	; 236
    4b64:	34 ef       	ldi	r19, 0xF4	; 244
    4b66:	4f ef       	ldi	r20, 0xFF	; 255
    4b68:	5f ef       	ldi	r21, 0xFF	; 255
    4b6a:	0e 94 35 29 	call	0x526a	; 0x526a <__mulsi3>
    4b6e:	6a 0d       	add	r22, r10
    4b70:	7b 1d       	adc	r23, r11
    4b72:	8c 1d       	adc	r24, r12
    4b74:	9d 1d       	adc	r25, r13
    4b76:	97 ff       	sbrs	r25, 7
    4b78:	04 c0       	rjmp	.+8      	; 0x4b82 <do_rand+0x74>
    4b7a:	61 50       	subi	r22, 0x01	; 1
    4b7c:	70 40       	sbci	r23, 0x00	; 0
    4b7e:	80 40       	sbci	r24, 0x00	; 0
    4b80:	90 48       	sbci	r25, 0x80	; 128
    4b82:	68 83       	st	Y, r22
    4b84:	79 83       	std	Y+1, r23	; 0x01
    4b86:	8a 83       	std	Y+2, r24	; 0x02
    4b88:	9b 83       	std	Y+3, r25	; 0x03
    4b8a:	7f 77       	andi	r23, 0x7F	; 127
    4b8c:	cb 01       	movw	r24, r22
    4b8e:	df 91       	pop	r29
    4b90:	cf 91       	pop	r28
    4b92:	1f 91       	pop	r17
    4b94:	0f 91       	pop	r16
    4b96:	ff 90       	pop	r15
    4b98:	ef 90       	pop	r14
    4b9a:	df 90       	pop	r13
    4b9c:	cf 90       	pop	r12
    4b9e:	bf 90       	pop	r11
    4ba0:	af 90       	pop	r10
    4ba2:	08 95       	ret

00004ba4 <rand_r>:
    4ba4:	0e 94 87 25 	call	0x4b0e	; 0x4b0e <do_rand>
    4ba8:	08 95       	ret

00004baa <rand>:
    4baa:	86 ef       	ldi	r24, 0xF6	; 246
    4bac:	95 e0       	ldi	r25, 0x05	; 5
    4bae:	0e 94 87 25 	call	0x4b0e	; 0x4b0e <do_rand>
    4bb2:	08 95       	ret

00004bb4 <srand>:
    4bb4:	a0 e0       	ldi	r26, 0x00	; 0
    4bb6:	b0 e0       	ldi	r27, 0x00	; 0
    4bb8:	80 93 f6 05 	sts	0x05F6, r24
    4bbc:	90 93 f7 05 	sts	0x05F7, r25
    4bc0:	a0 93 f8 05 	sts	0x05F8, r26
    4bc4:	b0 93 f9 05 	sts	0x05F9, r27
    4bc8:	08 95       	ret

00004bca <memcpy>:
    4bca:	fb 01       	movw	r30, r22
    4bcc:	dc 01       	movw	r26, r24
    4bce:	02 c0       	rjmp	.+4      	; 0x4bd4 <memcpy+0xa>
    4bd0:	01 90       	ld	r0, Z+
    4bd2:	0d 92       	st	X+, r0
    4bd4:	41 50       	subi	r20, 0x01	; 1
    4bd6:	50 40       	sbci	r21, 0x00	; 0
    4bd8:	d8 f7       	brcc	.-10     	; 0x4bd0 <memcpy+0x6>
    4bda:	08 95       	ret

00004bdc <memset>:
    4bdc:	dc 01       	movw	r26, r24
    4bde:	01 c0       	rjmp	.+2      	; 0x4be2 <memset+0x6>
    4be0:	6d 93       	st	X+, r22
    4be2:	41 50       	subi	r20, 0x01	; 1
    4be4:	50 40       	sbci	r21, 0x00	; 0
    4be6:	e0 f7       	brcc	.-8      	; 0x4be0 <memset+0x4>
    4be8:	08 95       	ret

00004bea <printf>:
    4bea:	df 93       	push	r29
    4bec:	cf 93       	push	r28
    4bee:	cd b7       	in	r28, 0x3d	; 61
    4bf0:	de b7       	in	r29, 0x3e	; 62
    4bf2:	fe 01       	movw	r30, r28
    4bf4:	35 96       	adiw	r30, 0x05	; 5
    4bf6:	61 91       	ld	r22, Z+
    4bf8:	71 91       	ld	r23, Z+
    4bfa:	80 91 ba 0e 	lds	r24, 0x0EBA
    4bfe:	90 91 bb 0e 	lds	r25, 0x0EBB
    4c02:	af 01       	movw	r20, r30
    4c04:	0e 94 5e 26 	call	0x4cbc	; 0x4cbc <vfprintf>
    4c08:	cf 91       	pop	r28
    4c0a:	df 91       	pop	r29
    4c0c:	08 95       	ret

00004c0e <printf_P>:
    4c0e:	df 93       	push	r29
    4c10:	cf 93       	push	r28
    4c12:	cd b7       	in	r28, 0x3d	; 61
    4c14:	de b7       	in	r29, 0x3e	; 62
    4c16:	fe 01       	movw	r30, r28
    4c18:	35 96       	adiw	r30, 0x05	; 5
    4c1a:	61 91       	ld	r22, Z+
    4c1c:	71 91       	ld	r23, Z+
    4c1e:	80 91 ba 0e 	lds	r24, 0x0EBA
    4c22:	90 91 bb 0e 	lds	r25, 0x0EBB
    4c26:	dc 01       	movw	r26, r24
    4c28:	13 96       	adiw	r26, 0x03	; 3
    4c2a:	2c 91       	ld	r18, X
    4c2c:	13 97       	sbiw	r26, 0x03	; 3
    4c2e:	28 60       	ori	r18, 0x08	; 8
    4c30:	13 96       	adiw	r26, 0x03	; 3
    4c32:	2c 93       	st	X, r18
    4c34:	af 01       	movw	r20, r30
    4c36:	0e 94 5e 26 	call	0x4cbc	; 0x4cbc <vfprintf>
    4c3a:	e0 91 ba 0e 	lds	r30, 0x0EBA
    4c3e:	f0 91 bb 0e 	lds	r31, 0x0EBB
    4c42:	23 81       	ldd	r18, Z+3	; 0x03
    4c44:	27 7f       	andi	r18, 0xF7	; 247
    4c46:	23 83       	std	Z+3, r18	; 0x03
    4c48:	cf 91       	pop	r28
    4c4a:	df 91       	pop	r29
    4c4c:	08 95       	ret

00004c4e <puts>:
    4c4e:	ef 92       	push	r14
    4c50:	ff 92       	push	r15
    4c52:	0f 93       	push	r16
    4c54:	1f 93       	push	r17
    4c56:	cf 93       	push	r28
    4c58:	df 93       	push	r29
    4c5a:	8c 01       	movw	r16, r24
    4c5c:	e0 91 ba 0e 	lds	r30, 0x0EBA
    4c60:	f0 91 bb 0e 	lds	r31, 0x0EBB
    4c64:	83 81       	ldd	r24, Z+3	; 0x03
    4c66:	81 ff       	sbrs	r24, 1
    4c68:	1f c0       	rjmp	.+62     	; 0x4ca8 <puts+0x5a>
    4c6a:	c0 e0       	ldi	r28, 0x00	; 0
    4c6c:	d0 e0       	ldi	r29, 0x00	; 0
    4c6e:	0a c0       	rjmp	.+20     	; 0x4c84 <puts+0x36>
    4c70:	db 01       	movw	r26, r22
    4c72:	18 96       	adiw	r26, 0x08	; 8
    4c74:	ed 91       	ld	r30, X+
    4c76:	fc 91       	ld	r31, X
    4c78:	19 97       	sbiw	r26, 0x09	; 9
    4c7a:	09 95       	icall
    4c7c:	00 97       	sbiw	r24, 0x00	; 0
    4c7e:	11 f0       	breq	.+4      	; 0x4c84 <puts+0x36>
    4c80:	cf ef       	ldi	r28, 0xFF	; 255
    4c82:	df ef       	ldi	r29, 0xFF	; 255
    4c84:	f8 01       	movw	r30, r16
    4c86:	81 91       	ld	r24, Z+
    4c88:	8f 01       	movw	r16, r30
    4c8a:	60 91 ba 0e 	lds	r22, 0x0EBA
    4c8e:	70 91 bb 0e 	lds	r23, 0x0EBB
    4c92:	88 23       	and	r24, r24
    4c94:	69 f7       	brne	.-38     	; 0x4c70 <puts+0x22>
    4c96:	db 01       	movw	r26, r22
    4c98:	18 96       	adiw	r26, 0x08	; 8
    4c9a:	ed 91       	ld	r30, X+
    4c9c:	fc 91       	ld	r31, X
    4c9e:	19 97       	sbiw	r26, 0x09	; 9
    4ca0:	8a e0       	ldi	r24, 0x0A	; 10
    4ca2:	09 95       	icall
    4ca4:	00 97       	sbiw	r24, 0x00	; 0
    4ca6:	11 f0       	breq	.+4      	; 0x4cac <puts+0x5e>
    4ca8:	cf ef       	ldi	r28, 0xFF	; 255
    4caa:	df ef       	ldi	r29, 0xFF	; 255
    4cac:	ce 01       	movw	r24, r28
    4cae:	df 91       	pop	r29
    4cb0:	cf 91       	pop	r28
    4cb2:	1f 91       	pop	r17
    4cb4:	0f 91       	pop	r16
    4cb6:	ff 90       	pop	r15
    4cb8:	ef 90       	pop	r14
    4cba:	08 95       	ret

00004cbc <vfprintf>:
    4cbc:	2f 92       	push	r2
    4cbe:	3f 92       	push	r3
    4cc0:	4f 92       	push	r4
    4cc2:	5f 92       	push	r5
    4cc4:	6f 92       	push	r6
    4cc6:	7f 92       	push	r7
    4cc8:	8f 92       	push	r8
    4cca:	9f 92       	push	r9
    4ccc:	af 92       	push	r10
    4cce:	bf 92       	push	r11
    4cd0:	cf 92       	push	r12
    4cd2:	df 92       	push	r13
    4cd4:	ef 92       	push	r14
    4cd6:	ff 92       	push	r15
    4cd8:	0f 93       	push	r16
    4cda:	1f 93       	push	r17
    4cdc:	df 93       	push	r29
    4cde:	cf 93       	push	r28
    4ce0:	cd b7       	in	r28, 0x3d	; 61
    4ce2:	de b7       	in	r29, 0x3e	; 62
    4ce4:	2c 97       	sbiw	r28, 0x0c	; 12
    4ce6:	0f b6       	in	r0, 0x3f	; 63
    4ce8:	f8 94       	cli
    4cea:	de bf       	out	0x3e, r29	; 62
    4cec:	0f be       	out	0x3f, r0	; 63
    4cee:	cd bf       	out	0x3d, r28	; 61
    4cf0:	6c 01       	movw	r12, r24
    4cf2:	1b 01       	movw	r2, r22
    4cf4:	8a 01       	movw	r16, r20
    4cf6:	fc 01       	movw	r30, r24
    4cf8:	17 82       	std	Z+7, r1	; 0x07
    4cfa:	16 82       	std	Z+6, r1	; 0x06
    4cfc:	83 81       	ldd	r24, Z+3	; 0x03
    4cfe:	81 ff       	sbrs	r24, 1
    4d00:	d1 c1       	rjmp	.+930    	; 0x50a4 <vfprintf+0x3e8>
    4d02:	2e 01       	movw	r4, r28
    4d04:	08 94       	sec
    4d06:	41 1c       	adc	r4, r1
    4d08:	51 1c       	adc	r5, r1
    4d0a:	f6 01       	movw	r30, r12
    4d0c:	93 81       	ldd	r25, Z+3	; 0x03
    4d0e:	f1 01       	movw	r30, r2
    4d10:	93 fd       	sbrc	r25, 3
    4d12:	85 91       	lpm	r24, Z+
    4d14:	93 ff       	sbrs	r25, 3
    4d16:	81 91       	ld	r24, Z+
    4d18:	1f 01       	movw	r2, r30
    4d1a:	88 23       	and	r24, r24
    4d1c:	09 f4       	brne	.+2      	; 0x4d20 <vfprintf+0x64>
    4d1e:	be c1       	rjmp	.+892    	; 0x509c <vfprintf+0x3e0>
    4d20:	85 32       	cpi	r24, 0x25	; 37
    4d22:	39 f4       	brne	.+14     	; 0x4d32 <vfprintf+0x76>
    4d24:	93 fd       	sbrc	r25, 3
    4d26:	85 91       	lpm	r24, Z+
    4d28:	93 ff       	sbrs	r25, 3
    4d2a:	81 91       	ld	r24, Z+
    4d2c:	1f 01       	movw	r2, r30
    4d2e:	85 32       	cpi	r24, 0x25	; 37
    4d30:	29 f4       	brne	.+10     	; 0x4d3c <vfprintf+0x80>
    4d32:	90 e0       	ldi	r25, 0x00	; 0
    4d34:	b6 01       	movw	r22, r12
    4d36:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    4d3a:	e7 cf       	rjmp	.-50     	; 0x4d0a <vfprintf+0x4e>
    4d3c:	ee 24       	eor	r14, r14
    4d3e:	ff 24       	eor	r15, r15
    4d40:	20 e0       	ldi	r18, 0x00	; 0
    4d42:	20 32       	cpi	r18, 0x20	; 32
    4d44:	b0 f4       	brcc	.+44     	; 0x4d72 <vfprintf+0xb6>
    4d46:	8b 32       	cpi	r24, 0x2B	; 43
    4d48:	69 f0       	breq	.+26     	; 0x4d64 <vfprintf+0xa8>
    4d4a:	8c 32       	cpi	r24, 0x2C	; 44
    4d4c:	28 f4       	brcc	.+10     	; 0x4d58 <vfprintf+0x9c>
    4d4e:	80 32       	cpi	r24, 0x20	; 32
    4d50:	51 f0       	breq	.+20     	; 0x4d66 <vfprintf+0xaa>
    4d52:	83 32       	cpi	r24, 0x23	; 35
    4d54:	71 f4       	brne	.+28     	; 0x4d72 <vfprintf+0xb6>
    4d56:	0b c0       	rjmp	.+22     	; 0x4d6e <vfprintf+0xb2>
    4d58:	8d 32       	cpi	r24, 0x2D	; 45
    4d5a:	39 f0       	breq	.+14     	; 0x4d6a <vfprintf+0xae>
    4d5c:	80 33       	cpi	r24, 0x30	; 48
    4d5e:	49 f4       	brne	.+18     	; 0x4d72 <vfprintf+0xb6>
    4d60:	21 60       	ori	r18, 0x01	; 1
    4d62:	2c c0       	rjmp	.+88     	; 0x4dbc <vfprintf+0x100>
    4d64:	22 60       	ori	r18, 0x02	; 2
    4d66:	24 60       	ori	r18, 0x04	; 4
    4d68:	29 c0       	rjmp	.+82     	; 0x4dbc <vfprintf+0x100>
    4d6a:	28 60       	ori	r18, 0x08	; 8
    4d6c:	27 c0       	rjmp	.+78     	; 0x4dbc <vfprintf+0x100>
    4d6e:	20 61       	ori	r18, 0x10	; 16
    4d70:	25 c0       	rjmp	.+74     	; 0x4dbc <vfprintf+0x100>
    4d72:	27 fd       	sbrc	r18, 7
    4d74:	2c c0       	rjmp	.+88     	; 0x4dce <vfprintf+0x112>
    4d76:	38 2f       	mov	r19, r24
    4d78:	30 53       	subi	r19, 0x30	; 48
    4d7a:	3a 30       	cpi	r19, 0x0A	; 10
    4d7c:	98 f4       	brcc	.+38     	; 0x4da4 <vfprintf+0xe8>
    4d7e:	26 ff       	sbrs	r18, 6
    4d80:	08 c0       	rjmp	.+16     	; 0x4d92 <vfprintf+0xd6>
    4d82:	8e 2d       	mov	r24, r14
    4d84:	88 0f       	add	r24, r24
    4d86:	e8 2e       	mov	r14, r24
    4d88:	ee 0c       	add	r14, r14
    4d8a:	ee 0c       	add	r14, r14
    4d8c:	e8 0e       	add	r14, r24
    4d8e:	e3 0e       	add	r14, r19
    4d90:	15 c0       	rjmp	.+42     	; 0x4dbc <vfprintf+0x100>
    4d92:	8f 2d       	mov	r24, r15
    4d94:	88 0f       	add	r24, r24
    4d96:	f8 2e       	mov	r15, r24
    4d98:	ff 0c       	add	r15, r15
    4d9a:	ff 0c       	add	r15, r15
    4d9c:	f8 0e       	add	r15, r24
    4d9e:	f3 0e       	add	r15, r19
    4da0:	20 62       	ori	r18, 0x20	; 32
    4da2:	0c c0       	rjmp	.+24     	; 0x4dbc <vfprintf+0x100>
    4da4:	8e 32       	cpi	r24, 0x2E	; 46
    4da6:	21 f4       	brne	.+8      	; 0x4db0 <vfprintf+0xf4>
    4da8:	26 fd       	sbrc	r18, 6
    4daa:	78 c1       	rjmp	.+752    	; 0x509c <vfprintf+0x3e0>
    4dac:	20 64       	ori	r18, 0x40	; 64
    4dae:	06 c0       	rjmp	.+12     	; 0x4dbc <vfprintf+0x100>
    4db0:	8c 36       	cpi	r24, 0x6C	; 108
    4db2:	11 f4       	brne	.+4      	; 0x4db8 <vfprintf+0xfc>
    4db4:	20 68       	ori	r18, 0x80	; 128
    4db6:	02 c0       	rjmp	.+4      	; 0x4dbc <vfprintf+0x100>
    4db8:	88 36       	cpi	r24, 0x68	; 104
    4dba:	49 f4       	brne	.+18     	; 0x4dce <vfprintf+0x112>
    4dbc:	f1 01       	movw	r30, r2
    4dbe:	93 fd       	sbrc	r25, 3
    4dc0:	85 91       	lpm	r24, Z+
    4dc2:	93 ff       	sbrs	r25, 3
    4dc4:	81 91       	ld	r24, Z+
    4dc6:	1f 01       	movw	r2, r30
    4dc8:	88 23       	and	r24, r24
    4dca:	09 f0       	breq	.+2      	; 0x4dce <vfprintf+0x112>
    4dcc:	ba cf       	rjmp	.-140    	; 0x4d42 <vfprintf+0x86>
    4dce:	98 2f       	mov	r25, r24
    4dd0:	95 54       	subi	r25, 0x45	; 69
    4dd2:	93 30       	cpi	r25, 0x03	; 3
    4dd4:	18 f0       	brcs	.+6      	; 0x4ddc <vfprintf+0x120>
    4dd6:	90 52       	subi	r25, 0x20	; 32
    4dd8:	93 30       	cpi	r25, 0x03	; 3
    4dda:	28 f4       	brcc	.+10     	; 0x4de6 <vfprintf+0x12a>
    4ddc:	0c 5f       	subi	r16, 0xFC	; 252
    4dde:	1f 4f       	sbci	r17, 0xFF	; 255
    4de0:	ff e3       	ldi	r31, 0x3F	; 63
    4de2:	f9 83       	std	Y+1, r31	; 0x01
    4de4:	0d c0       	rjmp	.+26     	; 0x4e00 <vfprintf+0x144>
    4de6:	83 36       	cpi	r24, 0x63	; 99
    4de8:	31 f0       	breq	.+12     	; 0x4df6 <vfprintf+0x13a>
    4dea:	83 37       	cpi	r24, 0x73	; 115
    4dec:	71 f0       	breq	.+28     	; 0x4e0a <vfprintf+0x14e>
    4dee:	83 35       	cpi	r24, 0x53	; 83
    4df0:	09 f0       	breq	.+2      	; 0x4df4 <vfprintf+0x138>
    4df2:	60 c0       	rjmp	.+192    	; 0x4eb4 <vfprintf+0x1f8>
    4df4:	22 c0       	rjmp	.+68     	; 0x4e3a <vfprintf+0x17e>
    4df6:	f8 01       	movw	r30, r16
    4df8:	80 81       	ld	r24, Z
    4dfa:	89 83       	std	Y+1, r24	; 0x01
    4dfc:	0e 5f       	subi	r16, 0xFE	; 254
    4dfe:	1f 4f       	sbci	r17, 0xFF	; 255
    4e00:	42 01       	movw	r8, r4
    4e02:	71 e0       	ldi	r23, 0x01	; 1
    4e04:	a7 2e       	mov	r10, r23
    4e06:	b1 2c       	mov	r11, r1
    4e08:	16 c0       	rjmp	.+44     	; 0x4e36 <vfprintf+0x17a>
    4e0a:	62 e0       	ldi	r22, 0x02	; 2
    4e0c:	66 2e       	mov	r6, r22
    4e0e:	71 2c       	mov	r7, r1
    4e10:	60 0e       	add	r6, r16
    4e12:	71 1e       	adc	r7, r17
    4e14:	f8 01       	movw	r30, r16
    4e16:	80 80       	ld	r8, Z
    4e18:	91 80       	ldd	r9, Z+1	; 0x01
    4e1a:	26 ff       	sbrs	r18, 6
    4e1c:	03 c0       	rjmp	.+6      	; 0x4e24 <vfprintf+0x168>
    4e1e:	6e 2d       	mov	r22, r14
    4e20:	70 e0       	ldi	r23, 0x00	; 0
    4e22:	02 c0       	rjmp	.+4      	; 0x4e28 <vfprintf+0x16c>
    4e24:	6f ef       	ldi	r22, 0xFF	; 255
    4e26:	7f ef       	ldi	r23, 0xFF	; 255
    4e28:	c4 01       	movw	r24, r8
    4e2a:	2c 87       	std	Y+12, r18	; 0x0c
    4e2c:	0e 94 a0 28 	call	0x5140	; 0x5140 <strnlen>
    4e30:	5c 01       	movw	r10, r24
    4e32:	83 01       	movw	r16, r6
    4e34:	2c 85       	ldd	r18, Y+12	; 0x0c
    4e36:	2f 77       	andi	r18, 0x7F	; 127
    4e38:	17 c0       	rjmp	.+46     	; 0x4e68 <vfprintf+0x1ac>
    4e3a:	52 e0       	ldi	r21, 0x02	; 2
    4e3c:	65 2e       	mov	r6, r21
    4e3e:	71 2c       	mov	r7, r1
    4e40:	60 0e       	add	r6, r16
    4e42:	71 1e       	adc	r7, r17
    4e44:	f8 01       	movw	r30, r16
    4e46:	80 80       	ld	r8, Z
    4e48:	91 80       	ldd	r9, Z+1	; 0x01
    4e4a:	26 ff       	sbrs	r18, 6
    4e4c:	03 c0       	rjmp	.+6      	; 0x4e54 <vfprintf+0x198>
    4e4e:	6e 2d       	mov	r22, r14
    4e50:	70 e0       	ldi	r23, 0x00	; 0
    4e52:	02 c0       	rjmp	.+4      	; 0x4e58 <vfprintf+0x19c>
    4e54:	6f ef       	ldi	r22, 0xFF	; 255
    4e56:	7f ef       	ldi	r23, 0xFF	; 255
    4e58:	c4 01       	movw	r24, r8
    4e5a:	2c 87       	std	Y+12, r18	; 0x0c
    4e5c:	0e 94 95 28 	call	0x512a	; 0x512a <strnlen_P>
    4e60:	5c 01       	movw	r10, r24
    4e62:	2c 85       	ldd	r18, Y+12	; 0x0c
    4e64:	20 68       	ori	r18, 0x80	; 128
    4e66:	83 01       	movw	r16, r6
    4e68:	23 fd       	sbrc	r18, 3
    4e6a:	20 c0       	rjmp	.+64     	; 0x4eac <vfprintf+0x1f0>
    4e6c:	08 c0       	rjmp	.+16     	; 0x4e7e <vfprintf+0x1c2>
    4e6e:	80 e2       	ldi	r24, 0x20	; 32
    4e70:	90 e0       	ldi	r25, 0x00	; 0
    4e72:	b6 01       	movw	r22, r12
    4e74:	2c 87       	std	Y+12, r18	; 0x0c
    4e76:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    4e7a:	fa 94       	dec	r15
    4e7c:	2c 85       	ldd	r18, Y+12	; 0x0c
    4e7e:	8f 2d       	mov	r24, r15
    4e80:	90 e0       	ldi	r25, 0x00	; 0
    4e82:	a8 16       	cp	r10, r24
    4e84:	b9 06       	cpc	r11, r25
    4e86:	98 f3       	brcs	.-26     	; 0x4e6e <vfprintf+0x1b2>
    4e88:	11 c0       	rjmp	.+34     	; 0x4eac <vfprintf+0x1f0>
    4e8a:	f4 01       	movw	r30, r8
    4e8c:	27 fd       	sbrc	r18, 7
    4e8e:	85 91       	lpm	r24, Z+
    4e90:	27 ff       	sbrs	r18, 7
    4e92:	81 91       	ld	r24, Z+
    4e94:	4f 01       	movw	r8, r30
    4e96:	90 e0       	ldi	r25, 0x00	; 0
    4e98:	b6 01       	movw	r22, r12
    4e9a:	2c 87       	std	Y+12, r18	; 0x0c
    4e9c:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    4ea0:	2c 85       	ldd	r18, Y+12	; 0x0c
    4ea2:	f1 10       	cpse	r15, r1
    4ea4:	fa 94       	dec	r15
    4ea6:	08 94       	sec
    4ea8:	a1 08       	sbc	r10, r1
    4eaa:	b1 08       	sbc	r11, r1
    4eac:	a1 14       	cp	r10, r1
    4eae:	b1 04       	cpc	r11, r1
    4eb0:	61 f7       	brne	.-40     	; 0x4e8a <vfprintf+0x1ce>
    4eb2:	f1 c0       	rjmp	.+482    	; 0x5096 <vfprintf+0x3da>
    4eb4:	84 36       	cpi	r24, 0x64	; 100
    4eb6:	11 f0       	breq	.+4      	; 0x4ebc <vfprintf+0x200>
    4eb8:	89 36       	cpi	r24, 0x69	; 105
    4eba:	49 f5       	brne	.+82     	; 0x4f0e <vfprintf+0x252>
    4ebc:	27 ff       	sbrs	r18, 7
    4ebe:	08 c0       	rjmp	.+16     	; 0x4ed0 <vfprintf+0x214>
    4ec0:	f8 01       	movw	r30, r16
    4ec2:	60 81       	ld	r22, Z
    4ec4:	71 81       	ldd	r23, Z+1	; 0x01
    4ec6:	82 81       	ldd	r24, Z+2	; 0x02
    4ec8:	93 81       	ldd	r25, Z+3	; 0x03
    4eca:	0c 5f       	subi	r16, 0xFC	; 252
    4ecc:	1f 4f       	sbci	r17, 0xFF	; 255
    4ece:	09 c0       	rjmp	.+18     	; 0x4ee2 <vfprintf+0x226>
    4ed0:	f8 01       	movw	r30, r16
    4ed2:	60 81       	ld	r22, Z
    4ed4:	71 81       	ldd	r23, Z+1	; 0x01
    4ed6:	88 27       	eor	r24, r24
    4ed8:	77 fd       	sbrc	r23, 7
    4eda:	80 95       	com	r24
    4edc:	98 2f       	mov	r25, r24
    4ede:	0e 5f       	subi	r16, 0xFE	; 254
    4ee0:	1f 4f       	sbci	r17, 0xFF	; 255
    4ee2:	4f e6       	ldi	r20, 0x6F	; 111
    4ee4:	b4 2e       	mov	r11, r20
    4ee6:	b2 22       	and	r11, r18
    4ee8:	97 ff       	sbrs	r25, 7
    4eea:	09 c0       	rjmp	.+18     	; 0x4efe <vfprintf+0x242>
    4eec:	90 95       	com	r25
    4eee:	80 95       	com	r24
    4ef0:	70 95       	com	r23
    4ef2:	61 95       	neg	r22
    4ef4:	7f 4f       	sbci	r23, 0xFF	; 255
    4ef6:	8f 4f       	sbci	r24, 0xFF	; 255
    4ef8:	9f 4f       	sbci	r25, 0xFF	; 255
    4efa:	f0 e8       	ldi	r31, 0x80	; 128
    4efc:	bf 2a       	or	r11, r31
    4efe:	a2 01       	movw	r20, r4
    4f00:	2a e0       	ldi	r18, 0x0A	; 10
    4f02:	30 e0       	ldi	r19, 0x00	; 0
    4f04:	0e 94 d7 28 	call	0x51ae	; 0x51ae <__ultoa_invert>
    4f08:	78 2e       	mov	r7, r24
    4f0a:	74 18       	sub	r7, r4
    4f0c:	45 c0       	rjmp	.+138    	; 0x4f98 <vfprintf+0x2dc>
    4f0e:	85 37       	cpi	r24, 0x75	; 117
    4f10:	31 f4       	brne	.+12     	; 0x4f1e <vfprintf+0x262>
    4f12:	3f ee       	ldi	r19, 0xEF	; 239
    4f14:	b3 2e       	mov	r11, r19
    4f16:	b2 22       	and	r11, r18
    4f18:	2a e0       	ldi	r18, 0x0A	; 10
    4f1a:	30 e0       	ldi	r19, 0x00	; 0
    4f1c:	25 c0       	rjmp	.+74     	; 0x4f68 <vfprintf+0x2ac>
    4f1e:	99 ef       	ldi	r25, 0xF9	; 249
    4f20:	b9 2e       	mov	r11, r25
    4f22:	b2 22       	and	r11, r18
    4f24:	8f 36       	cpi	r24, 0x6F	; 111
    4f26:	c1 f0       	breq	.+48     	; 0x4f58 <vfprintf+0x29c>
    4f28:	80 37       	cpi	r24, 0x70	; 112
    4f2a:	20 f4       	brcc	.+8      	; 0x4f34 <vfprintf+0x278>
    4f2c:	88 35       	cpi	r24, 0x58	; 88
    4f2e:	09 f0       	breq	.+2      	; 0x4f32 <vfprintf+0x276>
    4f30:	b5 c0       	rjmp	.+362    	; 0x509c <vfprintf+0x3e0>
    4f32:	0d c0       	rjmp	.+26     	; 0x4f4e <vfprintf+0x292>
    4f34:	80 37       	cpi	r24, 0x70	; 112
    4f36:	21 f0       	breq	.+8      	; 0x4f40 <vfprintf+0x284>
    4f38:	88 37       	cpi	r24, 0x78	; 120
    4f3a:	09 f0       	breq	.+2      	; 0x4f3e <vfprintf+0x282>
    4f3c:	af c0       	rjmp	.+350    	; 0x509c <vfprintf+0x3e0>
    4f3e:	02 c0       	rjmp	.+4      	; 0x4f44 <vfprintf+0x288>
    4f40:	20 e1       	ldi	r18, 0x10	; 16
    4f42:	b2 2a       	or	r11, r18
    4f44:	b4 fe       	sbrs	r11, 4
    4f46:	0b c0       	rjmp	.+22     	; 0x4f5e <vfprintf+0x2a2>
    4f48:	84 e0       	ldi	r24, 0x04	; 4
    4f4a:	b8 2a       	or	r11, r24
    4f4c:	08 c0       	rjmp	.+16     	; 0x4f5e <vfprintf+0x2a2>
    4f4e:	b4 fe       	sbrs	r11, 4
    4f50:	09 c0       	rjmp	.+18     	; 0x4f64 <vfprintf+0x2a8>
    4f52:	e6 e0       	ldi	r30, 0x06	; 6
    4f54:	be 2a       	or	r11, r30
    4f56:	06 c0       	rjmp	.+12     	; 0x4f64 <vfprintf+0x2a8>
    4f58:	28 e0       	ldi	r18, 0x08	; 8
    4f5a:	30 e0       	ldi	r19, 0x00	; 0
    4f5c:	05 c0       	rjmp	.+10     	; 0x4f68 <vfprintf+0x2ac>
    4f5e:	20 e1       	ldi	r18, 0x10	; 16
    4f60:	30 e0       	ldi	r19, 0x00	; 0
    4f62:	02 c0       	rjmp	.+4      	; 0x4f68 <vfprintf+0x2ac>
    4f64:	20 e1       	ldi	r18, 0x10	; 16
    4f66:	32 e0       	ldi	r19, 0x02	; 2
    4f68:	b7 fe       	sbrs	r11, 7
    4f6a:	08 c0       	rjmp	.+16     	; 0x4f7c <vfprintf+0x2c0>
    4f6c:	f8 01       	movw	r30, r16
    4f6e:	60 81       	ld	r22, Z
    4f70:	71 81       	ldd	r23, Z+1	; 0x01
    4f72:	82 81       	ldd	r24, Z+2	; 0x02
    4f74:	93 81       	ldd	r25, Z+3	; 0x03
    4f76:	0c 5f       	subi	r16, 0xFC	; 252
    4f78:	1f 4f       	sbci	r17, 0xFF	; 255
    4f7a:	07 c0       	rjmp	.+14     	; 0x4f8a <vfprintf+0x2ce>
    4f7c:	f8 01       	movw	r30, r16
    4f7e:	60 81       	ld	r22, Z
    4f80:	71 81       	ldd	r23, Z+1	; 0x01
    4f82:	80 e0       	ldi	r24, 0x00	; 0
    4f84:	90 e0       	ldi	r25, 0x00	; 0
    4f86:	0e 5f       	subi	r16, 0xFE	; 254
    4f88:	1f 4f       	sbci	r17, 0xFF	; 255
    4f8a:	a2 01       	movw	r20, r4
    4f8c:	0e 94 d7 28 	call	0x51ae	; 0x51ae <__ultoa_invert>
    4f90:	78 2e       	mov	r7, r24
    4f92:	74 18       	sub	r7, r4
    4f94:	ff e7       	ldi	r31, 0x7F	; 127
    4f96:	bf 22       	and	r11, r31
    4f98:	b6 fe       	sbrs	r11, 6
    4f9a:	0b c0       	rjmp	.+22     	; 0x4fb2 <vfprintf+0x2f6>
    4f9c:	2e ef       	ldi	r18, 0xFE	; 254
    4f9e:	b2 22       	and	r11, r18
    4fa0:	7e 14       	cp	r7, r14
    4fa2:	38 f4       	brcc	.+14     	; 0x4fb2 <vfprintf+0x2f6>
    4fa4:	b4 fe       	sbrs	r11, 4
    4fa6:	07 c0       	rjmp	.+14     	; 0x4fb6 <vfprintf+0x2fa>
    4fa8:	b2 fc       	sbrc	r11, 2
    4faa:	05 c0       	rjmp	.+10     	; 0x4fb6 <vfprintf+0x2fa>
    4fac:	8f ee       	ldi	r24, 0xEF	; 239
    4fae:	b8 22       	and	r11, r24
    4fb0:	02 c0       	rjmp	.+4      	; 0x4fb6 <vfprintf+0x2fa>
    4fb2:	a7 2c       	mov	r10, r7
    4fb4:	01 c0       	rjmp	.+2      	; 0x4fb8 <vfprintf+0x2fc>
    4fb6:	ae 2c       	mov	r10, r14
    4fb8:	8b 2d       	mov	r24, r11
    4fba:	90 e0       	ldi	r25, 0x00	; 0
    4fbc:	b4 fe       	sbrs	r11, 4
    4fbe:	0d c0       	rjmp	.+26     	; 0x4fda <vfprintf+0x31e>
    4fc0:	fe 01       	movw	r30, r28
    4fc2:	e7 0d       	add	r30, r7
    4fc4:	f1 1d       	adc	r31, r1
    4fc6:	20 81       	ld	r18, Z
    4fc8:	20 33       	cpi	r18, 0x30	; 48
    4fca:	19 f4       	brne	.+6      	; 0x4fd2 <vfprintf+0x316>
    4fcc:	e9 ee       	ldi	r30, 0xE9	; 233
    4fce:	be 22       	and	r11, r30
    4fd0:	09 c0       	rjmp	.+18     	; 0x4fe4 <vfprintf+0x328>
    4fd2:	a3 94       	inc	r10
    4fd4:	b2 fe       	sbrs	r11, 2
    4fd6:	06 c0       	rjmp	.+12     	; 0x4fe4 <vfprintf+0x328>
    4fd8:	04 c0       	rjmp	.+8      	; 0x4fe2 <vfprintf+0x326>
    4fda:	86 78       	andi	r24, 0x86	; 134
    4fdc:	90 70       	andi	r25, 0x00	; 0
    4fde:	00 97       	sbiw	r24, 0x00	; 0
    4fe0:	09 f0       	breq	.+2      	; 0x4fe4 <vfprintf+0x328>
    4fe2:	a3 94       	inc	r10
    4fe4:	8b 2c       	mov	r8, r11
    4fe6:	99 24       	eor	r9, r9
    4fe8:	b3 fc       	sbrc	r11, 3
    4fea:	14 c0       	rjmp	.+40     	; 0x5014 <vfprintf+0x358>
    4fec:	b0 fe       	sbrs	r11, 0
    4fee:	0f c0       	rjmp	.+30     	; 0x500e <vfprintf+0x352>
    4ff0:	af 14       	cp	r10, r15
    4ff2:	28 f4       	brcc	.+10     	; 0x4ffe <vfprintf+0x342>
    4ff4:	e7 2c       	mov	r14, r7
    4ff6:	ef 0c       	add	r14, r15
    4ff8:	ea 18       	sub	r14, r10
    4ffa:	af 2c       	mov	r10, r15
    4ffc:	08 c0       	rjmp	.+16     	; 0x500e <vfprintf+0x352>
    4ffe:	e7 2c       	mov	r14, r7
    5000:	06 c0       	rjmp	.+12     	; 0x500e <vfprintf+0x352>
    5002:	80 e2       	ldi	r24, 0x20	; 32
    5004:	90 e0       	ldi	r25, 0x00	; 0
    5006:	b6 01       	movw	r22, r12
    5008:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    500c:	a3 94       	inc	r10
    500e:	af 14       	cp	r10, r15
    5010:	c0 f3       	brcs	.-16     	; 0x5002 <vfprintf+0x346>
    5012:	04 c0       	rjmp	.+8      	; 0x501c <vfprintf+0x360>
    5014:	af 14       	cp	r10, r15
    5016:	10 f4       	brcc	.+4      	; 0x501c <vfprintf+0x360>
    5018:	fa 18       	sub	r15, r10
    501a:	01 c0       	rjmp	.+2      	; 0x501e <vfprintf+0x362>
    501c:	ff 24       	eor	r15, r15
    501e:	84 fe       	sbrs	r8, 4
    5020:	0f c0       	rjmp	.+30     	; 0x5040 <vfprintf+0x384>
    5022:	80 e3       	ldi	r24, 0x30	; 48
    5024:	90 e0       	ldi	r25, 0x00	; 0
    5026:	b6 01       	movw	r22, r12
    5028:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    502c:	82 fe       	sbrs	r8, 2
    502e:	1f c0       	rjmp	.+62     	; 0x506e <vfprintf+0x3b2>
    5030:	81 fe       	sbrs	r8, 1
    5032:	03 c0       	rjmp	.+6      	; 0x503a <vfprintf+0x37e>
    5034:	88 e5       	ldi	r24, 0x58	; 88
    5036:	90 e0       	ldi	r25, 0x00	; 0
    5038:	10 c0       	rjmp	.+32     	; 0x505a <vfprintf+0x39e>
    503a:	88 e7       	ldi	r24, 0x78	; 120
    503c:	90 e0       	ldi	r25, 0x00	; 0
    503e:	0d c0       	rjmp	.+26     	; 0x505a <vfprintf+0x39e>
    5040:	c4 01       	movw	r24, r8
    5042:	86 78       	andi	r24, 0x86	; 134
    5044:	90 70       	andi	r25, 0x00	; 0
    5046:	00 97       	sbiw	r24, 0x00	; 0
    5048:	91 f0       	breq	.+36     	; 0x506e <vfprintf+0x3b2>
    504a:	81 fc       	sbrc	r8, 1
    504c:	02 c0       	rjmp	.+4      	; 0x5052 <vfprintf+0x396>
    504e:	80 e2       	ldi	r24, 0x20	; 32
    5050:	01 c0       	rjmp	.+2      	; 0x5054 <vfprintf+0x398>
    5052:	8b e2       	ldi	r24, 0x2B	; 43
    5054:	b7 fc       	sbrc	r11, 7
    5056:	8d e2       	ldi	r24, 0x2D	; 45
    5058:	90 e0       	ldi	r25, 0x00	; 0
    505a:	b6 01       	movw	r22, r12
    505c:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    5060:	06 c0       	rjmp	.+12     	; 0x506e <vfprintf+0x3b2>
    5062:	80 e3       	ldi	r24, 0x30	; 48
    5064:	90 e0       	ldi	r25, 0x00	; 0
    5066:	b6 01       	movw	r22, r12
    5068:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    506c:	ea 94       	dec	r14
    506e:	7e 14       	cp	r7, r14
    5070:	c0 f3       	brcs	.-16     	; 0x5062 <vfprintf+0x3a6>
    5072:	7a 94       	dec	r7
    5074:	f2 01       	movw	r30, r4
    5076:	e7 0d       	add	r30, r7
    5078:	f1 1d       	adc	r31, r1
    507a:	80 81       	ld	r24, Z
    507c:	90 e0       	ldi	r25, 0x00	; 0
    507e:	b6 01       	movw	r22, r12
    5080:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    5084:	77 20       	and	r7, r7
    5086:	a9 f7       	brne	.-22     	; 0x5072 <vfprintf+0x3b6>
    5088:	06 c0       	rjmp	.+12     	; 0x5096 <vfprintf+0x3da>
    508a:	80 e2       	ldi	r24, 0x20	; 32
    508c:	90 e0       	ldi	r25, 0x00	; 0
    508e:	b6 01       	movw	r22, r12
    5090:	0e 94 ab 28 	call	0x5156	; 0x5156 <fputc>
    5094:	fa 94       	dec	r15
    5096:	ff 20       	and	r15, r15
    5098:	c1 f7       	brne	.-16     	; 0x508a <vfprintf+0x3ce>
    509a:	37 ce       	rjmp	.-914    	; 0x4d0a <vfprintf+0x4e>
    509c:	f6 01       	movw	r30, r12
    509e:	26 81       	ldd	r18, Z+6	; 0x06
    50a0:	37 81       	ldd	r19, Z+7	; 0x07
    50a2:	02 c0       	rjmp	.+4      	; 0x50a8 <vfprintf+0x3ec>
    50a4:	2f ef       	ldi	r18, 0xFF	; 255
    50a6:	3f ef       	ldi	r19, 0xFF	; 255
    50a8:	c9 01       	movw	r24, r18
    50aa:	2c 96       	adiw	r28, 0x0c	; 12
    50ac:	0f b6       	in	r0, 0x3f	; 63
    50ae:	f8 94       	cli
    50b0:	de bf       	out	0x3e, r29	; 62
    50b2:	0f be       	out	0x3f, r0	; 63
    50b4:	cd bf       	out	0x3d, r28	; 61
    50b6:	cf 91       	pop	r28
    50b8:	df 91       	pop	r29
    50ba:	1f 91       	pop	r17
    50bc:	0f 91       	pop	r16
    50be:	ff 90       	pop	r15
    50c0:	ef 90       	pop	r14
    50c2:	df 90       	pop	r13
    50c4:	cf 90       	pop	r12
    50c6:	bf 90       	pop	r11
    50c8:	af 90       	pop	r10
    50ca:	9f 90       	pop	r9
    50cc:	8f 90       	pop	r8
    50ce:	7f 90       	pop	r7
    50d0:	6f 90       	pop	r6
    50d2:	5f 90       	pop	r5
    50d4:	4f 90       	pop	r4
    50d6:	3f 90       	pop	r3
    50d8:	2f 90       	pop	r2
    50da:	08 95       	ret

000050dc <__eerd_block_m128>:
    50dc:	dc 01       	movw	r26, r24
    50de:	cb 01       	movw	r24, r22

000050e0 <__eerd_blraw_m128>:
    50e0:	fc 01       	movw	r30, r24
    50e2:	e1 99       	sbic	0x1c, 1	; 28
    50e4:	fe cf       	rjmp	.-4      	; 0x50e2 <__eerd_blraw_m128+0x2>
    50e6:	06 c0       	rjmp	.+12     	; 0x50f4 <__eerd_blraw_m128+0x14>
    50e8:	ff bb       	out	0x1f, r31	; 31
    50ea:	ee bb       	out	0x1e, r30	; 30
    50ec:	e0 9a       	sbi	0x1c, 0	; 28
    50ee:	31 96       	adiw	r30, 0x01	; 1
    50f0:	0d b2       	in	r0, 0x1d	; 29
    50f2:	0d 92       	st	X+, r0
    50f4:	41 50       	subi	r20, 0x01	; 1
    50f6:	50 40       	sbci	r21, 0x00	; 0
    50f8:	b8 f7       	brcc	.-18     	; 0x50e8 <__eerd_blraw_m128+0x8>
    50fa:	08 95       	ret

000050fc <__eewr_block_m128>:
    50fc:	dc 01       	movw	r26, r24
    50fe:	cb 01       	movw	r24, r22
    5100:	03 c0       	rjmp	.+6      	; 0x5108 <__eewr_block_m128+0xc>
    5102:	2d 91       	ld	r18, X+
    5104:	0e 94 89 28 	call	0x5112	; 0x5112 <__eewr_r18_m128>
    5108:	41 50       	subi	r20, 0x01	; 1
    510a:	50 40       	sbci	r21, 0x00	; 0
    510c:	d0 f7       	brcc	.-12     	; 0x5102 <__eewr_block_m128+0x6>
    510e:	08 95       	ret

00005110 <__eewr_byte_m128>:
    5110:	26 2f       	mov	r18, r22

00005112 <__eewr_r18_m128>:
    5112:	e1 99       	sbic	0x1c, 1	; 28
    5114:	fe cf       	rjmp	.-4      	; 0x5112 <__eewr_r18_m128>
    5116:	9f bb       	out	0x1f, r25	; 31
    5118:	8e bb       	out	0x1e, r24	; 30
    511a:	2d bb       	out	0x1d, r18	; 29
    511c:	0f b6       	in	r0, 0x3f	; 63
    511e:	f8 94       	cli
    5120:	e2 9a       	sbi	0x1c, 2	; 28
    5122:	e1 9a       	sbi	0x1c, 1	; 28
    5124:	0f be       	out	0x3f, r0	; 63
    5126:	01 96       	adiw	r24, 0x01	; 1
    5128:	08 95       	ret

0000512a <strnlen_P>:
    512a:	fc 01       	movw	r30, r24
    512c:	05 90       	lpm	r0, Z+
    512e:	61 50       	subi	r22, 0x01	; 1
    5130:	70 40       	sbci	r23, 0x00	; 0
    5132:	01 10       	cpse	r0, r1
    5134:	d8 f7       	brcc	.-10     	; 0x512c <strnlen_P+0x2>
    5136:	80 95       	com	r24
    5138:	90 95       	com	r25
    513a:	8e 0f       	add	r24, r30
    513c:	9f 1f       	adc	r25, r31
    513e:	08 95       	ret

00005140 <strnlen>:
    5140:	fc 01       	movw	r30, r24
    5142:	61 50       	subi	r22, 0x01	; 1
    5144:	70 40       	sbci	r23, 0x00	; 0
    5146:	01 90       	ld	r0, Z+
    5148:	01 10       	cpse	r0, r1
    514a:	d8 f7       	brcc	.-10     	; 0x5142 <strnlen+0x2>
    514c:	80 95       	com	r24
    514e:	90 95       	com	r25
    5150:	8e 0f       	add	r24, r30
    5152:	9f 1f       	adc	r25, r31
    5154:	08 95       	ret

00005156 <fputc>:
    5156:	0f 93       	push	r16
    5158:	1f 93       	push	r17
    515a:	cf 93       	push	r28
    515c:	df 93       	push	r29
    515e:	8c 01       	movw	r16, r24
    5160:	eb 01       	movw	r28, r22
    5162:	8b 81       	ldd	r24, Y+3	; 0x03
    5164:	81 ff       	sbrs	r24, 1
    5166:	1b c0       	rjmp	.+54     	; 0x519e <fputc+0x48>
    5168:	82 ff       	sbrs	r24, 2
    516a:	0d c0       	rjmp	.+26     	; 0x5186 <fputc+0x30>
    516c:	2e 81       	ldd	r18, Y+6	; 0x06
    516e:	3f 81       	ldd	r19, Y+7	; 0x07
    5170:	8c 81       	ldd	r24, Y+4	; 0x04
    5172:	9d 81       	ldd	r25, Y+5	; 0x05
    5174:	28 17       	cp	r18, r24
    5176:	39 07       	cpc	r19, r25
    5178:	64 f4       	brge	.+24     	; 0x5192 <fputc+0x3c>
    517a:	e8 81       	ld	r30, Y
    517c:	f9 81       	ldd	r31, Y+1	; 0x01
    517e:	01 93       	st	Z+, r16
    5180:	f9 83       	std	Y+1, r31	; 0x01
    5182:	e8 83       	st	Y, r30
    5184:	06 c0       	rjmp	.+12     	; 0x5192 <fputc+0x3c>
    5186:	e8 85       	ldd	r30, Y+8	; 0x08
    5188:	f9 85       	ldd	r31, Y+9	; 0x09
    518a:	80 2f       	mov	r24, r16
    518c:	09 95       	icall
    518e:	00 97       	sbiw	r24, 0x00	; 0
    5190:	31 f4       	brne	.+12     	; 0x519e <fputc+0x48>
    5192:	8e 81       	ldd	r24, Y+6	; 0x06
    5194:	9f 81       	ldd	r25, Y+7	; 0x07
    5196:	01 96       	adiw	r24, 0x01	; 1
    5198:	9f 83       	std	Y+7, r25	; 0x07
    519a:	8e 83       	std	Y+6, r24	; 0x06
    519c:	02 c0       	rjmp	.+4      	; 0x51a2 <fputc+0x4c>
    519e:	0f ef       	ldi	r16, 0xFF	; 255
    51a0:	1f ef       	ldi	r17, 0xFF	; 255
    51a2:	c8 01       	movw	r24, r16
    51a4:	df 91       	pop	r29
    51a6:	cf 91       	pop	r28
    51a8:	1f 91       	pop	r17
    51aa:	0f 91       	pop	r16
    51ac:	08 95       	ret

000051ae <__ultoa_invert>:
    51ae:	fa 01       	movw	r30, r20
    51b0:	aa 27       	eor	r26, r26
    51b2:	28 30       	cpi	r18, 0x08	; 8
    51b4:	51 f1       	breq	.+84     	; 0x520a <__ultoa_invert+0x5c>
    51b6:	20 31       	cpi	r18, 0x10	; 16
    51b8:	81 f1       	breq	.+96     	; 0x521a <__ultoa_invert+0x6c>
    51ba:	e8 94       	clt
    51bc:	6f 93       	push	r22
    51be:	6e 7f       	andi	r22, 0xFE	; 254
    51c0:	6e 5f       	subi	r22, 0xFE	; 254
    51c2:	7f 4f       	sbci	r23, 0xFF	; 255
    51c4:	8f 4f       	sbci	r24, 0xFF	; 255
    51c6:	9f 4f       	sbci	r25, 0xFF	; 255
    51c8:	af 4f       	sbci	r26, 0xFF	; 255
    51ca:	b1 e0       	ldi	r27, 0x01	; 1
    51cc:	3e d0       	rcall	.+124    	; 0x524a <__ultoa_invert+0x9c>
    51ce:	b4 e0       	ldi	r27, 0x04	; 4
    51d0:	3c d0       	rcall	.+120    	; 0x524a <__ultoa_invert+0x9c>
    51d2:	67 0f       	add	r22, r23
    51d4:	78 1f       	adc	r23, r24
    51d6:	89 1f       	adc	r24, r25
    51d8:	9a 1f       	adc	r25, r26
    51da:	a1 1d       	adc	r26, r1
    51dc:	68 0f       	add	r22, r24
    51de:	79 1f       	adc	r23, r25
    51e0:	8a 1f       	adc	r24, r26
    51e2:	91 1d       	adc	r25, r1
    51e4:	a1 1d       	adc	r26, r1
    51e6:	6a 0f       	add	r22, r26
    51e8:	71 1d       	adc	r23, r1
    51ea:	81 1d       	adc	r24, r1
    51ec:	91 1d       	adc	r25, r1
    51ee:	a1 1d       	adc	r26, r1
    51f0:	20 d0       	rcall	.+64     	; 0x5232 <__ultoa_invert+0x84>
    51f2:	09 f4       	brne	.+2      	; 0x51f6 <__ultoa_invert+0x48>
    51f4:	68 94       	set
    51f6:	3f 91       	pop	r19
    51f8:	2a e0       	ldi	r18, 0x0A	; 10
    51fa:	26 9f       	mul	r18, r22
    51fc:	11 24       	eor	r1, r1
    51fe:	30 19       	sub	r19, r0
    5200:	30 5d       	subi	r19, 0xD0	; 208
    5202:	31 93       	st	Z+, r19
    5204:	de f6       	brtc	.-74     	; 0x51bc <__ultoa_invert+0xe>
    5206:	cf 01       	movw	r24, r30
    5208:	08 95       	ret
    520a:	46 2f       	mov	r20, r22
    520c:	47 70       	andi	r20, 0x07	; 7
    520e:	40 5d       	subi	r20, 0xD0	; 208
    5210:	41 93       	st	Z+, r20
    5212:	b3 e0       	ldi	r27, 0x03	; 3
    5214:	0f d0       	rcall	.+30     	; 0x5234 <__ultoa_invert+0x86>
    5216:	c9 f7       	brne	.-14     	; 0x520a <__ultoa_invert+0x5c>
    5218:	f6 cf       	rjmp	.-20     	; 0x5206 <__ultoa_invert+0x58>
    521a:	46 2f       	mov	r20, r22
    521c:	4f 70       	andi	r20, 0x0F	; 15
    521e:	40 5d       	subi	r20, 0xD0	; 208
    5220:	4a 33       	cpi	r20, 0x3A	; 58
    5222:	18 f0       	brcs	.+6      	; 0x522a <__ultoa_invert+0x7c>
    5224:	49 5d       	subi	r20, 0xD9	; 217
    5226:	31 fd       	sbrc	r19, 1
    5228:	40 52       	subi	r20, 0x20	; 32
    522a:	41 93       	st	Z+, r20
    522c:	02 d0       	rcall	.+4      	; 0x5232 <__ultoa_invert+0x84>
    522e:	a9 f7       	brne	.-22     	; 0x521a <__ultoa_invert+0x6c>
    5230:	ea cf       	rjmp	.-44     	; 0x5206 <__ultoa_invert+0x58>
    5232:	b4 e0       	ldi	r27, 0x04	; 4
    5234:	a6 95       	lsr	r26
    5236:	97 95       	ror	r25
    5238:	87 95       	ror	r24
    523a:	77 95       	ror	r23
    523c:	67 95       	ror	r22
    523e:	ba 95       	dec	r27
    5240:	c9 f7       	brne	.-14     	; 0x5234 <__ultoa_invert+0x86>
    5242:	00 97       	sbiw	r24, 0x00	; 0
    5244:	61 05       	cpc	r22, r1
    5246:	71 05       	cpc	r23, r1
    5248:	08 95       	ret
    524a:	9b 01       	movw	r18, r22
    524c:	ac 01       	movw	r20, r24
    524e:	0a 2e       	mov	r0, r26
    5250:	06 94       	lsr	r0
    5252:	57 95       	ror	r21
    5254:	47 95       	ror	r20
    5256:	37 95       	ror	r19
    5258:	27 95       	ror	r18
    525a:	ba 95       	dec	r27
    525c:	c9 f7       	brne	.-14     	; 0x5250 <__ultoa_invert+0xa2>
    525e:	62 0f       	add	r22, r18
    5260:	73 1f       	adc	r23, r19
    5262:	84 1f       	adc	r24, r20
    5264:	95 1f       	adc	r25, r21
    5266:	a0 1d       	adc	r26, r0
    5268:	08 95       	ret

0000526a <__mulsi3>:
    526a:	62 9f       	mul	r22, r18
    526c:	d0 01       	movw	r26, r0
    526e:	73 9f       	mul	r23, r19
    5270:	f0 01       	movw	r30, r0
    5272:	82 9f       	mul	r24, r18
    5274:	e0 0d       	add	r30, r0
    5276:	f1 1d       	adc	r31, r1
    5278:	64 9f       	mul	r22, r20
    527a:	e0 0d       	add	r30, r0
    527c:	f1 1d       	adc	r31, r1
    527e:	92 9f       	mul	r25, r18
    5280:	f0 0d       	add	r31, r0
    5282:	83 9f       	mul	r24, r19
    5284:	f0 0d       	add	r31, r0
    5286:	74 9f       	mul	r23, r20
    5288:	f0 0d       	add	r31, r0
    528a:	65 9f       	mul	r22, r21
    528c:	f0 0d       	add	r31, r0
    528e:	99 27       	eor	r25, r25
    5290:	72 9f       	mul	r23, r18
    5292:	b0 0d       	add	r27, r0
    5294:	e1 1d       	adc	r30, r1
    5296:	f9 1f       	adc	r31, r25
    5298:	63 9f       	mul	r22, r19
    529a:	b0 0d       	add	r27, r0
    529c:	e1 1d       	adc	r30, r1
    529e:	f9 1f       	adc	r31, r25
    52a0:	bd 01       	movw	r22, r26
    52a2:	cf 01       	movw	r24, r30
    52a4:	11 24       	eor	r1, r1
    52a6:	08 95       	ret

000052a8 <__divmodsi4>:
    52a8:	97 fb       	bst	r25, 7
    52aa:	09 2e       	mov	r0, r25
    52ac:	05 26       	eor	r0, r21
    52ae:	0e d0       	rcall	.+28     	; 0x52cc <__divmodsi4_neg1>
    52b0:	57 fd       	sbrc	r21, 7
    52b2:	04 d0       	rcall	.+8      	; 0x52bc <__divmodsi4_neg2>
    52b4:	14 d0       	rcall	.+40     	; 0x52de <__udivmodsi4>
    52b6:	0a d0       	rcall	.+20     	; 0x52cc <__divmodsi4_neg1>
    52b8:	00 1c       	adc	r0, r0
    52ba:	38 f4       	brcc	.+14     	; 0x52ca <__divmodsi4_exit>

000052bc <__divmodsi4_neg2>:
    52bc:	50 95       	com	r21
    52be:	40 95       	com	r20
    52c0:	30 95       	com	r19
    52c2:	21 95       	neg	r18
    52c4:	3f 4f       	sbci	r19, 0xFF	; 255
    52c6:	4f 4f       	sbci	r20, 0xFF	; 255
    52c8:	5f 4f       	sbci	r21, 0xFF	; 255

000052ca <__divmodsi4_exit>:
    52ca:	08 95       	ret

000052cc <__divmodsi4_neg1>:
    52cc:	f6 f7       	brtc	.-4      	; 0x52ca <__divmodsi4_exit>
    52ce:	90 95       	com	r25
    52d0:	80 95       	com	r24
    52d2:	70 95       	com	r23
    52d4:	61 95       	neg	r22
    52d6:	7f 4f       	sbci	r23, 0xFF	; 255
    52d8:	8f 4f       	sbci	r24, 0xFF	; 255
    52da:	9f 4f       	sbci	r25, 0xFF	; 255
    52dc:	08 95       	ret

000052de <__udivmodsi4>:
    52de:	a1 e2       	ldi	r26, 0x21	; 33
    52e0:	1a 2e       	mov	r1, r26
    52e2:	aa 1b       	sub	r26, r26
    52e4:	bb 1b       	sub	r27, r27
    52e6:	fd 01       	movw	r30, r26
    52e8:	0d c0       	rjmp	.+26     	; 0x5304 <__udivmodsi4_ep>

000052ea <__udivmodsi4_loop>:
    52ea:	aa 1f       	adc	r26, r26
    52ec:	bb 1f       	adc	r27, r27
    52ee:	ee 1f       	adc	r30, r30
    52f0:	ff 1f       	adc	r31, r31
    52f2:	a2 17       	cp	r26, r18
    52f4:	b3 07       	cpc	r27, r19
    52f6:	e4 07       	cpc	r30, r20
    52f8:	f5 07       	cpc	r31, r21
    52fa:	20 f0       	brcs	.+8      	; 0x5304 <__udivmodsi4_ep>
    52fc:	a2 1b       	sub	r26, r18
    52fe:	b3 0b       	sbc	r27, r19
    5300:	e4 0b       	sbc	r30, r20
    5302:	f5 0b       	sbc	r31, r21

00005304 <__udivmodsi4_ep>:
    5304:	66 1f       	adc	r22, r22
    5306:	77 1f       	adc	r23, r23
    5308:	88 1f       	adc	r24, r24
    530a:	99 1f       	adc	r25, r25
    530c:	1a 94       	dec	r1
    530e:	69 f7       	brne	.-38     	; 0x52ea <__udivmodsi4_loop>
    5310:	60 95       	com	r22
    5312:	70 95       	com	r23
    5314:	80 95       	com	r24
    5316:	90 95       	com	r25
    5318:	9b 01       	movw	r18, r22
    531a:	ac 01       	movw	r20, r24
    531c:	bd 01       	movw	r22, r26
    531e:	cf 01       	movw	r24, r30
    5320:	08 95       	ret

00005322 <_exit>:
    5322:	f8 94       	cli

00005324 <__stop_program>:
    5324:	ff cf       	rjmp	.-2      	; 0x5324 <__stop_program>
